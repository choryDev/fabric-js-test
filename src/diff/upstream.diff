diff --git a/README.md b/README.md
index cbc9a43f..9540ecfb 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
 ## Fabric.js
-.
+
 <!-- build/coverage status, climate -->
 
 [![Build Status](https://secure.travis-ci.org/fabricjs/fabric.js.svg?branch=master)](http://travis-ci.org/#!/kangax/fabric.js)
diff --git a/build.js b/build.js
index 38f3b45a..be656cf1 100644
--- a/build.js
+++ b/build.js
@@ -195,6 +195,8 @@ var filesToInclude = [
   'src/shapes/polygon.class.js',
   'src/shapes/path.class.js',
   'src/shapes/group.class.js',
+  'src/shapes/icollection.class.js',
+  'src/shapes/layer.class.js',
   ifSpecifiedInclude('interaction', 'src/shapes/active_selection.class.js'),
   'src/shapes/image.class.js',
 
diff --git a/dist/fabric.js b/dist/fabric.js
index 86536ce0..09fcb85a 100644
--- a/dist/fabric.js
+++ b/dist/fabric.js
@@ -1,4 +1,4 @@
-/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */
+/* build: `node build.js modules=ALL requirejs minifier=uglifyjs` */
 /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
 
 var fabric = fabric || { version: '4.6.0' };
@@ -210,6 +210,1967 @@ if (typeof document !== 'undefined' && typeof window !== 'undefined') {
 }
 
 
+/*:
+	----------------------------------------------------
+	event.js : 1.1.5 : 2014/02/12 : MIT License
+	----------------------------------------------------
+	https://github.com/mudcube/Event.js
+	----------------------------------------------------
+	1  : click, dblclick, dbltap
+	1+ : tap, longpress, drag, swipe
+	2+ : pinch, rotate
+	   : mousewheel, devicemotion, shake
+	----------------------------------------------------
+	Ideas for the future
+	----------------------------------------------------
+	* GamePad, and other input abstractions.
+	* Event batching - i.e. for every x fingers down a new gesture is created.
+	----------------------------------------------------
+	http://www.w3.org/TR/2011/WD-touch-events-20110505/
+	----------------------------------------------------
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+
+(function(root) { "use strict";
+
+// Add custom *EventListener commands to HTMLElements (set false to prevent funkiness).
+root.modifyEventListener = false;
+
+// Add bulk *EventListener commands on NodeLists from querySelectorAll and others  (set false to prevent funkiness).
+root.modifySelectors = false;
+
+root.configure = function(conf) {
+	if (isFinite(conf.modifyEventListener)) root.modifyEventListener = conf.modifyEventListener;
+	if (isFinite(conf.modifySelectors)) root.modifySelectors = conf.modifySelectors;
+	/// Augment event listeners
+	if (eventListenersAgumented === false && root.modifyEventListener) {
+		augmentEventListeners();
+	}
+	if (selectorsAugmented === false && root.modifySelectors) {
+		augmentSelectors();
+	}
+};
+
+// Event maintenance.
+root.add = function(target, type, listener, configure) {
+	return eventManager(target, type, listener, configure, "add");
+};
+
+root.remove = function(target, type, listener, configure) {
+	return eventManager(target, type, listener, configure, "remove");
+};
+
+root.returnFalse = function(event) {
+	return false;
+};
+
+root.stop = function(event) {
+	if (!event) return;
+	if (event.stopPropagation) event.stopPropagation();
+	event.cancelBubble = true; // <= IE8
+	event.cancelBubbleCount = 0;
+};
+
+root.prevent = function(event) {
+	if (!event) return;
+	if (event.preventDefault) {
+		event.preventDefault();
+	} else if (event.preventManipulation) {
+		event.preventManipulation(); // MS
+	} else {
+		event.returnValue = false; // <= IE8
+	}
+};
+
+root.cancel = function(event) {
+	root.stop(event);
+	root.prevent(event);
+};
+
+root.blur = function() { // Blurs the focused element. Useful when using eventjs.cancel as canceling will prevent focused elements from being blurred.
+	var node = document.activeElement;
+	if (!node) return;
+	var nodeName = document.activeElement.nodeName;
+	if (nodeName === "INPUT" || nodeName === "TEXTAREA" || node.contentEditable === "true") {
+		if (node.blur) node.blur();
+	}
+};
+
+// Check whether event is natively supported (via @kangax)
+root.getEventSupport = function (target, type) {
+	if (typeof(target) === "string") {
+		type = target;
+		target = window;
+	}
+	type = "on" + type;
+	if (type in target) return true;
+	if (!target.setAttribute) target = document.createElement("div");
+	if (target.setAttribute && target.removeAttribute) {
+		target.setAttribute(type, "");
+		var isSupported = typeof target[type] === "function";
+		if (typeof target[type] !== "undefined") target[type] = null;
+		target.removeAttribute(type);
+		return isSupported;
+	}
+};
+
+var clone = function (obj) {
+	if (!obj || typeof (obj) !== 'object') return obj;
+	var temp = new obj.constructor();
+	for (var key in obj) {
+		if (!obj[key] || typeof (obj[key]) !== 'object') {
+			temp[key] = obj[key];
+		} else { // clone sub-object
+			temp[key] = clone(obj[key]);
+		}
+	}
+	return temp;
+};
+
+/// Handle custom *EventListener commands.
+var eventManager = function(target, type, listener, configure, trigger, fromOverwrite) {
+	configure = configure || {};
+	// Check whether target is a configuration variable;
+	if (String(target) === "[object Object]") {
+		var data = target;
+		target = data.target; delete data.target;
+		///
+		if (data.type && data.listener) {
+			type = data.type; delete data.type;
+			listener = data.listener; delete data.listener;
+			for (var key in data) {
+				configure[key] = data[key];
+			}
+		} else { // specialness
+			for (var param in data) {
+				var value = data[param];
+				if (typeof(value) === "function") continue;
+				configure[param] = value;
+			}
+			///
+			var ret = {};
+			for (var key in data) {
+				var param = key.split(",");
+				var o = data[key];
+				var conf = {};
+				for (var k in configure) { // clone base configuration
+					conf[k] = configure[k];
+				}
+				///
+				if (typeof(o) === "function") { // without configuration
+					var listener = o;
+				} else if (typeof(o.listener) === "function") { // with configuration
+					var listener = o.listener;
+					for (var k in o) { // merge configure into base configuration
+						if (typeof(o[k]) === "function") continue;
+						conf[k] = o[k];
+					}
+				} else { // not a listener
+					continue;
+				}
+				///
+				for (var n = 0; n < param.length; n ++) {
+					ret[key] = eventjs.add(target, param[n], listener, conf, trigger);
+				}
+			}
+			return ret;
+		}
+	}
+	///
+	if (!target || !type || !listener) return;
+	// Check for element to load on interval (before onload).
+	if (typeof(target) === "string" && type === "ready") {
+		if (window.eventjs_stallOnReady) { /// force stall for scripts to load
+			type = "load";
+			target = window;
+		} else { //
+			var time = (new Date()).getTime();
+			var timeout = configure.timeout;
+			var ms = configure.interval || 1000 / 60;
+			var interval = window.setInterval(function() {
+				if ((new Date()).getTime() - time > timeout) {
+					window.clearInterval(interval);
+				}
+				if (document.querySelector(target)) {
+					window.clearInterval(interval);
+					setTimeout(listener, 1);
+				}
+			}, ms);
+			return;
+		}
+	}
+	// Get DOM element from Query Selector.
+	if (typeof(target) === "string") {
+		target = document.querySelectorAll(target);
+		if (target.length === 0) return createError("Missing target on listener!", arguments); // No results.
+		if (target.length === 1) { // Single target.
+			target = target[0];
+		}
+	}
+
+	/// Handle multiple targets.
+	var event;
+	var events = {};
+	if (target.length > 0 && target !== window) {
+		for (var n0 = 0, length0 = target.length; n0 < length0; n0 ++) {
+			event = eventManager(target[n0], type, listener, clone(configure), trigger);
+			if (event) events[n0] = event;
+		}
+		return createBatchCommands(events);
+	}
+
+	/// Check for multiple events in one string.
+	if (typeof(type) === "string") {
+		type = type.toLowerCase();
+		if (type.indexOf(" ") !== -1) {
+			type = type.split(" ");
+		} else if (type.indexOf(",") !== -1) {
+			type = type.split(",");
+		}
+	}
+
+	/// Attach or remove multiple events associated with a target.
+	if (typeof(type) !== "string") { // Has multiple events.
+		if (typeof(type.length) === "number") { // Handle multiple listeners glued together.
+			for (var n1 = 0, length1 = type.length; n1 < length1; n1 ++) { // Array [type]
+				event = eventManager(target, type[n1], listener, clone(configure), trigger);
+				if (event) events[type[n1]] = event;
+			}
+		} else { // Handle multiple listeners.
+			for (var key in type) { // Object {type}
+				if (typeof(type[key]) === "function") { // without configuration.
+					event = eventManager(target, key, type[key], clone(configure), trigger);
+				} else { // with configuration.
+					event = eventManager(target, key, type[key].listener, clone(type[key]), trigger);
+				}
+				if (event) events[key] = event;
+			}
+		}
+		return createBatchCommands(events);
+	} else if (type.indexOf("on") === 0) { // to support things like "onclick" instead of "click"
+		type = type.substr(2);
+	}
+
+	// Ensure listener is a function.
+	if (typeof(target) !== "object") return createError("Target is not defined!", arguments);
+	if (typeof(listener) !== "function") return createError("Listener is not a function!", arguments);
+
+	// Generate a unique wrapper identifier.
+	var useCapture = configure.useCapture || false;
+	var id = getID(target) + "." + getID(listener) + "." + (useCapture ? 1 : 0);
+	// Handle the event.
+	if (root.Gesture && root.Gesture._gestureHandlers[type]) { // Fire custom event.
+		id = type + id;
+		if (trigger === "remove") { // Remove event listener.
+			if (!wrappers[id]) return; // Already removed.
+			wrappers[id].remove();
+			delete wrappers[id];
+		} else if (trigger === "add") { // Attach event listener.
+			if (wrappers[id]) {
+				wrappers[id].add();
+				return wrappers[id]; // Already attached.
+			}
+			// Retains "this" orientation.
+			if (configure.useCall && !root.modifyEventListener) {
+				var tmp = listener;
+				listener = function(event, self) {
+					for (var key in self) event[key] = self[key];
+					return tmp.call(target, event);
+				};
+			}
+			// Create listener proxy.
+			configure.gesture = type;
+			configure.target = target;
+			configure.listener = listener;
+			configure.fromOverwrite = fromOverwrite;
+			// Record wrapper.
+			wrappers[id] = root.proxy[type](configure);
+		}
+		return wrappers[id];
+	} else { // Fire native event.
+		var eventList = getEventList(type);
+		for (var n = 0, eventId; n < eventList.length; n ++) {
+			type = eventList[n];
+			eventId = type + "." + id;
+			if (trigger === "remove") { // Remove event listener.
+				if (!wrappers[eventId]) continue; // Already removed.
+				target[remove](type, listener, useCapture);
+				delete wrappers[eventId];
+			} else if (trigger === "add") { // Attach event listener.
+				if (wrappers[eventId]) return wrappers[eventId]; // Already attached.
+				target[add](type, listener, useCapture);
+				// Record wrapper.
+				wrappers[eventId] = {
+					id: eventId,
+					type: type,
+					target: target,
+					listener: listener,
+					remove: function() {
+						for (var n = 0; n < eventList.length; n ++) {
+							root.remove(target, eventList[n], listener, configure);
+						}
+					}
+				};
+			}
+		}
+		return wrappers[eventId];
+	}
+};
+
+/// Perform batch actions on multiple events.
+var createBatchCommands = function(events) {
+	return {
+		remove: function() { // Remove multiple events.
+			for (var key in events) {
+				events[key].remove();
+			}
+		},
+		add: function() { // Add multiple events.
+			for (var key in events) {
+				events[key].add();
+			}
+		}
+	};
+};
+
+/// Display error message in console.
+var createError = function(message, data) {
+	if (typeof(console) === "undefined") return;
+	if (typeof(console.error) === "undefined") return;
+	console.error(message, data);
+};
+
+/// Handle naming discrepancies between platforms.
+var pointerDefs = {
+	"msPointer": [ "MSPointerDown", "MSPointerMove", "MSPointerUp" ],
+	"touch": [ "touchstart", "touchmove", "touchend" ],
+	"mouse": [ "mousedown", "mousemove", "mouseup" ]
+};
+
+var pointerDetect = {
+	// MSPointer
+	"MSPointerDown": 0,
+	"MSPointerMove": 1,
+	"MSPointerUp": 2,
+	// Touch
+	"touchstart": 0,
+	"touchmove": 1,
+	"touchend": 2,
+	// Mouse
+	"mousedown": 0,
+	"mousemove": 1,
+	"mouseup": 2
+};
+
+var getEventSupport = (function() {
+	root.supports = {};
+	if (window.navigator.msPointerEnabled) {
+		root.supports.msPointer = true;
+	}
+	if (root.getEventSupport("touchstart")) {
+		root.supports.touch = true;
+	}
+	if (root.getEventSupport("mousedown")) {
+		root.supports.mouse = true;
+	}
+})();
+
+var getEventList = (function() {
+	return function(type) {
+		var prefix = document.addEventListener ? "" : "on"; // IE
+		var idx = pointerDetect[type];
+		if (isFinite(idx)) {
+			var types = [];
+			for (var key in root.supports) {
+				types.push(prefix + pointerDefs[key][idx]);
+			}
+			return types;
+		} else {
+			return [ prefix + type ];
+		}
+	};
+})();
+
+/// Event wrappers to keep track of all events placed in the window.
+var wrappers = {};
+var counter = 0;
+var getID = function(object) {
+	if (object === window) return "#window";
+	if (object === document) return "#document";
+	if (!object.uniqueID) object.uniqueID = "e" + counter ++;
+	return object.uniqueID;
+};
+
+/// Detect platforms native *EventListener command.
+var add = document.addEventListener ? "addEventListener" : "attachEvent";
+var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";
+
+/*
+	Pointer.js
+	----------------------------------------
+	Modified from; https://github.com/borismus/pointer.js
+*/
+
+root.createPointerEvent = function (event, self, preventRecord) {
+	var eventName = self.gesture;
+	var target = self.target;
+	var pts = event.changedTouches || root.proxy.getCoords(event);
+	if (pts.length) {
+		var pt = pts[0];
+		self.pointers = preventRecord ? [] : pts;
+		self.pageX = pt.pageX;
+		self.pageY = pt.pageY;
+		self.x = self.pageX;
+		self.y = self.pageY;
+	}
+	///
+	var newEvent = document.createEvent("Event");
+	newEvent.initEvent(eventName, true, true);
+	newEvent.originalEvent = event;
+	for (var k in self) {
+		if (k === "target") continue;
+		newEvent[k] = self[k];
+	}
+	///
+	var type = newEvent.type;
+	if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
+//		target.dispatchEvent(newEvent);
+		self.oldListener.call(target, newEvent, self, false);
+	}
+};
+
+var eventListenersAgumented = false;
+var augmentEventListeners = function() {
+	/// Allows *EventListener to use custom event proxies.
+	if (!window.HTMLElement) return;
+	var augmentEventListener = function(proto) {
+		var recall = function(trigger) { // overwrite native *EventListener's
+			var handle = trigger + "EventListener";
+			var handler = proto[handle];
+			proto[handle] = function (type, listener, useCapture) {
+				if (root.Gesture && root.Gesture._gestureHandlers[type]) { // capture custom events.
+					var configure = useCapture;
+					if (typeof(useCapture) === "object") {
+						configure.useCall = true;
+					} else { // convert to configuration object.
+						configure = {
+							useCall: true,
+							useCapture: useCapture
+						};
+					}
+					eventManager(this, type, listener, configure, trigger, true);
+//					handler.call(this, type, listener, useCapture);
+				} else { // use native function.
+					var types = getEventList(type);
+					for (var n = 0; n < types.length; n ++) {
+						handler.call(this, types[n], listener, useCapture);
+					}
+				}
+			};
+		};
+		recall("add");
+		recall("remove");
+	};
+	// NOTE: overwriting HTMLElement doesn't do anything in Firefox.
+	if (navigator.userAgent.match(/Firefox/)) {
+		// TODO: fix Firefox for the general case.
+		augmentEventListener(HTMLDivElement.prototype);
+		augmentEventListener(HTMLCanvasElement.prototype);
+	} else {
+		augmentEventListener(HTMLElement.prototype);
+	}
+	augmentEventListener(document);
+	augmentEventListener(window);
+};
+
+var selectorsAugmented = false;
+var augmentSelectors = function() {
+/// Allows querySelectorAll and other NodeLists to perform *EventListener commands in bulk.
+	var proto = NodeList.prototype;
+	proto.removeEventListener = function(type, listener, useCapture) {
+		for (var n = 0, length = this.length; n < length; n ++) {
+			this[n].removeEventListener(type, listener, useCapture);
+		}
+	};
+	proto.addEventListener = function(type, listener, useCapture) {
+		for (var n = 0, length = this.length; n < length; n ++) {
+			this[n].addEventListener(type, listener, useCapture);
+		}
+	};
+};
+
+return root;
+
+})(eventjs);
+
+/*:
+	----------------------------------------------------
+	eventjs.proxy : 0.4.2 : 2013/07/17 : MIT License
+	----------------------------------------------------
+	https://github.com/mudcube/eventjs.js
+	----------------------------------------------------
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+/*
+	Create a new pointer gesture instance.
+*/
+
+root.pointerSetup = function(conf, self) {
+	/// Configure.
+	conf.target = conf.target || window;
+	conf.doc = conf.target.ownerDocument || conf.target; // Associated document.
+	conf.minFingers = conf.minFingers || conf.fingers || 1; // Minimum required fingers.
+	conf.maxFingers = conf.maxFingers || conf.fingers || Infinity; // Maximum allowed fingers.
+	conf.position = conf.position || "relative"; // Determines what coordinate system points are returned.
+	delete conf.fingers; //-
+	/// Convenience data.
+	self = self || {};
+	self.enabled = true;
+	self.gesture = conf.gesture;
+	self.target = conf.target;
+	self.env = conf.env;
+	///
+	if (eventjs.modifyEventListener && conf.fromOverwrite) {
+		conf.oldListener = conf.listener;
+		conf.listener = eventjs.createPointerEvent;
+	}
+	/// Convenience commands.
+	var fingers = 0;
+	var type = self.gesture.indexOf("pointer") === 0 && eventjs.modifyEventListener ? "pointer" : "mouse";
+	if (conf.oldListener) self.oldListener = conf.oldListener;
+	///
+	self.listener = conf.listener;
+	self.proxy = function(listener) {
+		self.defaultListener = conf.listener;
+		conf.listener = listener;
+		listener(conf.event, self);
+	};
+	self.add = function() {
+		if (self.enabled === true) return;
+		if (conf.onPointerDown) eventjs.add(conf.target, type + "down", conf.onPointerDown);
+		if (conf.onPointerMove) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
+		if (conf.onPointerUp) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
+		self.enabled = true;
+	};
+	self.remove = function() {
+		if (self.enabled === false) return;
+		if (conf.onPointerDown) eventjs.remove(conf.target, type + "down", conf.onPointerDown);
+		if (conf.onPointerMove) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
+		if (conf.onPointerUp) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
+		self.reset();
+		self.enabled = false;
+	};
+	self.pause = function(opt) {
+		if (conf.onPointerMove && (!opt || opt.move)) eventjs.remove(conf.doc, type + "move", conf.onPointerMove);
+		if (conf.onPointerUp && (!opt || opt.up)) eventjs.remove(conf.doc, type + "up", conf.onPointerUp);
+		fingers = conf.fingers;
+		conf.fingers = 0;
+	};
+	self.resume = function(opt) {
+		if (conf.onPointerMove && (!opt || opt.move)) eventjs.add(conf.doc, type + "move", conf.onPointerMove);
+		if (conf.onPointerUp && (!opt || opt.up)) eventjs.add(conf.doc, type + "up", conf.onPointerUp);
+		conf.fingers = fingers;
+	};
+	self.reset = function() {
+		conf.tracker = {};
+		conf.fingers = 0;
+	};
+	///
+	return self;
+};
+
+/*
+	Begin proxied pointer command.
+*/
+
+var sp = eventjs.supports; // Default pointerType
+///
+eventjs.isMouse = !!sp.mouse;
+eventjs.isMSPointer = !!sp.touch;
+eventjs.isTouch = !!sp.msPointer;
+///
+root.pointerStart = function(event, self, conf) {
+	/// tracks multiple inputs
+	var type = (event.type || "mousedown").toUpperCase();
+	if (type.indexOf("MOUSE") === 0) {
+		eventjs.isMouse = true;
+		eventjs.isTouch = false;
+		eventjs.isMSPointer = false;
+	} else if (type.indexOf("TOUCH") === 0) {
+		eventjs.isMouse = false;
+		eventjs.isTouch = true;
+		eventjs.isMSPointer = false;
+	} else if (type.indexOf("MSPOINTER") === 0) {
+		eventjs.isMouse = false;
+		eventjs.isTouch = false;
+		eventjs.isMSPointer = true;
+	}
+	///
+	var addTouchStart = function(touch, sid) {
+		var bbox = conf.bbox;
+		var pt = track[sid] = {};
+		///
+		switch(conf.position) {
+			case "absolute": // Absolute from within window.
+				pt.offsetX = 0;
+				pt.offsetY = 0;
+				break;
+			case "differenceFromLast": // Since last coordinate recorded.
+				pt.offsetX = touch.pageX;
+				pt.offsetY = touch.pageY;
+				break;
+			case "difference": // Relative from origin.
+				pt.offsetX = touch.pageX;
+				pt.offsetY = touch.pageY;
+				break;
+			case "move": // Move target element.
+				pt.offsetX = touch.pageX - bbox.x1;
+				pt.offsetY = touch.pageY - bbox.y1;
+				break;
+			default: // Relative from within target.
+				pt.offsetX = bbox.x1 - bbox.scrollLeft;
+				pt.offsetY = bbox.y1 - bbox.scrollTop;
+				break;
+		}
+		///
+		var x = touch.pageX - pt.offsetX;
+		var y = touch.pageY - pt.offsetY;
+		///
+		pt.rotation = 0;
+		pt.scale = 1;
+		pt.startTime = pt.moveTime = (new Date()).getTime();
+		pt.move = { x: x, y: y };
+		pt.start = { x: x, y: y };
+		///
+		conf.fingers ++;
+	};
+	///
+	conf.event = event;
+	if (self.defaultListener) {
+		conf.listener = self.defaultListener;
+		delete self.defaultListener;
+	}
+	///
+	var isTouchStart = !conf.fingers;
+	var track = conf.tracker;
+	var touches = event.changedTouches || root.getCoords(event);
+	var length = touches.length;
+	// Adding touch events to tracking.
+	for (var i = 0; i < length; i ++) {
+		var touch = touches[i];
+		var sid = touch.identifier || Infinity; // Touch ID.
+		// Track the current state of the touches.
+		if (conf.fingers) {
+			if (conf.fingers >= conf.maxFingers) {
+				var ids = [];
+				for (var sid in conf.tracker) ids.push(sid);
+				self.identifier = ids.join(",");
+				return isTouchStart;
+			}
+			var fingers = 0; // Finger ID.
+			for (var rid in track) {
+				// Replace removed finger.
+				if (track[rid].up) {
+					delete track[rid];
+					addTouchStart(touch, sid);
+					conf.cancel = true;
+					break;
+				}
+				fingers ++;
+			}
+			// Add additional finger.
+			if (track[sid]) continue;
+			addTouchStart(touch, sid);
+		} else { // Start tracking fingers.
+			track = conf.tracker = {};
+			self.bbox = conf.bbox = root.getBoundingBox(conf.target);
+			conf.fingers = 0;
+			conf.cancel = false;
+			addTouchStart(touch, sid);
+		}
+	}
+	///
+	var ids = [];
+	for (var sid in conf.tracker) ids.push(sid);
+	self.identifier = ids.join(",");
+	///
+	return isTouchStart;
+};
+
+/*
+	End proxied pointer command.
+*/
+
+root.pointerEnd = function(event, self, conf, onPointerUp) {
+	// Record changed touches have ended (iOS changedTouches is not reliable).
+	var touches = event.touches || [];
+	var length = touches.length;
+	var exists = {};
+	for (var i = 0; i < length; i ++) {
+		var touch = touches[i];
+		var sid = touch.identifier;
+		exists[sid || Infinity] = true;
+	}
+	for (var sid in conf.tracker) {
+		var track = conf.tracker[sid];
+		if (exists[sid] || track.up) continue;
+		if (onPointerUp) { // add changedTouches to mouse.
+			onPointerUp({
+				pageX: track.pageX,
+				pageY: track.pageY,
+				changedTouches: [{
+					pageX: track.pageX,
+					pageY: track.pageY,
+					identifier: sid === "Infinity" ? Infinity : sid
+				}]
+			}, "up");
+		}
+		track.up = true;
+		conf.fingers --;
+	}
+/*	// This should work but fails in Safari on iOS4 so not using it.
+	var touches = event.changedTouches || root.getCoords(event);
+	var length = touches.length;
+	// Record changed touches have ended (this should work).
+	for (var i = 0; i < length; i ++) {
+		var touch = touches[i];
+		var sid = touch.identifier || Infinity;
+		var track = conf.tracker[sid];
+		if (track && !track.up) {
+			if (onPointerUp) { // add changedTouches to mouse.
+				onPointerUp({
+					changedTouches: [{
+						pageX: track.pageX,
+						pageY: track.pageY,
+						identifier: sid === "Infinity" ? Infinity : sid
+					}]
+				}, "up");
+			}
+			track.up = true;
+			conf.fingers --;
+		}
+	} */
+	// Wait for all fingers to be released.
+	if (conf.fingers !== 0) return false;
+	// Record total number of fingers gesture used.
+	var ids = [];
+	conf.gestureFingers = 0;
+	for (var sid in conf.tracker) {
+		conf.gestureFingers ++;
+		ids.push(sid);
+	}
+	self.identifier = ids.join(",");
+	// Our pointer gesture has ended.
+	return true;
+};
+
+/*
+	Returns mouse coords in an array to match event.*Touches
+	------------------------------------------------------------
+	var touch = event.changedTouches || root.getCoords(event);
+*/
+
+root.getCoords = function(event) {
+	if (typeof(event.pageX) !== "undefined") { // Desktop browsers.
+		root.getCoords = function(event) {
+			return Array({
+				type: "mouse",
+				x: event.pageX,
+				y: event.pageY,
+				pageX: event.pageX,
+				pageY: event.pageY,
+				identifier: event.pointerId || Infinity // pointerId is MS
+			});
+		};
+	} else { // Internet Explorer <= 8.0
+		root.getCoords = function(event) {
+			var doc = document.documentElement;
+			event = event || window.event;
+			return Array({
+				type: "mouse",
+				x: event.clientX + doc.scrollLeft,
+				y: event.clientY + doc.scrollTop,
+				pageX: event.clientX + doc.scrollLeft,
+				pageY: event.clientY + doc.scrollTop,
+				identifier: Infinity
+			});
+		};
+	}
+	return root.getCoords(event);
+};
+
+/*
+	Returns single coords in an object.
+	------------------------------------------------------------
+	var mouse = root.getCoord(event);
+*/
+
+root.getCoord = function(event) {
+	if ("ontouchstart" in window) { // Mobile browsers.
+		var pX = 0;
+		var pY = 0;
+		root.getCoord = function(event) {
+			var touches = event.changedTouches;
+			if (touches && touches.length) { // ontouchstart + ontouchmove
+				return {
+					x: pX = touches[0].pageX,
+					y: pY = touches[0].pageY
+				};
+			} else { // ontouchend
+				return {
+					x: pX,
+					y: pY
+				};
+			}
+		};
+	} else if(typeof(event.pageX) !== "undefined" && typeof(event.pageY) !== "undefined") { // Desktop browsers.
+		root.getCoord = function(event) {
+			return {
+				x: event.pageX,
+				y: event.pageY
+			};
+		};
+	} else { // Internet Explorer <=8.0
+		root.getCoord = function(event) {
+			var doc = document.documentElement;
+			event = event || window.event;
+			return {
+				x: event.clientX + doc.scrollLeft,
+				y: event.clientY + doc.scrollTop
+			};
+		};
+	}
+	return root.getCoord(event);
+};
+
+/*
+	Get target scale and position in space.
+*/
+
+var getPropertyAsFloat = function(o, type) {
+	var n = parseFloat(o.getPropertyValue(type), 10);
+	return isFinite(n) ? n : 0;
+};
+
+root.getBoundingBox = function(o) {
+	if (o === window || o === document) o = document.body;
+	///
+	var bbox = {};
+	var bcr = o.getBoundingClientRect();
+	bbox.width = bcr.width;
+	bbox.height = bcr.height;
+	bbox.x1 = bcr.left;
+	bbox.y1 = bcr.top;
+	bbox.scaleX = bcr.width / o.offsetWidth || 1;
+	bbox.scaleY = bcr.height / o.offsetHeight || 1;
+	bbox.scrollLeft = 0;
+	bbox.scrollTop = 0;
+	///
+	var style = window.getComputedStyle(o);
+	var borderBox = style.getPropertyValue("box-sizing") === "border-box";
+	///
+	if (borderBox === false) {
+		var left = getPropertyAsFloat(style, "border-left-width");
+		var right = getPropertyAsFloat(style, "border-right-width");
+		var bottom = getPropertyAsFloat(style, "border-bottom-width");
+		var top = getPropertyAsFloat(style, "border-top-width");
+		bbox.border = [ left, right, top, bottom ];
+		bbox.x1 += left;
+		bbox.y1 += top;
+		bbox.width -= right + left;
+		bbox.height -= bottom + top;
+	}
+
+/*	var left = getPropertyAsFloat(style, "padding-left");
+	var right = getPropertyAsFloat(style, "padding-right");
+	var bottom = getPropertyAsFloat(style, "padding-bottom");
+	var top = getPropertyAsFloat(style, "padding-top");
+	bbox.padding = [ left, right, top, bottom ];*/
+	///
+	bbox.x2 = bbox.x1 + bbox.width;
+	bbox.y2 = bbox.y1 + bbox.height;
+
+	/// Get the scroll of container element.
+	var position = style.getPropertyValue("position");
+	var tmp = position === "fixed" ? o : o.parentNode;
+	while (tmp !== null) {
+		if (tmp === document.body) break;
+		if (tmp.scrollTop === undefined) break;
+		var style = window.getComputedStyle(tmp);
+		var position = style.getPropertyValue("position");
+		if (position === "absolute") {
+
+		} else if (position === "fixed") {
+//			bbox.scrollTop += document.body.scrollTop;
+//			bbox.scrollLeft += document.body.scrollLeft;
+			bbox.scrollTop -= tmp.parentNode.scrollTop;
+			bbox.scrollLeft -= tmp.parentNode.scrollLeft;
+			break;
+		} else {
+			bbox.scrollLeft += tmp.scrollLeft;
+			bbox.scrollTop += tmp.scrollTop;
+		}
+		///
+		tmp = tmp.parentNode;
+	};
+	///
+	bbox.scrollBodyLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
+	bbox.scrollBodyTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
+	///
+	bbox.scrollLeft -= bbox.scrollBodyLeft;
+	bbox.scrollTop -= bbox.scrollBodyTop;
+	///
+	return bbox;
+};
+
+/*
+	Keep track of metaKey, the proper ctrlKey for users platform.
+	----------------------------------------------------
+	http://www.quirksmode.org/js/keys.html
+	-----------------------------------
+	http://unixpapa.com/js/key.html
+*/
+
+(function() {
+	var agent = navigator.userAgent.toLowerCase();
+	var mac = agent.indexOf("macintosh") !== -1;
+	var metaKeys;
+	if (mac && agent.indexOf("khtml") !== -1) { // chrome, safari.
+		metaKeys = { 91: true, 93: true };
+	} else if (mac && agent.indexOf("firefox") !== -1) {  // mac firefox.
+		metaKeys = { 224: true };
+	} else { // windows, linux, or mac opera.
+		metaKeys = { 17: true };
+	}
+	(root.metaTrackerReset = function() {
+		eventjs.fnKey = root.fnKey = false;
+		eventjs.metaKey = root.metaKey = false;
+		eventjs.escKey = root.escKey = false;
+		eventjs.ctrlKey = root.ctrlKey = false;
+		eventjs.shiftKey = root.shiftKey = false;
+		eventjs.altKey = root.altKey = false;
+	})();
+	root.metaTracker = function(event) {
+		var isKeyDown = event.type === "keydown";
+		if (event.keyCode === 27) eventjs.escKey = root.escKey = isKeyDown;
+		if (metaKeys[event.keyCode]) eventjs.metaKey = root.metaKey = isKeyDown;
+		eventjs.ctrlKey = root.ctrlKey = event.ctrlKey;
+		eventjs.shiftKey = root.shiftKey = event.shiftKey;
+		eventjs.altKey = root.altKey = event.altKey;
+	};
+})();
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	----------------------------------------------------
+	"MutationObserver" event proxy.
+	----------------------------------------------------
+	author: Selvakumar Arumugam - MIT LICENSE
+	   src: http://stackoverflow.com/questions/10868104/can-you-have-a-javascript-hook-trigger-after-a-dom-elements-style-object-change
+	----------------------------------------------------
+*/
+if (typeof(eventjs) === "undefined") var eventjs = {};
+
+eventjs.MutationObserver = (function() {
+	var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
+	var DOMAttrModifiedSupported = !MutationObserver && (function() {
+		var p = document.createElement("p");
+		var flag = false;
+		var fn = function() { flag = true };
+		if (p.addEventListener) {
+			p.addEventListener("DOMAttrModified", fn, false);
+		} else if (p.attachEvent) {
+			p.attachEvent("onDOMAttrModified", fn);
+		} else {
+			return false;
+		}
+		///
+		p.setAttribute("id", "target");
+		///
+		return flag;
+	})();
+	///
+	return function(container, callback) {
+		if (MutationObserver) {
+			var options = {
+				subtree: false,
+				attributes: true
+			};
+			var observer = new MutationObserver(function(mutations) {
+				mutations.forEach(function(e) {
+					callback.call(e.target, e.attributeName);
+				});
+			});
+			observer.observe(container, options)
+		} else if (DOMAttrModifiedSupported) {
+			eventjs.add(container, "DOMAttrModified", function(e) {
+				callback.call(container, e.attrName);
+			});
+		} else if ("onpropertychange" in document.body) {
+			eventjs.add(container, "propertychange", function(e) {
+				callback.call(container, window.event.propertyName);
+			});
+		}
+	}
+})();
+/*:
+	"Click" event proxy.
+	----------------------------------------------------
+	eventjs.add(window, "click", function(event, self) {});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.click = function(conf) {
+	conf.gesture = conf.gesture || "click";
+	conf.maxFingers = conf.maxFingers || conf.fingers || 1;
+	/// Tracking the events.
+	conf.onPointerDown = function (event) {
+		if (root.pointerStart(event, self, conf)) {
+			eventjs.add(conf.target, "mouseup", conf.onPointerUp);
+		}
+	};
+	conf.onPointerUp = function(event) {
+		if (root.pointerEnd(event, self, conf)) {
+			eventjs.remove(conf.target, "mouseup", conf.onPointerUp);
+			var pointers = event.changedTouches || root.getCoords(event);
+			var pointer = pointers[0];
+			var bbox = conf.bbox;
+			var newbbox = root.getBoundingBox(conf.target);
+			var y = pointer.pageY - newbbox.scrollBodyTop;
+			var x = pointer.pageX - newbbox.scrollBodyLeft;
+			////
+			if (x > bbox.x1 && y > bbox.y1 &&
+				x < bbox.x2 && y < bbox.y2 &&
+				bbox.scrollTop === newbbox.scrollTop) { // has not been scrolled
+				///
+				for (var key in conf.tracker) break; //- should be modularized? in dblclick too
+				var point = conf.tracker[key];
+				self.x = point.start.x;
+				self.y = point.start.y;
+				///
+				conf.listener(event, self);
+			}
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	self.state = "click";
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.click = root.click;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Double-Click" aka "Double-Tap" event proxy.
+	----------------------------------------------------
+	eventjs.add(window, "dblclick", function(event, self) {});
+	----------------------------------------------------
+	Touch an target twice for <= 700ms, with less than 25 pixel drift.
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.dbltap =
+root.dblclick = function(conf) {
+	conf.gesture = conf.gesture || "dbltap";
+	conf.maxFingers = conf.maxFingers || conf.fingers || 1;
+	// Setting up local variables.
+	var delay = 700; // in milliseconds
+	var time0, time1, timeout;
+	var pointer0, pointer1;
+	// Tracking the events.
+	conf.onPointerDown = function (event) {
+		var pointers = event.changedTouches || root.getCoords(event);
+		if (time0 && !time1) { // Click #2
+			pointer1 = pointers[0];
+			time1 = (new Date()).getTime() - time0;
+		} else { // Click #1
+			pointer0 = pointers[0];
+			time0 = (new Date()).getTime();
+			time1 = 0;
+			clearTimeout(timeout);
+			timeout = setTimeout(function() {
+				time0 = 0;
+			}, delay);
+		}
+		if (root.pointerStart(event, self, conf)) {
+			eventjs.add(conf.target, "mousemove", conf.onPointerMove).listener(event);
+			eventjs.add(conf.target, "mouseup", conf.onPointerUp);
+		}
+	};
+	conf.onPointerMove = function (event) {
+		if (time0 && !time1) {
+			var pointers = event.changedTouches || root.getCoords(event);
+			pointer1 = pointers[0];
+		}
+		var bbox = conf.bbox;
+		var ax = (pointer1.pageX - bbox.x1);
+		var ay = (pointer1.pageY - bbox.y1);
+		if (!(ax > 0 && ax < bbox.width && // Within target coordinates..
+			  ay > 0 && ay < bbox.height &&
+			  Math.abs(pointer1.pageX - pointer0.pageX) <= 25 && // Within drift deviance.
+			  Math.abs(pointer1.pageY - pointer0.pageY) <= 25)) {
+			// Cancel out this listener.
+			eventjs.remove(conf.target, "mousemove", conf.onPointerMove);
+			clearTimeout(timeout);
+			time0 = time1 = 0;
+		}
+	};
+	conf.onPointerUp = function(event) {
+		if (root.pointerEnd(event, self, conf)) {
+			eventjs.remove(conf.target, "mousemove", conf.onPointerMove);
+			eventjs.remove(conf.target, "mouseup", conf.onPointerUp);
+		}
+		if (time0 && time1) {
+			if (time1 <= delay) { // && !(event.cancelBubble && ++event.cancelBubbleCount > 1)) {
+				self.state = conf.gesture;
+				for (var key in conf.tracker) break;
+				var point = conf.tracker[key];
+				self.x = point.start.x;
+				self.y = point.start.y;
+				conf.listener(event, self);
+			}
+			clearTimeout(timeout);
+			time0 = time1 = 0;
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	self.state = "dblclick";
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.dbltap = root.dbltap;
+eventjs.Gesture._gestureHandlers.dblclick = root.dblclick;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Drag" event proxy (1+ fingers).
+	----------------------------------------------------
+	CONFIGURE: maxFingers, position.
+	----------------------------------------------------
+	eventjs.add(window, "drag", function(event, self) {
+		console.log(self.gesture, self.state, self.start, self.x, self.y, self.bbox);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.dragElement = function(that, event) {
+	root.drag({
+		event: event,
+		target: that,
+		position: "move",
+		listener: function(event, self) {
+			that.style.left = self.x + "px";
+			that.style.top = self.y + "px";
+			eventjs.prevent(event);
+		}
+	});
+};
+
+root.drag = function(conf) {
+	conf.gesture = "drag";
+	conf.onPointerDown = function (event) {
+		if (root.pointerStart(event, self, conf)) {
+			if (!conf.monitor) {
+				eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
+				eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+			}
+		}
+		// Process event listener.
+		conf.onPointerMove(event, "down");
+	};
+	conf.onPointerMove = function (event, state) {
+		if (!conf.tracker) return conf.onPointerDown(event);
+		var bbox = conf.bbox;
+		var touches = event.changedTouches || root.getCoords(event);
+		var length = touches.length;
+		for (var i = 0; i < length; i ++) {
+			var touch = touches[i];
+			var identifier = touch.identifier || Infinity;
+			var pt = conf.tracker[identifier];
+			// Identifier defined outside of listener.
+			if (!pt) continue;
+			pt.pageX = touch.pageX;
+			pt.pageY = touch.pageY;
+			// Record data.
+			self.state = state || "move";
+			self.identifier = identifier;
+			self.start = pt.start;
+			self.fingers = conf.fingers;
+			if (conf.position === "differenceFromLast") {
+				self.x = (pt.pageX - pt.offsetX);
+				self.y = (pt.pageY - pt.offsetY);
+				pt.offsetX = pt.pageX;
+				pt.offsetY = pt.pageY;
+			} else {
+				self.x = (pt.pageX - pt.offsetX);
+				self.y = (pt.pageY - pt.offsetY);
+			}
+			///
+			conf.listener(event, self);
+		}
+	};
+	conf.onPointerUp = function(event) {
+		// Remove tracking for touch.
+		if (root.pointerEnd(event, self, conf, conf.onPointerMove)) {
+			if (!conf.monitor) {
+				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
+				eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
+			}
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	// Attach events.
+	if (conf.event) {
+		conf.onPointerDown(conf.event);
+	} else { //
+		eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+		if (conf.monitor) {
+			eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
+			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+		}
+	}
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.drag = root.drag;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Gesture" event proxy (2+ fingers).
+	----------------------------------------------------
+	CONFIGURE: minFingers, maxFingers.
+	----------------------------------------------------
+	eventjs.add(window, "gesture", function(event, self) {
+		console.log(
+			self.x, // centroid
+			self.y,
+			self.rotation,
+			self.scale,
+			self.fingers,
+			self.state
+		);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+var RAD_DEG = Math.PI / 180;
+var getCentroid = function(self, points) {
+	var centroidx = 0;
+	var centroidy = 0;
+	var length = 0;
+	for (var sid in points) {
+		var touch = points[sid];
+		if (touch.up) continue;
+		centroidx += touch.move.x;
+		centroidy += touch.move.y;
+		length ++;
+	}
+	self.x = centroidx /= length;
+	self.y = centroidy /= length;
+	return self;
+};
+
+root.gesture = function(conf) {
+	conf.gesture = conf.gesture || "gesture";
+	conf.minFingers = conf.minFingers || conf.fingers || 2;
+	// Tracking the events.
+	conf.onPointerDown = function (event) {
+		var fingers = conf.fingers;
+		if (root.pointerStart(event, self, conf)) {
+			eventjs.add(conf.doc, "mousemove", conf.onPointerMove);
+			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+		}
+		// Record gesture start.
+		if (conf.fingers === conf.minFingers && fingers !== conf.fingers) {
+			self.fingers = conf.minFingers;
+			self.scale = 1;
+			self.rotation = 0;
+			self.state = "start";
+			var sids = ""; //- FIXME(mud): can generate duplicate IDs.
+			for (var key in conf.tracker) sids += key;
+			self.identifier = parseInt(sids);
+			getCentroid(self, conf.tracker);
+			conf.listener(event, self);
+		}
+	};
+	///
+	conf.onPointerMove = function (event, state) {
+		var bbox = conf.bbox;
+		var points = conf.tracker;
+		var touches = event.changedTouches || root.getCoords(event);
+		var length = touches.length;
+		// Update tracker coordinates.
+		for (var i = 0; i < length; i ++) {
+			var touch = touches[i];
+			var sid = touch.identifier || Infinity;
+			var pt = points[sid];
+			// Check whether "pt" is used by another gesture.
+			if (!pt) continue;
+			// Find the actual coordinates.
+			pt.move.x = (touch.pageX - bbox.x1);
+			pt.move.y = (touch.pageY - bbox.y1);
+		}
+		///
+		if (conf.fingers < conf.minFingers) return;
+		///
+		var touches = [];
+		var scale = 0;
+		var rotation = 0;
+
+		/// Calculate centroid of gesture.
+		getCentroid(self, points);
+		///
+		for (var sid in points) {
+			var touch = points[sid];
+			if (touch.up) continue;
+			var start = touch.start;
+			if (!start.distance) {
+				var dx = start.x - self.x;
+				var dy = start.y - self.y;
+				start.distance = Math.sqrt(dx * dx + dy * dy);
+				start.angle = Math.atan2(dx, dy) / RAD_DEG;
+			}
+			// Calculate scale.
+			var dx = touch.move.x - self.x;
+			var dy = touch.move.y - self.y;
+			var distance = Math.sqrt(dx * dx + dy * dy);
+			scale += distance / start.distance;
+			// Calculate rotation.
+			var angle = Math.atan2(dx, dy) / RAD_DEG;
+			var rotate = (start.angle - angle + 360) % 360 - 180;
+			touch.DEG2 = touch.DEG1; // Previous degree.
+			touch.DEG1 = rotate > 0 ? rotate : -rotate; // Current degree.
+			if (typeof(touch.DEG2) !== "undefined") {
+				if (rotate > 0) {
+					touch.rotation += touch.DEG1 - touch.DEG2;
+				} else {
+					touch.rotation -= touch.DEG1 - touch.DEG2;
+				}
+				rotation += touch.rotation;
+			}
+			// Attach current points to self.
+			touches.push(touch.move);
+		}
+		///
+		self.touches = touches;
+		self.fingers = conf.fingers;
+		self.scale = scale / conf.fingers;
+		self.rotation = rotation / conf.fingers;
+		self.state = "change";
+		conf.listener(event, self);
+	};
+	conf.onPointerUp = function(event) {
+		// Remove tracking for touch.
+		var fingers = conf.fingers;
+		if (root.pointerEnd(event, self, conf)) {
+			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
+			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
+		}
+		// Check whether fingers has dropped below minFingers.
+		if (fingers === conf.minFingers && conf.fingers < conf.minFingers) {
+			self.fingers = conf.fingers;
+			self.state = "end";
+			conf.listener(event, self);
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.gesture = root.gesture;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Pointer" event proxy (1+ fingers).
+	----------------------------------------------------
+	CONFIGURE: minFingers, maxFingers.
+	----------------------------------------------------
+	eventjs.add(window, "gesture", function(event, self) {
+		console.log(self.rotation, self.scale, self.fingers, self.state);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.pointerdown =
+root.pointermove =
+root.pointerup = function(conf) {
+	conf.gesture = conf.gesture || "pointer";
+	if (conf.target.isPointerEmitter) return;
+	// Tracking the events.
+	var isDown = true;
+	conf.onPointerDown = function (event) {
+		isDown = false;
+		self.gesture = "pointerdown";
+		conf.listener(event, self);
+	};
+	conf.onPointerMove = function (event) {
+		self.gesture = "pointermove";
+		conf.listener(event, self, isDown);
+	};
+	conf.onPointerUp = function (event) {
+		isDown = true;
+		self.gesture = "pointerup";
+		conf.listener(event, self, true);
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	eventjs.add(conf.target, "mousemove", conf.onPointerMove);
+	eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+	// Return this object.
+	conf.target.isPointerEmitter = true;
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.pointerdown = root.pointerdown;
+eventjs.Gesture._gestureHandlers.pointermove = root.pointermove;
+eventjs.Gesture._gestureHandlers.pointerup = root.pointerup;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Device Motion" and "Shake" event proxy.
+	----------------------------------------------------
+	http://developer.android.com/reference/android/hardware/Sensoreventjs.html#values
+	----------------------------------------------------
+	eventjs.add(window, "shake", function(event, self) {});
+	eventjs.add(window, "devicemotion", function(event, self) {
+		console.log(self.acceleration, self.accelerationIncludingGravity);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.shake = function(conf) {
+	// Externally accessible data.
+	var self = {
+		gesture: "devicemotion",
+		acceleration: {},
+		accelerationIncludingGravity: {},
+		target: conf.target,
+		listener: conf.listener,
+		remove: function() {
+			window.removeEventListener('devicemotion', onDeviceMotion, false);
+		}
+	};
+	// Setting up local variables.
+	var threshold = 4; // Gravitational threshold.
+	var timeout = 1000; // Timeout between shake events.
+	var timeframe = 200; // Time between shakes.
+	var shakes = 3; // Minimum shakes to trigger event.
+	var lastShake = (new Date()).getTime();
+	var gravity = { x: 0, y: 0, z: 0 };
+	var delta = {
+		x: { count: 0, value: 0 },
+		y: { count: 0, value: 0 },
+		z: { count: 0, value: 0 }
+	};
+	// Tracking the events.
+	var onDeviceMotion = function(e) {
+		var alpha = 0.8; // Low pass filter.
+		var o = e.accelerationIncludingGravity;
+		gravity.x = alpha * gravity.x + (1 - alpha) * o.x;
+		gravity.y = alpha * gravity.y + (1 - alpha) * o.y;
+		gravity.z = alpha * gravity.z + (1 - alpha) * o.z;
+		self.accelerationIncludingGravity = gravity;
+		self.acceleration.x = o.x - gravity.x;
+		self.acceleration.y = o.y - gravity.y;
+		self.acceleration.z = o.z - gravity.z;
+		///
+		if (conf.gesture === "devicemotion") {
+			conf.listener(e, self);
+			return;
+		}
+		var data = "xyz";
+		var now = (new Date()).getTime();
+		for (var n = 0, length = data.length; n < length; n ++) {
+			var letter = data[n];
+			var ACCELERATION = self.acceleration[letter];
+			var DELTA = delta[letter];
+			var abs = Math.abs(ACCELERATION);
+			/// Check whether another shake event was recently registered.
+			if (now - lastShake < timeout) continue;
+			/// Check whether delta surpasses threshold.
+			if (abs > threshold) {
+				var idx = now * ACCELERATION / abs;
+				var span = Math.abs(idx + DELTA.value);
+				// Check whether last delta was registered within timeframe.
+				if (DELTA.value && span < timeframe) {
+					DELTA.value = idx;
+					DELTA.count ++;
+					// Check whether delta count has enough shakes.
+					if (DELTA.count === shakes) {
+						conf.listener(e, self);
+						// Reset tracking.
+						lastShake = now;
+						DELTA.value = 0;
+						DELTA.count = 0;
+					}
+				} else {
+					// Track first shake.
+					DELTA.value = idx;
+					DELTA.count = 1;
+				}
+			}
+		}
+	};
+	// Attach events.
+	if (!window.addEventListener) return;
+	window.addEventListener('devicemotion', onDeviceMotion, false);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.shake = root.shake;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Swipe" event proxy (1+ fingers).
+	----------------------------------------------------
+	CONFIGURE: snap, threshold, maxFingers.
+	----------------------------------------------------
+	eventjs.add(window, "swipe", function(event, self) {
+		console.log(self.velocity, self.angle);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+var RAD_DEG = Math.PI / 180;
+
+root.swipe = function(conf) {
+	conf.snap = conf.snap || 90; // angle snap.
+	conf.threshold = conf.threshold || 1; // velocity threshold.
+	conf.gesture = conf.gesture || "swipe";
+	// Tracking the events.
+	conf.onPointerDown = function (event) {
+		if (root.pointerStart(event, self, conf)) {
+			eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
+			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+		}
+	};
+	conf.onPointerMove = function (event) {
+		var touches = event.changedTouches || root.getCoords(event);
+		var length = touches.length;
+		for (var i = 0; i < length; i ++) {
+			var touch = touches[i];
+			var sid = touch.identifier || Infinity;
+			var o = conf.tracker[sid];
+			// Identifier defined outside of listener.
+			if (!o) continue;
+			o.move.x = touch.pageX;
+			o.move.y = touch.pageY;
+			o.moveTime = (new Date()).getTime();
+		}
+	};
+	conf.onPointerUp = function(event) {
+		if (root.pointerEnd(event, self, conf)) {
+			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
+			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
+			///
+			var velocity1;
+			var velocity2
+			var degree1;
+			var degree2;
+			/// Calculate centroid of gesture.
+			var start = { x: 0, y: 0 };
+			var endx = 0;
+			var endy = 0;
+			var length = 0;
+			///
+			for (var sid in conf.tracker) {
+				var touch = conf.tracker[sid];
+				var xdist = touch.move.x - touch.start.x;
+				var ydist = touch.move.y - touch.start.y;
+				///
+				endx += touch.move.x;
+				endy += touch.move.y;
+				start.x += touch.start.x;
+				start.y += touch.start.y;
+				length ++;
+				///
+				var distance = Math.sqrt(xdist * xdist + ydist * ydist);
+				var ms = touch.moveTime - touch.startTime;
+				var degree2 = Math.atan2(xdist, ydist) / RAD_DEG + 180;
+				var velocity2 = ms ? distance / ms : 0;
+				if (typeof(degree1) === "undefined") {
+					degree1 = degree2;
+					velocity1 = velocity2;
+				} else if (Math.abs(degree2 - degree1) <= 20) {
+					degree1 = (degree1 + degree2) / 2;
+					velocity1 = (velocity1 + velocity2) / 2;
+				} else {
+					return;
+				}
+			}
+			///
+			var fingers = conf.gestureFingers;
+			if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
+				if (velocity1 > conf.threshold) {
+					start.x /= length;
+					start.y /= length;
+					self.start = start;
+					self.x = endx / length;
+					self.y = endy / length;
+					self.angle = -((((degree1 / conf.snap + 0.5) >> 0) * conf.snap || 360) - 360);
+					self.velocity = velocity1;
+					self.fingers = fingers;
+					self.state = "swipe";
+					conf.listener(event, self);
+				}
+			}
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.swipe = root.swipe;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Tap" and "Longpress" event proxy.
+	----------------------------------------------------
+	CONFIGURE: delay (longpress), timeout (tap).
+	----------------------------------------------------
+	eventjs.add(window, "tap", function(event, self) {
+		console.log(self.fingers);
+	});
+	----------------------------------------------------
+	multi-finger tap // touch an target for <= 250ms.
+	multi-finger longpress // touch an target for >= 500ms
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.longpress = function(conf) {
+	conf.gesture = "longpress";
+	return root.tap(conf);
+};
+
+root.tap = function(conf) {
+	conf.delay = conf.delay || 500;
+	conf.timeout = conf.timeout || 250;
+	conf.driftDeviance = conf.driftDeviance || 10;
+	conf.gesture = conf.gesture || "tap";
+	// Setting up local variables.
+	var timestamp, timeout;
+	// Tracking the events.
+	conf.onPointerDown = function (event) {
+		if (root.pointerStart(event, self, conf)) {
+			timestamp = (new Date()).getTime();
+			// Initialize event listeners.
+			eventjs.add(conf.doc, "mousemove", conf.onPointerMove).listener(event);
+			eventjs.add(conf.doc, "mouseup", conf.onPointerUp);
+			// Make sure this is a "longpress" event.
+			if (conf.gesture !== "longpress") return;
+			timeout = setTimeout(function() {
+				if (event.cancelBubble && ++event.cancelBubbleCount > 1) return;
+				// Make sure no fingers have been changed.
+				var fingers = 0;
+				for (var key in conf.tracker) {
+					var point = conf.tracker[key];
+					if (point.end === true) return;
+					if (conf.cancel) return;
+					fingers ++;
+				}
+				// Send callback.
+				if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
+					self.state = "start";
+					self.fingers = fingers;
+					self.x = point.start.x;
+					self.y = point.start.y;
+					conf.listener(event, self);
+				}
+			}, conf.delay);
+		}
+	};
+	conf.onPointerMove = function (event) {
+		var bbox = conf.bbox;
+		var touches = event.changedTouches || root.getCoords(event);
+		var length = touches.length;
+		for (var i = 0; i < length; i ++) {
+			var touch = touches[i];
+			var identifier = touch.identifier || Infinity;
+			var pt = conf.tracker[identifier];
+			if (!pt) continue;
+			var x = (touch.pageX - bbox.x1);
+			var y = (touch.pageY - bbox.y1);
+			///
+			var dx = x - pt.start.x;
+			var dy = y - pt.start.y;
+			var distance = Math.sqrt(dx * dx + dy * dy);
+			if (!(x > 0 && x < bbox.width && // Within target coordinates..
+				  y > 0 && y < bbox.height &&
+				  distance <= conf.driftDeviance)) { // Within drift deviance.
+				// Cancel out this listener.
+				eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
+				conf.cancel = true;
+				return;
+			}
+		}
+	};
+	conf.onPointerUp = function(event) {
+		if (root.pointerEnd(event, self, conf)) {
+			clearTimeout(timeout);
+			eventjs.remove(conf.doc, "mousemove", conf.onPointerMove);
+			eventjs.remove(conf.doc, "mouseup", conf.onPointerUp);
+			if (event.cancelBubble && ++event.cancelBubbleCount > 1) return;
+			// Callback release on longpress.
+			if (conf.gesture === "longpress") {
+				if (self.state === "start") {
+					self.state = "end";
+					conf.listener(event, self);
+				}
+				return;
+			}
+			// Cancel event due to movement.
+			if (conf.cancel) return;
+			// Ensure delay is within margins.
+			if ((new Date()).getTime() - timestamp > conf.timeout) return;
+			// Send callback.
+			var fingers = conf.gestureFingers;
+			if (conf.minFingers <= fingers && conf.maxFingers >= fingers) {
+				self.state = "tap";
+				self.fingers = conf.gestureFingers;
+				conf.listener(event, self);
+			}
+		}
+	};
+	// Generate maintenance commands, and other configurations.
+	var self = root.pointerSetup(conf);
+	// Attach events.
+	eventjs.add(conf.target, "mousedown", conf.onPointerDown);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.tap = root.tap;
+eventjs.Gesture._gestureHandlers.longpress = root.longpress;
+
+return root;
+
+})(eventjs.proxy);
+/*:
+	"Mouse Wheel" event proxy.
+	----------------------------------------------------
+	eventjs.add(window, "wheel", function(event, self) {
+		console.log(self.state, self.wheelDelta);
+	});
+*/
+
+if (typeof(eventjs) === "undefined") var eventjs = {};
+if (typeof(eventjs.proxy) === "undefined") eventjs.proxy = {};
+
+eventjs.proxy = (function(root) { "use strict";
+
+root.wheelPreventElasticBounce = function(el) {
+	if (!el) return;
+	if (typeof(el) === "string") el = document.querySelector(el);
+	eventjs.add(el, "wheel", function(event, self) {
+		self.preventElasticBounce();
+		eventjs.stop(event);
+	});
+};
+
+root.wheel = function(conf) {
+	// Configure event listener.
+	var interval;
+	var timeout = conf.timeout || 150;
+	var count = 0;
+	// Externally accessible data.
+	var self = {
+		gesture: "wheel",
+		state: "start",
+		wheelDelta: 0,
+		target: conf.target,
+		listener: conf.listener,
+		preventElasticBounce: function(event) {
+			var target = this.target;
+			var scrollTop = target.scrollTop;
+			var top = scrollTop + target.offsetHeight;
+			var height = target.scrollHeight;
+			if (top === height && this.wheelDelta <= 0) eventjs.cancel(event);
+			else if (scrollTop === 0 && this.wheelDelta >= 0) eventjs.cancel(event);
+			eventjs.stop(event);
+		},
+		add: function() {
+			conf.target[add](type, onMouseWheel, false);
+		},
+		remove: function() {
+			conf.target[remove](type, onMouseWheel, false);
+		}
+	};
+	// Tracking the events.
+	var onMouseWheel = function(event) {
+		event = event || window.event;
+		self.state = count++ ? "change" : "start";
+		self.wheelDelta = event.detail ? event.detail * -20 : event.wheelDelta;
+		conf.listener(event, self);
+		clearTimeout(interval);
+		interval = setTimeout(function() {
+			count = 0;
+			self.state = "end";
+			self.wheelDelta = 0;
+			conf.listener(event, self);
+		}, timeout);
+	};
+	// Attach events.
+	var add = document.addEventListener ? "addEventListener" : "attachEvent";
+	var remove = document.removeEventListener ? "removeEventListener" : "detachEvent";
+	var type = eventjs.getEventSupport("mousewheel") ? "mousewheel" : "DOMMouseScroll";
+	conf.target[add](type, onMouseWheel, false);
+	// Return this object.
+	return self;
+};
+
+eventjs.Gesture = eventjs.Gesture || {};
+eventjs.Gesture._gestureHandlers = eventjs.Gesture._gestureHandlers || {};
+eventjs.Gesture._gestureHandlers.wheel = root.wheel;
+
+return root;
+
+})(eventjs.proxy);
+/*
+	"Orientation Change"
+	----------------------------------------------------
+	https://developer.apple.com/library/safari/documentation/SafariDOMAdditions/Reference/DeviceOrientationEventClassRef/DeviceOrientationEvent/DeviceOrientationEvent.html#//apple_ref/doc/uid/TP40010526
+	----------------------------------------------------
+	Event.add(window, "deviceorientation", function(event, self) {});
+*/
+
+if (typeof(Event) === "undefined") var Event = {};
+if (typeof(Event.proxy) === "undefined") Event.proxy = {};
+
+Event.proxy = (function(root) { "use strict";
+
+root.orientation = function(conf) {
+	// Externally accessible data.
+	var self = {
+		gesture: "orientationchange",
+		previous: null, /* Report the previous orientation */
+		current: window.orientation,
+		target: conf.target,
+		listener: conf.listener,
+		remove: function() {
+			window.removeEventListener('orientationchange', onOrientationChange, false);
+		}
+	};
+
+	// Tracking the events.
+	var onOrientationChange = function(e) {
+
+		self.previous = self.current;
+		self.current = window.orientation;
+	    if(self.previous !== null && self.previous != self.current) {
+			conf.listener(e, self);
+			return;
+	    }
+
+
+	};
+	// Attach events.
+	if (window.DeviceOrientationEvent) {
+    	window.addEventListener("orientationchange", onOrientationChange, false);
+  	}
+	// Return this object.
+	return self;
+};
+
+Event.Gesture = Event.Gesture || {};
+Event.Gesture._gestureHandlers = Event.Gesture._gestureHandlers || {};
+Event.Gesture._gestureHandlers.orientation = root.orientation;
+
+return root;
+
+})(Event.proxy);
+
+
 (function() {
 
   /**
@@ -495,7 +2456,8 @@ fabric.Collection = {
   },
 
   /**
-   * Returns true if collection contains an object
+   * Returns true if collection contains an object.\
+   * **Prefer using `Object.isDescendantOf` for performance reasons**
    * @param {Object} object Object to check against
    * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`
    * @return {Boolean} `true` if collection contains an object
@@ -1115,18 +3077,17 @@ fabric.CommonMethods = {
     },
 
     /**
-     * Groups SVG elements (usually those retrieved from SVG document)
+     * prepares options object from svg
      * @static
      * @memberOf fabric.util
      * @param {Array} elements SVG elements to group
      * @param {Object} [options] Options object
      * @param {String} path Value to set sourcePath to
-     * @return {fabric.Object|fabric.Group}
+     * @return {Object|undefined} options
      */
-    groupSVGElements: function(elements, options, path) {
-      var object;
+    getOptionsFromSVG: function (elements, options, path) {
       if (elements && elements.length === 1) {
-        return elements[0];
+        return;
       }
       if (options) {
         if (options.width && options.height) {
@@ -1140,10 +3101,27 @@ fabric.CommonMethods = {
           delete options.height;
         }
       }
-      object = new fabric.Group(elements, options);
       if (typeof path !== 'undefined') {
-        object.sourcePath = path;
+        options.sourcePath = path;
+      }
+      return options;
+    },
+
+    /**
+     * Groups SVG elements (usually those retrieved from SVG document)
+     * @static
+     * @memberOf fabric.util
+     * @param {Array} elements SVG elements to group
+     * @param {Object} [options] Options object
+     * @param {String} path Value to set sourcePath to
+     * @return {fabric.Object|fabric.Group}
+     */
+    groupSVGElements: function(elements, options, path) {
+      var object;
+      if (elements && elements.length === 1) {
+        return elements[0];
       }
+      object = new fabric.Group(elements, fabric.util.getOptionsFromSVG(elements, options, path));
       return object;
     },
 
@@ -1695,4409 +3673,4839 @@ fabric.CommonMethods = {
 
 
 (function() {
-  var _join = Array.prototype.join,
-      commandLengths = {
-        m: 2,
-        l: 2,
-        h: 1,
-        v: 1,
-        c: 6,
-        s: 4,
-        q: 4,
-        t: 2,
-        a: 7
-      },
-      repeatedCommands = {
-        m: 'l',
-        M: 'L'
-      };
-  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
-    var costh2 = fabric.util.cos(th2),
-        sinth2 = fabric.util.sin(th2),
-        costh3 = fabric.util.cos(th3),
-        sinth3 = fabric.util.sin(th3),
-        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
-        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
-        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
-        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
-        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
-        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);
-
-    return ['C',
-      cp1X, cp1Y,
-      cp2X, cp2Y,
-      toX, toY
-    ];
-  }
 
-  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
-   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
-   * http://mozilla.org/MPL/2.0/
+  /**
+   * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
+   * @static
+   * @memberOf fabric.util
+   * @param {Object} klass "Class" to create accessors for
    */
-  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
-    var PI = Math.PI, th = rotateX * PI / 180,
-        sinTh = fabric.util.sin(th),
-        cosTh = fabric.util.cos(th),
-        fromX = 0, fromY = 0;
+  fabric.util.createAccessors = function(klass) {
+    var proto = klass.prototype, i, propName,
+        capitalizedPropName, setterName, getterName;
 
-    rx = Math.abs(rx);
-    ry = Math.abs(ry);
+    for (i = proto.stateProperties.length; i--; ) {
 
-    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
-        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
-        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
-        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
-        root = 0;
+      propName = proto.stateProperties[i];
+      capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1);
+      setterName = 'set' + capitalizedPropName;
+      getterName = 'get' + capitalizedPropName;
 
-    if (pl < 0) {
-      var s = Math.sqrt(1 - pl / (rx2 * ry2));
-      rx *= s;
-      ry *= s;
-    }
-    else {
-      root = (large === sweep ? -1.0 : 1.0) *
-              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
+      // using `new Function` for better introspection
+      if (!proto[getterName]) {
+        proto[getterName] = (function(property) {
+          return new Function('return this.get("' + property + '")');
+        })(propName);
+      }
+      if (!proto[setterName]) {
+        proto[setterName] = (function(property) {
+          return new Function('value', 'return this.set("' + property + '", value)');
+        })(propName);
+      }
     }
+  };
 
-    var cx = root * rx * py / ry,
-        cy = -root * ry * px / rx,
-        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
-        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
-        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
-        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
+  /** @lends fabric.Text.Prototype */
+  /**
+   * Retrieves object's fontSize
+   * @method getFontSize
+   * @memberOf fabric.Text.prototype
+   * @return {String} Font size (in pixels)
+   */
 
-    if (sweep === 0 && dtheta > 0) {
-      dtheta -= 2 * PI;
-    }
-    else if (sweep === 1 && dtheta < 0) {
-      dtheta += 2 * PI;
-    }
+  /**
+   * Sets object's fontSize
+   * Does not update the object .width and .height,
+   * call .initDimensions() to update the values.
+   * @method setFontSize
+   * @memberOf fabric.Text.prototype
+   * @param {Number} fontSize Font size (in pixels)
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-    // Convert into cubic bezier segments <= 90deg
-    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
-        result = [], mDelta = dtheta / segments,
-        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
-        th3 = mTheta + mDelta;
+  /**
+   * Retrieves object's fontWeight
+   * @method getFontWeight
+   * @memberOf fabric.Text.prototype
+   * @return {(String|Number)} Font weight
+   */
 
-    for (var i = 0; i < segments; i++) {
-      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
-      fromX = result[i][5];
-      fromY = result[i][6];
-      mTheta = th3;
-      th3 += mDelta;
-    }
-    return result;
-  }
+  /**
+   * Sets object's fontWeight
+   * Does not update the object .width and .height,
+   * call .initDimensions() to update the values.
+   * @method setFontWeight
+   * @memberOf fabric.Text.prototype
+   * @param {(Number|String)} fontWeight Font weight
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-  /*
-   * Private
+  /**
+   * Retrieves object's fontFamily
+   * @method getFontFamily
+   * @memberOf fabric.Text.prototype
+   * @return {String} Font family
    */
-  function calcVectorAngle(ux, uy, vx, vy) {
-    var ta = Math.atan2(uy, ux),
-        tb = Math.atan2(vy, vx);
-    if (tb >= ta) {
-      return tb - ta;
-    }
-    else {
-      return 2 * Math.PI - (ta - tb);
-    }
-  }
 
   /**
-   * Calculate bounding box of a beziercurve
-   * @param {Number} x0 starting point
-   * @param {Number} y0
-   * @param {Number} x1 first control point
-   * @param {Number} y1
-   * @param {Number} x2 secondo control point
-   * @param {Number} y2
-   * @param {Number} x3 end of bezier
-   * @param {Number} y3
+   * Sets object's fontFamily
+   * Does not update the object .width and .height,
+   * call .initDimensions() to update the values.
+   * @method setFontFamily
+   * @memberOf fabric.Text.prototype
+   * @param {String} fontFamily Font family
+   * @return {fabric.Text}
+   * @chainable
    */
-  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
-  // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?
-  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
-    var argsString;
-    if (fabric.cachesBoundsOfCurve) {
-      argsString = _join.call(arguments);
-      if (fabric.boundsOfCurveCache[argsString]) {
-        return fabric.boundsOfCurveCache[argsString];
-      }
-    }
 
-    var sqrt = Math.sqrt,
-        min = Math.min, max = Math.max,
-        abs = Math.abs, tvalues = [],
-        bounds = [[], []],
-        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
+  /**
+   * Retrieves object's text
+   * @method getText
+   * @memberOf fabric.Text.prototype
+   * @return {String} text
+   */
 
-    b = 6 * x0 - 12 * x1 + 6 * x2;
-    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
-    c = 3 * x1 - 3 * x0;
+  /**
+   * Sets object's text
+   * Does not update the object .width and .height,
+   * call .initDimensions() to update the values.
+   * @method setText
+   * @memberOf fabric.Text.prototype
+   * @param {String} text Text
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-    for (var i = 0; i < 2; ++i) {
-      if (i > 0) {
-        b = 6 * y0 - 12 * y1 + 6 * y2;
-        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
-        c = 3 * y1 - 3 * y0;
-      }
+  /**
+   * Retrieves object's underline
+   * @method getUnderline
+   * @memberOf fabric.Text.prototype
+   * @return {Boolean} underline enabled or disabled
+   */
 
-      if (abs(a) < 1e-12) {
-        if (abs(b) < 1e-12) {
-          continue;
-        }
-        t = -c / b;
-        if (0 < t && t < 1) {
-          tvalues.push(t);
-        }
-        continue;
-      }
-      b2ac = b * b - 4 * c * a;
-      if (b2ac < 0) {
-        continue;
-      }
-      sqrtb2ac = sqrt(b2ac);
-      t1 = (-b + sqrtb2ac) / (2 * a);
-      if (0 < t1 && t1 < 1) {
-        tvalues.push(t1);
-      }
-      t2 = (-b - sqrtb2ac) / (2 * a);
-      if (0 < t2 && t2 < 1) {
-        tvalues.push(t2);
-      }
-    }
+  /**
+   * Sets object's underline
+   * @method setUnderline
+   * @memberOf fabric.Text.prototype
+   * @param {Boolean} underline Text decoration
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-    var x, y, j = tvalues.length, jlen = j, mt;
-    while (j--) {
-      t = tvalues[j];
-      mt = 1 - t;
-      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
-      bounds[0][j] = x;
+  /**
+   * Retrieves object's fontStyle
+   * @method getFontStyle
+   * @memberOf fabric.Text.prototype
+   * @return {String} Font style
+   */
 
-      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
-      bounds[1][j] = y;
-    }
+  /**
+   * Sets object's fontStyle
+   * Does not update the object .width and .height,
+   * call .initDimensions() to update the values.
+   * @method setFontStyle
+   * @memberOf fabric.Text.prototype
+   * @param {String} fontStyle Font style
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-    bounds[0][jlen] = x0;
-    bounds[1][jlen] = y0;
-    bounds[0][jlen + 1] = x3;
-    bounds[1][jlen + 1] = y3;
-    var result = [
-      {
-        x: min.apply(null, bounds[0]),
-        y: min.apply(null, bounds[1])
-      },
-      {
-        x: max.apply(null, bounds[0]),
-        y: max.apply(null, bounds[1])
-      }
-    ];
-    if (fabric.cachesBoundsOfCurve) {
-      fabric.boundsOfCurveCache[argsString] = result;
-    }
-    return result;
-  }
+  /**
+   * Retrieves object's lineHeight
+   * @method getLineHeight
+   * @memberOf fabric.Text.prototype
+   * @return {Number} Line height
+   */
 
   /**
-   * Converts arc to a bunch of bezier curves
-   * @param {Number} fx starting point x
-   * @param {Number} fy starting point y
-   * @param {Array} coords Arc command
+   * Sets object's lineHeight
+   * @method setLineHeight
+   * @memberOf fabric.Text.prototype
+   * @param {Number} lineHeight Line height
+   * @return {fabric.Text}
+   * @chainable
    */
-  function fromArcToBeziers(fx, fy, coords) {
-    var rx = coords[1],
-        ry = coords[2],
-        rot = coords[3],
-        large = coords[4],
-        sweep = coords[5],
-        tx = coords[6],
-        ty = coords[7],
-        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
 
-    for (var i = 0, len = segsNorm.length; i < len; i++) {
-      segsNorm[i][1] += fx;
-      segsNorm[i][2] += fy;
-      segsNorm[i][3] += fx;
-      segsNorm[i][4] += fy;
-      segsNorm[i][5] += fx;
-      segsNorm[i][6] += fy;
-    }
-    return segsNorm;
-  };
+  /**
+   * Retrieves object's textAlign
+   * @method getTextAlign
+   * @memberOf fabric.Text.prototype
+   * @return {String} Text alignment
+   */
 
   /**
-   * This function take a parsed SVG path and make it simpler for fabricJS logic.
-   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )
-   * S converted in C, T converted in Q, A converted in C.
-   * @param {Array} path the array of commands of a parsed svg path for fabric.Path
-   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path
+   * Sets object's textAlign
+   * @method setTextAlign
+   * @memberOf fabric.Text.prototype
+   * @param {String} textAlign Text alignment
+   * @return {fabric.Text}
+   * @chainable
    */
-  function makePathSimpler(path) {
-    // x and y represent the last point of the path. the previous command point.
-    // we add them to each relative command to make it an absolute comment.
-    // we also swap the v V h H with L, because are easier to transform.
-    var x = 0, y = 0, len = path.length,
-        // x1 and y1 represent the last point of the subpath. the subpath is started with
-        // m or M command. When a z or Z command is drawn, x and y need to be resetted to
-        // the last x1 and y1.
-        x1 = 0, y1 = 0, current, i, converted,
-        // previous will host the letter of the previous command, to handle S and T.
-        // controlX and controlY will host the previous reflected control point
-        destinationPath = [], previous, controlX, controlY;
-    for (i = 0; i < len; ++i) {
-      converted = false;
-      current = path[i].slice(0);
-      switch (current[0]) { // first letter
-        case 'l': // lineto, relative
-          current[0] = 'L';
-          current[1] += x;
-          current[2] += y;
-          // falls through
-        case 'L':
-          x = current[1];
-          y = current[2];
-          break;
-        case 'h': // horizontal lineto, relative
-          current[1] += x;
-          // falls through
-        case 'H':
-          current[0] = 'L';
-          current[2] = y;
-          x = current[1];
-          break;
-        case 'v': // vertical lineto, relative
-          current[1] += y;
-          // falls through
-        case 'V':
-          current[0] = 'L';
-          y = current[1];
-          current[1] = x;
-          current[2] = y;
-          break;
-        case 'm': // moveTo, relative
-          current[0] = 'M';
-          current[1] += x;
-          current[2] += y;
-          // falls through
-        case 'M':
-          x = current[1];
-          y = current[2];
-          x1 = current[1];
-          y1 = current[2];
-          break;
-        case 'c': // bezierCurveTo, relative
-          current[0] = 'C';
-          current[1] += x;
-          current[2] += y;
-          current[3] += x;
-          current[4] += y;
-          current[5] += x;
-          current[6] += y;
-          // falls through
-        case 'C':
-          controlX = current[3];
-          controlY = current[4];
-          x = current[5];
-          y = current[6];
-          break;
-        case 's': // shorthand cubic bezierCurveTo, relative
-          current[0] = 'S';
-          current[1] += x;
-          current[2] += y;
-          current[3] += x;
-          current[4] += y;
-          // falls through
-        case 'S':
-          // would be sScC but since we are swapping sSc for C, we check just that.
-          if (previous === 'C') {
-            // calculate reflection of previous control points
-            controlX = 2 * x - controlX;
-            controlY = 2 * y - controlY;
-          }
-          else {
-            // If there is no previous command or if the previous command was not a C, c, S, or s,
-            // the control point is coincident with the current point
-            controlX = x;
-            controlY = y;
-          }
-          x = current[3];
-          y = current[4];
-          current[0] = 'C';
-          current[5] = current[3];
-          current[6] = current[4];
-          current[3] = current[1];
-          current[4] = current[2];
-          current[1] = controlX;
-          current[2] = controlY;
-          // current[3] and current[4] are NOW the second control point.
-          // we keep it for the next reflection.
-          controlX = current[3];
-          controlY = current[4];
-          break;
-        case 'q': // quadraticCurveTo, relative
-          current[0] = 'Q';
-          current[1] += x;
-          current[2] += y;
-          current[3] += x;
-          current[4] += y;
-          // falls through
-        case 'Q':
-          controlX = current[1];
-          controlY = current[2];
-          x = current[3];
-          y = current[4];
-          break;
-        case 't': // shorthand quadraticCurveTo, relative
-          current[0] = 'T';
-          current[1] += x;
-          current[2] += y;
-          // falls through
-        case 'T':
-          if (previous === 'Q') {
-            // calculate reflection of previous control point
-            controlX = 2 * x - controlX;
-            controlY = 2 * y - controlY;
-          }
-          else {
-            // If there is no previous command or if the previous command was not a Q, q, T or t,
-            // assume the control point is coincident with the current point
-            controlX = x;
-            controlY = y;
-          }
-          current[0] = 'Q';
-          x = current[1];
-          y = current[2];
-          current[1] = controlX;
-          current[2] = controlY;
-          current[3] = x;
-          current[4] = y;
-          break;
-        case 'a':
-          current[0] = 'A';
-          current[6] += x;
-          current[7] += y;
-          // falls through
-        case 'A':
-          converted = true;
-          destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
-          x = current[6];
-          y = current[7];
-          break;
-        case 'z':
-        case 'Z':
-          x = x1;
-          y = y1;
-          break;
-        default:
-      }
-      if (!converted) {
-        destinationPath.push(current);
-      }
-      previous = current[0];
-    }
-    return destinationPath;
-  };
 
   /**
-   * Calc length from point x1,y1 to x2,y2
-   * @param {Number} x1 starting point x
-   * @param {Number} y1 starting point y
-   * @param {Number} x2 starting point x
-   * @param {Number} y2 starting point y
-   * @return {Number} length of segment
+   * Retrieves object's textBackgroundColor
+   * @method getTextBackgroundColor
+   * @memberOf fabric.Text.prototype
+   * @return {String} Text background color
    */
-  function calcLineLength(x1, y1, x2, y2) {
-    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
-  }
 
-  // functions for the Cubic beizer
-  // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350
-  function CB1(t) {
-    return t * t * t;
-  }
-  function CB2(t) {
-    return 3 * t * t * (1 - t);
-  }
-  function CB3(t) {
-    return 3 * t * (1 - t) * (1 - t);
-  }
-  function CB4(t) {
-    return (1 - t) * (1 - t) * (1 - t);
-  }
+  /**
+   * Sets object's textBackgroundColor
+   * @method setTextBackgroundColor
+   * @memberOf fabric.Text.prototype
+   * @param {String} textBackgroundColor Text background color
+   * @return {fabric.Text}
+   * @chainable
+   */
 
-  function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
-    return function(pct) {
-      var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
-      return {
-        x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
-        y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
-      };
-    };
-  }
+  /** @lends fabric.Object.Prototype */
+  /**
+   * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}
+   * @method getTransformMatrix
+   * @memberOf fabric.Object.prototype
+   * @return {Array} transformMatrix
+   */
 
-  function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
-    return function (pct) {
-      var invT = 1 - pct,
-          tangentX = (3 * invT * invT * (p2x - p1x)) + (6 * invT * pct * (p3x - p2x)) +
-          (3 * pct * pct * (p4x - p3x)),
-          tangentY = (3 * invT * invT * (p2y - p1y)) + (6 * invT * pct * (p3y - p2y)) +
-          (3 * pct * pct * (p4y - p3y));
-      return Math.atan2(tangentY, tangentX);
-    };
-  }
+  /**
+   * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}
+   * @method setTransformMatrix
+   * @memberOf fabric.Object.prototype
+   * @param {Array} transformMatrix
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-  function QB1(t) {
-    return t * t;
-  }
+  /**
+   * Retrieves object's {@link fabric.Object#visible|visible} state
+   * @method getVisible
+   * @memberOf fabric.Object.prototype
+   * @return {Boolean} True if visible
+   */
 
-  function QB2(t) {
-    return 2 * t * (1 - t);
-  }
+  /**
+   * Sets object's {@link fabric.Object#visible|visible} state
+   * @method setVisible
+   * @memberOf fabric.Object.prototype
+   * @param {Boolean} value visible value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-  function QB3(t) {
-    return (1 - t) * (1 - t);
-  }
+  /**
+   * Retrieves object's {@link fabric.Object#shadow|shadow}
+   * @method getShadow
+   * @memberOf fabric.Object.prototype
+   * @return {Object} Shadow instance
+   */
 
-  function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
-    return function(pct) {
-      var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
-      return {
-        x: p3x * c1 + p2x * c2 + p1x * c3,
-        y: p3y * c1 + p2y * c2 + p1y * c3
-      };
-    };
-  }
+  /**
+   * Retrieves object's {@link fabric.Object#stroke|stroke}
+   * @method getStroke
+   * @memberOf fabric.Object.prototype
+   * @return {String} stroke value
+   */
 
-  function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
-    return function (pct) {
-      var invT = 1 - pct,
-          tangentX = (2 * invT * (p2x - p1x)) + (2 * pct * (p3x - p2x)),
-          tangentY = (2 * invT * (p2y - p1y)) + (2 * pct * (p3y - p2y));
-      return Math.atan2(tangentY, tangentX);
-    };
-  }
+  /**
+   * Sets object's {@link fabric.Object#stroke|stroke}
+   * @method setStroke
+   * @memberOf fabric.Object.prototype
+   * @param {String} value stroke value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
+  /**
+   * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}
+   * @method getStrokeWidth
+   * @memberOf fabric.Object.prototype
+   * @return {Number} strokeWidth value
+   */
 
-  // this will run over a path segment ( a cubic or quadratic segment) and approximate it
-  // with 100 segemnts. This will good enough to calculate the length of the curve
-  function pathIterator(iterator, x1, y1) {
-    var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
-    for (perc = 1; perc <= 100; perc += 1) {
-      p = iterator(perc / 100);
-      tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
-      tempP = p;
-    }
-    return tmpLen;
-  }
+  /**
+   * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}
+   * @method setStrokeWidth
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value strokeWidth value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
   /**
-   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1
-   * that correspond to that pixels run over the path.
-   * The percentage will be then used to find the correct point on the canvas for the path.
-   * @param {Array} segInfo fabricJS collection of information on a parsed path
-   * @param {Number} distance from starting point, in pixels.
-   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;
+   * Retrieves object's {@link fabric.Object#originX|originX}
+   * @method getOriginX
+   * @memberOf fabric.Object.prototype
+   * @return {String} originX value
    */
-  function findPercentageForDistance(segInfo, distance) {
-    var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y },
-        p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
-    // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
-    // the path
-    while (tmpLen < distance && perc <= 1 && nextStep > 0.0001) {
-      p = iterator(perc);
-      lastPerc = perc;
-      nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
-      // compare tmpLen each cycle with distance, decide next perc to test.
-      if ((nextLen + tmpLen) > distance) {
-        // we discard this step and we make smaller steps.
-        nextStep /= 2;
-        perc -= nextStep;
-      }
-      else {
-        tempP = p;
-        perc += nextStep;
-        tmpLen += nextLen;
-      }
-    }
-    p.angle = angleFinder(lastPerc);
-    return p;
-  }
 
   /**
-   * Run over a parsed and simplifed path and extrac some informations.
-   * informations are length of each command and starting point
-   * @param {Array} path fabricJS parsed path commands
-   * @return {Array} path commands informations
+   * Sets object's {@link fabric.Object#originX|originX}
+   * @method setOriginX
+   * @memberOf fabric.Object.prototype
+   * @param {String} value originX value
+   * @return {fabric.Object} thisArg
+   * @chainable
    */
-  function getPathSegmentsInfo(path) {
-    var totalLength = 0, len = path.length, current,
-        //x2 and y2 are the coords of segment start
-        //x1 and y1 are the coords of the current point
-        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
-    for (var i = 0; i < len; i++) {
-      current = path[i];
-      tempInfo = {
-        x: x1,
-        y: y1,
-        command: current[0],
-      };
-      switch (current[0]) { //first letter
-        case 'M':
-          tempInfo.length = 0;
-          x2 = x1 = current[1];
-          y2 = y1 = current[2];
-          break;
-        case 'L':
-          tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
-          x1 = current[1];
-          y1 = current[2];
-          break;
-        case 'C':
-          iterator = getPointOnCubicBezierIterator(
-            x1,
-            y1,
-            current[1],
-            current[2],
-            current[3],
-            current[4],
-            current[5],
-            current[6]
-          );
-          angleFinder = getTangentCubicIterator(
-            x1,
-            y1,
-            current[1],
-            current[2],
-            current[3],
-            current[4],
-            current[5],
-            current[6]
-          );
-          tempInfo.iterator = iterator;
-          tempInfo.angleFinder = angleFinder;
-          tempInfo.length = pathIterator(iterator, x1, y1);
-          x1 = current[5];
-          y1 = current[6];
-          break;
-        case 'Q':
-          iterator = getPointOnQuadraticBezierIterator(
-            x1,
-            y1,
-            current[1],
-            current[2],
-            current[3],
-            current[4]
-          );
-          angleFinder = getTangentQuadraticIterator(
-            x1,
-            y1,
-            current[1],
-            current[2],
-            current[3],
-            current[4]
-          );
-          tempInfo.iterator = iterator;
-          tempInfo.angleFinder = angleFinder;
-          tempInfo.length = pathIterator(iterator, x1, y1);
-          x1 = current[3];
-          y1 = current[4];
-          break;
-        case 'Z':
-        case 'z':
-          // we add those in order to ease calculations later
-          tempInfo.destX = x2;
-          tempInfo.destY = y2;
-          tempInfo.length = calcLineLength(x1, y1, x2, y2);
-          x1 = x2;
-          y1 = y2;
-          break;
-      }
-      totalLength += tempInfo.length;
-      info.push(tempInfo);
-    }
-    info.push({ length: totalLength, x: x1, y: y1 });
-    return info;
-  }
 
-  function getPointOnPath(path, distance, infos) {
-    if (!infos) {
-      infos = getPathSegmentsInfo(path);
-    }
-    var i = 0;
-    while ((distance - infos[i].length > 0) && i < (infos.length - 2)) {
-      distance -= infos[i].length;
-      i++;
-    }
-    // var distance = infos[infos.length - 1] * perc;
-    var segInfo = infos[i], segPercent = distance / segInfo.length,
-        command = segInfo.command, segment = path[i], info;
+  /**
+   * Retrieves object's {@link fabric.Object#originY|originY}
+   * @method getOriginY
+   * @memberOf fabric.Object.prototype
+   * @return {String} originY value
+   */
 
-    switch (command) {
-      case 'M':
-        return { x: segInfo.x, y: segInfo.y, angle: 0 };
-      case 'Z':
-      case 'z':
-        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
-          new fabric.Point(segInfo.destX, segInfo.destY),
-          segPercent
-        );
-        info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
-        return info;
-      case 'L':
-        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
-          new fabric.Point(segment[1], segment[2]),
-          segPercent
-        );
-        info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
-        return info;
-      case 'C':
-        return findPercentageForDistance(segInfo, distance);
-      case 'Q':
-        return findPercentageForDistance(segInfo, distance);
-    }
-  }
+  /**
+   * Sets object's {@link fabric.Object#originY|originY}
+   * @method setOriginY
+   * @memberOf fabric.Object.prototype
+   * @param {String} value originY value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
   /**
-   *
-   * @param {string} pathString
-   * @return {(string|number)[][]} An array of SVG path commands
-   * @example <caption>Usage</caption>
-   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [
-   *   ['M', 3, 4],
-   *   ['Q', 3, 5, 2, 1, 4, 0],
-   *   ['Q', 9, 12, 2, 1, 4, 0],
-   * ];
-   *
+   * Retrieves object's {@link fabric.Object#fill|fill}
+   * @method getFill
+   * @memberOf fabric.Object.prototype
+   * @return {String} Fill value
    */
-  function parsePath(pathString) {
-    var result = [],
-        coords = [],
-        currentPath,
-        parsed,
-        re = fabric.rePathCommand,
-        rNumber = '[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*',
-        rNumberCommaWsp = '(' + rNumber + ')' + fabric.commaWsp,
-        rFlagCommaWsp = '([01])' + fabric.commaWsp + '?',
-        rArcSeq = rNumberCommaWsp + '?' + rNumberCommaWsp + '?' + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp +
-          rNumberCommaWsp + '?(' + rNumber + ')',
-        regArcArgumentSequence = new RegExp(rArcSeq, 'g'),
-        match,
-        coordsStr,
-        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
-        path;
-    if (!pathString || !pathString.match) {
-      return result;
-    }
-    path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
 
-    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
-      currentPath = path[i];
+  /**
+   * Sets object's {@link fabric.Object#fill|fill}
+   * @method setFill
+   * @memberOf fabric.Object.prototype
+   * @param {String} value Fill value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-      coordsStr = currentPath.slice(1).trim();
-      coords.length = 0;
+  /**
+   * Retrieves object's {@link fabric.Object#opacity|opacity}
+   * @method getOpacity
+   * @memberOf fabric.Object.prototype
+   * @return {Number} Opacity value (0-1)
+   */
 
-      var command = currentPath.charAt(0);
-      coordsParsed = [command];
+  /**
+   * Sets object's {@link fabric.Object#opacity|opacity}
+   * @method setOpacity
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value Opacity value (0-1)
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-      if (command.toLowerCase() === 'a') {
-        // arcs have special flags that apparently don't require spaces so handle special
-        for (var args; (args = regArcArgumentSequence.exec(coordsStr));) {
-          for (var j = 1; j < args.length; j++) {
-            coords.push(args[j]);
-          }
-        }
-      }
-      else {
-        while ((match = re.exec(coordsStr))) {
-          coords.push(match[0]);
-        }
-      }
+  /**
+   * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)
+   * @method getAngle
+   * @memberOf fabric.Object.prototype
+   * @return {Number}
+   */
 
-      for (var j = 0, jlen = coords.length; j < jlen; j++) {
-        parsed = parseFloat(coords[j]);
-        if (!isNaN(parsed)) {
-          coordsParsed.push(parsed);
-        }
-      }
+  /**
+   * Retrieves object's {@link fabric.Object#top|top position}
+   * @method getTop
+   * @memberOf fabric.Object.prototype
+   * @return {Number} Top value (in pixels)
+   */
 
-      var commandLength = commandLengths[command.toLowerCase()],
-          repeatedCommand = repeatedCommands[command] || command;
+  /**
+   * Sets object's {@link fabric.Object#top|top position}
+   * @method setTop
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value Top value (in pixels)
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-      if (coordsParsed.length - 1 > commandLength) {
-        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
-          result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
-          command = repeatedCommand;
-        }
-      }
-      else {
-        result.push(coordsParsed);
-      }
-    }
+  /**
+   * Retrieves object's {@link fabric.Object#left|left position}
+   * @method getLeft
+   * @memberOf fabric.Object.prototype
+   * @return {Number} Left value (in pixels)
+   */
 
-    return result;
-  };
+  /**
+   * Sets object's {@link fabric.Object#left|left position}
+   * @method setLeft
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value Left value (in pixels)
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
   /**
-   *
-   * Converts points to a smooth SVG path
-   * @param {{ x: number,y: number }[]} points Array of points
-   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.
-   * @return {(string|number)[][]} An array of SVG path commands
+   * Retrieves object's {@link fabric.Object#scaleX|scaleX} value
+   * @method getScaleX
+   * @memberOf fabric.Object.prototype
+   * @return {Number} scaleX value
    */
-  function getSmoothPathFromPoints(points, correction) {
-    var path = [], i,
-        p1 = new fabric.Point(points[0].x, points[0].y),
-        p2 = new fabric.Point(points[1].x, points[1].y),
-        len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;
-    correction = correction || 0;
 
-    if (manyPoints) {
-      multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
-      multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
-    }
-    path.push(['M', p1.x - multSignX * correction, p1.y - multSignY * correction]);
-    for (i = 1; i < len; i++) {
-      if (!p1.eq(p2)) {
-        var midPoint = p1.midPointFrom(p2);
-        // p1 is our bezier control point
-        // midpoint is our endpoint
-        // start point is p(i-1) value.
-        path.push(['Q', p1.x, p1.y, midPoint.x, midPoint.y]);
-      }
-      p1 = points[i];
-      if ((i + 1) < points.length) {
-        p2 = points[i + 1];
-      }
-    }
-    if (manyPoints) {
-      multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
-      multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
-    }
-    path.push(['L', p1.x + multSignX * correction, p1.y + multSignY * correction]);
-    return path;
-  }
   /**
-   * Transform a path by transforming each segment.
-   * it has to be a simplified path or it won't work.
-   * WARNING: this depends from pathOffset for correct operation
-   * @param {Array} path fabricJS parsed and simplified path commands
-   * @param {Array} transform matrix that represent the transformation
-   * @param {Object} [pathOffset] the fabric.Path pathOffset
-   * @param {Number} pathOffset.x
-   * @param {Number} pathOffset.y
-   * @returns {Array} the transformed path
+   * Sets object's {@link fabric.Object#scaleX|scaleX} value
+   * @method setScaleX
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value scaleX value
+   * @return {fabric.Object} thisArg
+   * @chainable
    */
-  function transformPath(path, transform, pathOffset) {
-    if (pathOffset) {
-      transform = fabric.util.multiplyTransformMatrices(
-        transform,
-        [1, 0, 0, 1, -pathOffset.x, -pathOffset.y]
-      );
-    }
-    return path.map(function(pathSegment) {
-      var newSegment = pathSegment.slice(0), point = {};
-      for (var i = 1; i < pathSegment.length - 1; i += 2) {
-        point.x = pathSegment[i];
-        point.y = pathSegment[i + 1];
-        point = fabric.util.transformPoint(point, transform);
-        newSegment[i] = point.x;
-        newSegment[i + 1] = point.y;
-      }
-      return newSegment;
-    });
-  }
 
   /**
-   * Calculate bounding box of a elliptic-arc
-   * @deprecated
-   * @param {Number} fx start point of arc
-   * @param {Number} fy
-   * @param {Number} rx horizontal radius
-   * @param {Number} ry vertical radius
-   * @param {Number} rot angle of horizontal axis
-   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
-   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
-   * @param {Number} tx end point of arc
-   * @param {Number} ty
+   * Retrieves object's {@link fabric.Object#scaleY|scaleY} value
+   * @method getScaleY
+   * @memberOf fabric.Object.prototype
+   * @return {Number} scaleY value
    */
-  function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
 
-    var fromX = 0, fromY = 0, bound, bounds = [],
-        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
+  /**
+   * Sets object's {@link fabric.Object#scaleY|scaleY} value
+   * @method setScaleY
+   * @memberOf fabric.Object.prototype
+   * @param {Number} value scaleY value
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
 
-    for (var i = 0, len = segs.length; i < len; i++) {
-      bound = getBoundsOfCurve(fromX, fromY, segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5], segs[i][6]);
-      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
-      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
-      fromX = segs[i][5];
-      fromY = segs[i][6];
-    }
-    return bounds;
-  };
+  /**
+   * Retrieves object's {@link fabric.Object#flipX|flipX} value
+   * @method getFlipX
+   * @memberOf fabric.Object.prototype
+   * @return {Boolean} flipX value
+   */
 
   /**
-   * Draws arc
-   * @deprecated
-   * @param {CanvasRenderingContext2D} ctx
-   * @param {Number} fx
-   * @param {Number} fy
-   * @param {Array} coords coords of the arc, without the front 'A/a'
+   * Sets object's {@link fabric.Object#flipX|flipX} value
+   * @method setFlipX
+   * @memberOf fabric.Object.prototype
+   * @param {Boolean} value flipX value
+   * @return {fabric.Object} thisArg
+   * @chainable
    */
-  function drawArc(ctx, fx, fy, coords) {
-    coords = coords.slice(0).unshift('X'); // command A or a does not matter
-    var beziers = fromArcToBeziers(fx, fy, coords);
-    beziers.forEach(function(bezier) {
-      ctx.bezierCurveTo.apply(ctx, bezier.slice(1));
-    });
-  };
 
   /**
-   * Join path commands to go back to svg format
-   * @param {Array} pathData fabricJS parsed path commands
-   * @return {String} joined path 'M 0 0 L 20 30'
+   * Retrieves object's {@link fabric.Object#flipY|flipY} value
+   * @method getFlipY
+   * @memberOf fabric.Object.prototype
+   * @return {Boolean} flipY value
    */
-  fabric.util.joinPath = function(pathData) {
-    return pathData.map(function (segment) { return segment.join(' '); }).join(' ');
-  };
-  fabric.util.parsePath = parsePath;
-  fabric.util.makePathSimpler = makePathSimpler;
-  fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;
-  fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
-  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
-  fabric.util.getPointOnPath = getPointOnPath;
-  fabric.util.transformPath = transformPath;
+
   /**
-   * Typo of `fromArcToBeziers` kept for not breaking the api once corrected.
-   * Will be removed in fabric 5.0
-   * @deprecated
+   * Sets object's {@link fabric.Object#flipY|flipY} value
+   * @method setFlipY
+   * @memberOf fabric.Object.prototype
+   * @param {Boolean} value flipY value
+   * @return {fabric.Object} thisArg
+   * @chainable
    */
-  fabric.util.fromArcToBeizers = fromArcToBeziers;
-  // kept because we do not want to make breaking changes.
-  // but useless and deprecated.
-  fabric.util.getBoundsOfArc = getBoundsOfArc;
-  fabric.util.drawArc = drawArc;
-})();
+
+})(typeof exports !== 'undefined' ? exports : this);
 
 
 (function() {
+  var _join = Array.prototype.join,
+      commandLengths = {
+        m: 2,
+        l: 2,
+        h: 1,
+        v: 1,
+        c: 6,
+        s: 4,
+        q: 4,
+        t: 2,
+        a: 7
+      },
+      repeatedCommands = {
+        m: 'l',
+        M: 'L'
+      };
+  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
+    var costh2 = fabric.util.cos(th2),
+        sinth2 = fabric.util.sin(th2),
+        costh3 = fabric.util.cos(th3),
+        sinth3 = fabric.util.sin(th3),
+        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
+        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
+        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
+        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
+        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
+        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);
 
-  var slice = Array.prototype.slice;
+    return ['C',
+      cp1X, cp1Y,
+      cp2X, cp2Y,
+      toX, toY
+    ];
+  }
 
-  /**
-   * Invokes method on all items in a given array
-   * @memberOf fabric.util.array
-   * @param {Array} array Array to iterate over
-   * @param {String} method Name of a method to invoke
-   * @return {Array}
+  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
+   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
+   * http://mozilla.org/MPL/2.0/
    */
-  function invoke(array, method) {
-    var args = slice.call(arguments, 2), result = [];
-    for (var i = 0, len = array.length; i < len; i++) {
-      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
+  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
+    var PI = Math.PI, th = rotateX * PI / 180,
+        sinTh = fabric.util.sin(th),
+        cosTh = fabric.util.cos(th),
+        fromX = 0, fromY = 0;
+
+    rx = Math.abs(rx);
+    ry = Math.abs(ry);
+
+    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
+        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
+        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
+        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
+        root = 0;
+
+    if (pl < 0) {
+      var s = Math.sqrt(1 - pl / (rx2 * ry2));
+      rx *= s;
+      ry *= s;
+    }
+    else {
+      root = (large === sweep ? -1.0 : 1.0) *
+              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
     }
-    return result;
-  }
 
-  /**
-   * Finds maximum value in array (not necessarily "first" one)
-   * @memberOf fabric.util.array
-   * @param {Array} array Array to iterate over
-   * @param {String} byProperty
-   * @return {*}
-   */
-  function max(array, byProperty) {
-    return find(array, byProperty, function(value1, value2) {
-      return value1 >= value2;
-    });
-  }
+    var cx = root * rx * py / ry,
+        cy = -root * ry * px / rx,
+        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
+        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
+        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
+        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
 
-  /**
-   * Finds minimum value in array (not necessarily "first" one)
-   * @memberOf fabric.util.array
-   * @param {Array} array Array to iterate over
-   * @param {String} byProperty
-   * @return {*}
-   */
-  function min(array, byProperty) {
-    return find(array, byProperty, function(value1, value2) {
-      return value1 < value2;
-    });
-  }
+    if (sweep === 0 && dtheta > 0) {
+      dtheta -= 2 * PI;
+    }
+    else if (sweep === 1 && dtheta < 0) {
+      dtheta += 2 * PI;
+    }
 
-  /**
-   * @private
-   */
-  function fill(array, value) {
-    var k = array.length;
-    while (k--) {
-      array[k] = value;
+    // Convert into cubic bezier segments <= 90deg
+    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
+        result = [], mDelta = dtheta / segments,
+        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
+        th3 = mTheta + mDelta;
+
+    for (var i = 0; i < segments; i++) {
+      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
+      fromX = result[i][5];
+      fromY = result[i][6];
+      mTheta = th3;
+      th3 += mDelta;
     }
-    return array;
+    return result;
   }
 
-  /**
-   * @private
+  /*
+   * Private
    */
-  function find(array, byProperty, condition) {
-    if (!array || array.length === 0) {
-      return;
-    }
-
-    var i = array.length - 1,
-        result = byProperty ? array[i][byProperty] : array[i];
-    if (byProperty) {
-      while (i--) {
-        if (condition(array[i][byProperty], result)) {
-          result = array[i][byProperty];
-        }
-      }
+  function calcVectorAngle(ux, uy, vx, vy) {
+    var ta = Math.atan2(uy, ux),
+        tb = Math.atan2(vy, vx);
+    if (tb >= ta) {
+      return tb - ta;
     }
     else {
-      while (i--) {
-        if (condition(array[i], result)) {
-          result = array[i];
-        }
-      }
+      return 2 * Math.PI - (ta - tb);
     }
-    return result;
   }
 
   /**
-   * @namespace fabric.util.array
+   * Calculate bounding box of a beziercurve
+   * @param {Number} x0 starting point
+   * @param {Number} y0
+   * @param {Number} x1 first control point
+   * @param {Number} y1
+   * @param {Number} x2 secondo control point
+   * @param {Number} y2
+   * @param {Number} x3 end of bezier
+   * @param {Number} y3
    */
-  fabric.util.array = {
-    fill: fill,
-    invoke: invoke,
-    min: min,
-    max: max
-  };
-
-})();
-
+  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
+  // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?
+  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
+    var argsString;
+    if (fabric.cachesBoundsOfCurve) {
+      argsString = _join.call(arguments);
+      if (fabric.boundsOfCurveCache[argsString]) {
+        return fabric.boundsOfCurveCache[argsString];
+      }
+    }
 
-(function() {
-  /**
-   * Copies all enumerable properties of one js object to another
-   * this does not and cannot compete with generic utils.
-   * Does not clone or extend fabric.Object subclasses.
-   * This is mostly for internal use and has extra handling for fabricJS objects
-   * it skips the canvas and group properties in deep cloning.
-   * @memberOf fabric.util.object
-   * @param {Object} destination Where to copy to
-   * @param {Object} source Where to copy from
-   * @param {Boolean} [deep] Whether to extend nested objects
-   * @return {Object}
-   */
+    var sqrt = Math.sqrt,
+        min = Math.min, max = Math.max,
+        abs = Math.abs, tvalues = [],
+        bounds = [[], []],
+        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
 
-  function extend(destination, source, deep) {
-    // JScript DontEnum bug is not taken care of
-    // the deep clone is for internal use, is not meant to avoid
-    // javascript traps or cloning html element or self referenced objects.
-    if (deep) {
-      if (!fabric.isLikelyNode && source instanceof Element) {
-        // avoid cloning deep images, canvases,
-        destination = source;
+    b = 6 * x0 - 12 * x1 + 6 * x2;
+    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
+    c = 3 * x1 - 3 * x0;
+
+    for (var i = 0; i < 2; ++i) {
+      if (i > 0) {
+        b = 6 * y0 - 12 * y1 + 6 * y2;
+        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
+        c = 3 * y1 - 3 * y0;
       }
-      else if (source instanceof Array) {
-        destination = [];
-        for (var i = 0, len = source.length; i < len; i++) {
-          destination[i] = extend({ }, source[i], deep);
+
+      if (abs(a) < 1e-12) {
+        if (abs(b) < 1e-12) {
+          continue;
         }
-      }
-      else if (source && typeof source === 'object') {
-        for (var property in source) {
-          if (property === 'canvas' || property === 'group') {
-            // we do not want to clone this props at all.
-            // we want to keep the keys in the copy
-            destination[property] = null;
-          }
-          else if (source.hasOwnProperty(property)) {
-            destination[property] = extend({ }, source[property], deep);
-          }
+        t = -c / b;
+        if (0 < t && t < 1) {
+          tvalues.push(t);
         }
+        continue;
       }
-      else {
-        // this sounds odd for an extend but is ok for recursive use
-        destination = source;
+      b2ac = b * b - 4 * c * a;
+      if (b2ac < 0) {
+        continue;
       }
-    }
-    else {
-      for (var property in source) {
-        destination[property] = source[property];
+      sqrtb2ac = sqrt(b2ac);
+      t1 = (-b + sqrtb2ac) / (2 * a);
+      if (0 < t1 && t1 < 1) {
+        tvalues.push(t1);
       }
-    }
-    return destination;
-  }
-
-  /**
-   * Creates an empty object and copies all enumerable properties of another object to it
-   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. 
-   * @memberOf fabric.util.object
-   * @param {Object} object Object to clone
-   * @param {Boolean} [deep] Whether to clone nested objects
-   * @return {Object}
-   */
-
-  //TODO: this function return an empty object if you try to clone null
-  function clone(object, deep) {
-    return extend({ }, object, deep);
-  }
-
-  /** @namespace fabric.util.object */
-  fabric.util.object = {
-    extend: extend,
-    clone: clone
-  };
-  fabric.util.object.extend(fabric.util, fabric.Observable);
-})();
-
-
-(function() {
-
-  /**
-   * Camelizes a string
-   * @memberOf fabric.util.string
-   * @param {String} string String to camelize
-   * @return {String} Camelized version of a string
-   */
-  function camelize(string) {
-    return string.replace(/-+(.)?/g, function(match, character) {
-      return character ? character.toUpperCase() : '';
-    });
-  }
-
-  /**
-   * Capitalizes a string
-   * @memberOf fabric.util.string
-   * @param {String} string String to capitalize
-   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
-   * and other letters stay untouched, if false first letter is capitalized
-   * and other letters are converted to lowercase.
-   * @return {String} Capitalized version of a string
-   */
-  function capitalize(string, firstLetterOnly) {
-    return string.charAt(0).toUpperCase() +
-      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
-  }
-
-  /**
-   * Escapes XML in a string
-   * @memberOf fabric.util.string
-   * @param {String} string String to escape
-   * @return {String} Escaped version of a string
-   */
-  function escapeXml(string) {
-    return string.replace(/&/g, '&amp;')
-      .replace(/"/g, '&quot;')
-      .replace(/'/g, '&apos;')
-      .replace(/</g, '&lt;')
-      .replace(/>/g, '&gt;');
-  }
-
-  /**
-   * Divide a string in the user perceived single units
-   * @memberOf fabric.util.string
-   * @param {String} textstring String to escape
-   * @return {Array} array containing the graphemes
-   */
-  function graphemeSplit(textstring) {
-    var i = 0, chr, graphemes = [];
-    for (i = 0, chr; i < textstring.length; i++) {
-      if ((chr = getWholeChar(textstring, i)) === false) {
-        continue;
+      t2 = (-b - sqrtb2ac) / (2 * a);
+      if (0 < t2 && t2 < 1) {
+        tvalues.push(t2);
       }
-      graphemes.push(chr);
     }
-    return graphemes;
-  }
 
-  // taken from mdn in the charAt doc page.
-  function getWholeChar(str, i) {
-    var code = str.charCodeAt(i);
+    var x, y, j = tvalues.length, jlen = j, mt;
+    while (j--) {
+      t = tvalues[j];
+      mt = 1 - t;
+      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
+      bounds[0][j] = x;
 
-    if (isNaN(code)) {
-      return ''; // Position not found
-    }
-    if (code < 0xD800 || code > 0xDFFF) {
-      return str.charAt(i);
+      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
+      bounds[1][j] = y;
     }
 
-    // High surrogate (could change last hex to 0xDB7F to treat high private
-    // surrogates as single characters)
-    if (0xD800 <= code && code <= 0xDBFF) {
-      if (str.length <= (i + 1)) {
-        throw 'High surrogate without following low surrogate';
-      }
-      var next = str.charCodeAt(i + 1);
-      if (0xDC00 > next || next > 0xDFFF) {
-        throw 'High surrogate without following low surrogate';
+    bounds[0][jlen] = x0;
+    bounds[1][jlen] = y0;
+    bounds[0][jlen + 1] = x3;
+    bounds[1][jlen + 1] = y3;
+    var result = [
+      {
+        x: min.apply(null, bounds[0]),
+        y: min.apply(null, bounds[1])
+      },
+      {
+        x: max.apply(null, bounds[0]),
+        y: max.apply(null, bounds[1])
       }
-      return str.charAt(i) + str.charAt(i + 1);
-    }
-    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
-    if (i === 0) {
-      throw 'Low surrogate without preceding high surrogate';
-    }
-    var prev = str.charCodeAt(i - 1);
-
-    // (could change last hex to 0xDB7F to treat high private
-    // surrogates as single characters)
-    if (0xD800 > prev || prev > 0xDBFF) {
-      throw 'Low surrogate without preceding high surrogate';
+    ];
+    if (fabric.cachesBoundsOfCurve) {
+      fabric.boundsOfCurveCache[argsString] = result;
     }
-    // We can pass over low surrogates now as the second component
-    // in a pair which we have already processed
-    return false;
+    return result;
   }
 
-
   /**
-   * String utilities
-   * @namespace fabric.util.string
+   * Converts arc to a bunch of bezier curves
+   * @param {Number} fx starting point x
+   * @param {Number} fy starting point y
+   * @param {Array} coords Arc command
    */
-  fabric.util.string = {
-    camelize: camelize,
-    capitalize: capitalize,
-    escapeXml: escapeXml,
-    graphemeSplit: graphemeSplit
-  };
-})();
-
-
-(function() {
+  function fromArcToBeziers(fx, fy, coords) {
+    var rx = coords[1],
+        ry = coords[2],
+        rot = coords[3],
+        large = coords[4],
+        sweep = coords[5],
+        tx = coords[6],
+        ty = coords[7],
+        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
 
-  var slice = Array.prototype.slice, emptyFunction = function() { },
+    for (var i = 0, len = segsNorm.length; i < len; i++) {
+      segsNorm[i][1] += fx;
+      segsNorm[i][2] += fy;
+      segsNorm[i][3] += fx;
+      segsNorm[i][4] += fy;
+      segsNorm[i][5] += fx;
+      segsNorm[i][6] += fy;
+    }
+    return segsNorm;
+  };
 
-      IS_DONTENUM_BUGGY = (function() {
-        for (var p in { toString: 1 }) {
-          if (p === 'toString') {
-            return false;
-          }
-        }
-        return true;
-      })(),
-
-      /** @ignore */
-      addMethods = function(klass, source, parent) {
-        for (var property in source) {
-
-          if (property in klass.prototype &&
-              typeof klass.prototype[property] === 'function' &&
-              (source[property] + '').indexOf('callSuper') > -1) {
-
-            klass.prototype[property] = (function(property) {
-              return function() {
-
-                var superclass = this.constructor.superclass;
-                this.constructor.superclass = parent;
-                var returnValue = source[property].apply(this, arguments);
-                this.constructor.superclass = superclass;
-
-                if (property !== 'initialize') {
-                  return returnValue;
-                }
-              };
-            })(property);
+  /**
+   * This function take a parsed SVG path and make it simpler for fabricJS logic.
+   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )
+   * S converted in C, T converted in Q, A converted in C.
+   * @param {Array} path the array of commands of a parsed svg path for fabric.Path
+   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path
+   */
+  function makePathSimpler(path) {
+    // x and y represent the last point of the path. the previous command point.
+    // we add them to each relative command to make it an absolute comment.
+    // we also swap the v V h H with L, because are easier to transform.
+    var x = 0, y = 0, len = path.length,
+        // x1 and y1 represent the last point of the subpath. the subpath is started with
+        // m or M command. When a z or Z command is drawn, x and y need to be resetted to
+        // the last x1 and y1.
+        x1 = 0, y1 = 0, current, i, converted,
+        // previous will host the letter of the previous command, to handle S and T.
+        // controlX and controlY will host the previous reflected control point
+        destinationPath = [], previous, controlX, controlY;
+    for (i = 0; i < len; ++i) {
+      converted = false;
+      current = path[i].slice(0);
+      switch (current[0]) { // first letter
+        case 'l': // lineto, relative
+          current[0] = 'L';
+          current[1] += x;
+          current[2] += y;
+          // falls through
+        case 'L':
+          x = current[1];
+          y = current[2];
+          break;
+        case 'h': // horizontal lineto, relative
+          current[1] += x;
+          // falls through
+        case 'H':
+          current[0] = 'L';
+          current[2] = y;
+          x = current[1];
+          break;
+        case 'v': // vertical lineto, relative
+          current[1] += y;
+          // falls through
+        case 'V':
+          current[0] = 'L';
+          y = current[1];
+          current[1] = x;
+          current[2] = y;
+          break;
+        case 'm': // moveTo, relative
+          current[0] = 'M';
+          current[1] += x;
+          current[2] += y;
+          // falls through
+        case 'M':
+          x = current[1];
+          y = current[2];
+          x1 = current[1];
+          y1 = current[2];
+          break;
+        case 'c': // bezierCurveTo, relative
+          current[0] = 'C';
+          current[1] += x;
+          current[2] += y;
+          current[3] += x;
+          current[4] += y;
+          current[5] += x;
+          current[6] += y;
+          // falls through
+        case 'C':
+          controlX = current[3];
+          controlY = current[4];
+          x = current[5];
+          y = current[6];
+          break;
+        case 's': // shorthand cubic bezierCurveTo, relative
+          current[0] = 'S';
+          current[1] += x;
+          current[2] += y;
+          current[3] += x;
+          current[4] += y;
+          // falls through
+        case 'S':
+          // would be sScC but since we are swapping sSc for C, we check just that.
+          if (previous === 'C') {
+            // calculate reflection of previous control points
+            controlX = 2 * x - controlX;
+            controlY = 2 * y - controlY;
           }
           else {
-            klass.prototype[property] = source[property];
+            // If there is no previous command or if the previous command was not a C, c, S, or s,
+            // the control point is coincident with the current point
+            controlX = x;
+            controlY = y;
           }
-
-          if (IS_DONTENUM_BUGGY) {
-            if (source.toString !== Object.prototype.toString) {
-              klass.prototype.toString = source.toString;
-            }
-            if (source.valueOf !== Object.prototype.valueOf) {
-              klass.prototype.valueOf = source.valueOf;
-            }
+          x = current[3];
+          y = current[4];
+          current[0] = 'C';
+          current[5] = current[3];
+          current[6] = current[4];
+          current[3] = current[1];
+          current[4] = current[2];
+          current[1] = controlX;
+          current[2] = controlY;
+          // current[3] and current[4] are NOW the second control point.
+          // we keep it for the next reflection.
+          controlX = current[3];
+          controlY = current[4];
+          break;
+        case 'q': // quadraticCurveTo, relative
+          current[0] = 'Q';
+          current[1] += x;
+          current[2] += y;
+          current[3] += x;
+          current[4] += y;
+          // falls through
+        case 'Q':
+          controlX = current[1];
+          controlY = current[2];
+          x = current[3];
+          y = current[4];
+          break;
+        case 't': // shorthand quadraticCurveTo, relative
+          current[0] = 'T';
+          current[1] += x;
+          current[2] += y;
+          // falls through
+        case 'T':
+          if (previous === 'Q') {
+            // calculate reflection of previous control point
+            controlX = 2 * x - controlX;
+            controlY = 2 * y - controlY;
           }
-        }
-      };
-
-  function Subclass() { }
-
-  function callSuper(methodName) {
-    var parentMethod = null,
-        _this = this;
-
-    // climb prototype chain to find method not equal to callee's method
-    while (_this.constructor.superclass) {
-      var superClassMethod = _this.constructor.superclass.prototype[methodName];
-      if (_this[methodName] !== superClassMethod) {
-        parentMethod = superClassMethod;
-        break;
+          else {
+            // If there is no previous command or if the previous command was not a Q, q, T or t,
+            // assume the control point is coincident with the current point
+            controlX = x;
+            controlY = y;
+          }
+          current[0] = 'Q';
+          x = current[1];
+          y = current[2];
+          current[1] = controlX;
+          current[2] = controlY;
+          current[3] = x;
+          current[4] = y;
+          break;
+        case 'a':
+          current[0] = 'A';
+          current[6] += x;
+          current[7] += y;
+          // falls through
+        case 'A':
+          converted = true;
+          destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
+          x = current[6];
+          y = current[7];
+          break;
+        case 'z':
+        case 'Z':
+          x = x1;
+          y = y1;
+          break;
+        default:
       }
-      // eslint-disable-next-line
-      _this = _this.constructor.superclass.prototype;
-    }
-
-    if (!parentMethod) {
-      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
+      if (!converted) {
+        destinationPath.push(current);
+      }
+      previous = current[0];
     }
-
-    return (arguments.length > 1)
-      ? parentMethod.apply(this, slice.call(arguments, 1))
-      : parentMethod.call(this);
-  }
+    return destinationPath;
+  };
 
   /**
-   * Helper for creation of "classes".
-   * @memberOf fabric.util
-   * @param {Function} [parent] optional "Class" to inherit from
-   * @param {Object} [properties] Properties shared by all instances of this class
-   *                  (be careful modifying objects defined here as this would affect all instances)
+   * Calc length from point x1,y1 to x2,y2
+   * @param {Number} x1 starting point x
+   * @param {Number} y1 starting point y
+   * @param {Number} x2 starting point x
+   * @param {Number} y2 starting point y
+   * @return {Number} length of segment
    */
-  function createClass() {
-    var parent = null,
-        properties = slice.call(arguments, 0);
-
-    if (typeof properties[0] === 'function') {
-      parent = properties.shift();
-    }
-    function klass() {
-      this.initialize.apply(this, arguments);
-    }
-
-    klass.superclass = parent;
-    klass.subclasses = [];
+  function calcLineLength(x1, y1, x2, y2) {
+    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
+  }
 
-    if (parent) {
-      Subclass.prototype = parent.prototype;
-      klass.prototype = new Subclass();
-      parent.subclasses.push(klass);
-    }
-    for (var i = 0, length = properties.length; i < length; i++) {
-      addMethods(klass, properties[i], parent);
-    }
-    if (!klass.prototype.initialize) {
-      klass.prototype.initialize = emptyFunction;
-    }
-    klass.prototype.constructor = klass;
-    klass.prototype.callSuper = callSuper;
-    return klass;
+  // functions for the Cubic beizer
+  // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350
+  function CB1(t) {
+    return t * t * t;
   }
-
-  fabric.util.createClass = createClass;
-})();
-
-
-(function () {
-  // since ie11 can use addEventListener but they do not support options, i need to check
-  var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent,
-      touchEvents = ['touchstart', 'touchmove', 'touchend'];
-  /**
-   * Adds an event listener to an element
-   * @function
-   * @memberOf fabric.util
-   * @param {HTMLElement} element
-   * @param {String} eventName
-   * @param {Function} handler
-   */
-  fabric.util.addListener = function(element, eventName, handler, options) {
-    element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
-  };
-
-  /**
-   * Removes an event listener from an element
-   * @function
-   * @memberOf fabric.util
-   * @param {HTMLElement} element
-   * @param {String} eventName
-   * @param {Function} handler
-   */
-  fabric.util.removeListener = function(element, eventName, handler, options) {
-    element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
-  };
-
-  function getTouchInfo(event) {
-    var touchProp = event.changedTouches;
-    if (touchProp && touchProp[0]) {
-      return touchProp[0];
-    }
-    return event;
+  function CB2(t) {
+    return 3 * t * t * (1 - t);
   }
-
-  fabric.util.getPointer = function(event) {
-    var element = event.target,
-        scroll = fabric.util.getScrollLeftTop(element),
-        _evt = getTouchInfo(event);
-    return {
-      x: _evt.clientX + scroll.left,
-      y: _evt.clientY + scroll.top
-    };
-  };
-
-  fabric.util.isTouchEvent = function(event) {
-    return touchEvents.indexOf(event.type) > -1 || event.pointerType === 'touch';
-  };
-})();
-
-
-(function () {
-
-  /**
-   * Cross-browser wrapper for setting element's style
-   * @memberOf fabric.util
-   * @param {HTMLElement} element
-   * @param {Object} styles
-   * @return {HTMLElement} Element that was passed as a first argument
-   */
-  function setStyle(element, styles) {
-    var elementStyle = element.style;
-    if (!elementStyle) {
-      return element;
-    }
-    if (typeof styles === 'string') {
-      element.style.cssText += ';' + styles;
-      return styles.indexOf('opacity') > -1
-        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
-        : element;
-    }
-    for (var property in styles) {
-      if (property === 'opacity') {
-        setOpacity(element, styles[property]);
-      }
-      else {
-        var normalizedProperty = (property === 'float' || property === 'cssFloat')
-          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
-          : property;
-        elementStyle[normalizedProperty] = styles[property];
-      }
-    }
-    return element;
+  function CB3(t) {
+    return 3 * t * (1 - t) * (1 - t);
+  }
+  function CB4(t) {
+    return (1 - t) * (1 - t) * (1 - t);
   }
 
-  var parseEl = fabric.document.createElement('div'),
-      supportsOpacity = typeof parseEl.style.opacity === 'string',
-      supportsFilters = typeof parseEl.style.filter === 'string',
-      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
-
-      /** @ignore */
-      setOpacity = function (element) { return element; };
-
-  if (supportsOpacity) {
-    /** @ignore */
-    setOpacity = function(element, value) {
-      element.style.opacity = value;
-      return element;
+  function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
+    return function(pct) {
+      var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
+      return {
+        x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
+        y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
+      };
     };
   }
-  else if (supportsFilters) {
-    /** @ignore */
-    setOpacity = function(element, value) {
-      var es = element.style;
-      if (element.currentStyle && !element.currentStyle.hasLayout) {
-        es.zoom = 1;
-      }
-      if (reOpacity.test(es.filter)) {
-        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
-        es.filter = es.filter.replace(reOpacity, value);
-      }
-      else {
-        es.filter += ' alpha(opacity=' + (value * 100) + ')';
-      }
-      return element;
+
+  function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
+    return function (pct) {
+      var invT = 1 - pct,
+          tangentX = (3 * invT * invT * (p2x - p1x)) + (6 * invT * pct * (p3x - p2x)) +
+          (3 * pct * pct * (p4x - p3x)),
+          tangentY = (3 * invT * invT * (p2y - p1y)) + (6 * invT * pct * (p3y - p2y)) +
+          (3 * pct * pct * (p4y - p3y));
+      return Math.atan2(tangentY, tangentX);
     };
   }
 
-  fabric.util.setStyle = setStyle;
-
-})();
-
-
-(function() {
+  function QB1(t) {
+    return t * t;
+  }
 
-  var _slice = Array.prototype.slice;
+  function QB2(t) {
+    return 2 * t * (1 - t);
+  }
 
-  /**
-   * Takes id and returns an element with that id (if one exists in a document)
-   * @memberOf fabric.util
-   * @param {String|HTMLElement} id
-   * @return {HTMLElement|null}
-   */
-  function getById(id) {
-    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
+  function QB3(t) {
+    return (1 - t) * (1 - t);
   }
 
-  var sliceCanConvertNodelists,
-      /**
-       * Converts an array-like object (e.g. arguments or NodeList) to an array
-       * @memberOf fabric.util
-       * @param {Object} arrayLike
-       * @return {Array}
-       */
-      toArray = function(arrayLike) {
-        return _slice.call(arrayLike, 0);
+  function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
+    return function(pct) {
+      var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
+      return {
+        x: p3x * c1 + p2x * c2 + p1x * c3,
+        y: p3y * c1 + p2y * c2 + p1y * c3
       };
-
-  try {
-    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
+    };
   }
-  catch (err) { }
 
-  if (!sliceCanConvertNodelists) {
-    toArray = function(arrayLike) {
-      var arr = new Array(arrayLike.length), i = arrayLike.length;
-      while (i--) {
-        arr[i] = arrayLike[i];
-      }
-      return arr;
+  function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
+    return function (pct) {
+      var invT = 1 - pct,
+          tangentX = (2 * invT * (p2x - p1x)) + (2 * pct * (p3x - p2x)),
+          tangentY = (2 * invT * (p2y - p1y)) + (2 * pct * (p3y - p2y));
+      return Math.atan2(tangentY, tangentX);
     };
   }
 
-  /**
-   * Creates specified element with specified attributes
-   * @memberOf fabric.util
-   * @param {String} tagName Type of an element to create
-   * @param {Object} [attributes] Attributes to set on an element
-   * @return {HTMLElement} Newly created element
-   */
-  function makeElement(tagName, attributes) {
-    var el = fabric.document.createElement(tagName);
-    for (var prop in attributes) {
-      if (prop === 'class') {
-        el.className = attributes[prop];
-      }
-      else if (prop === 'for') {
-        el.htmlFor = attributes[prop];
-      }
-      else {
-        el.setAttribute(prop, attributes[prop]);
-      }
-    }
-    return el;
-  }
 
-  /**
-   * Adds class to an element
-   * @memberOf fabric.util
-   * @param {HTMLElement} element Element to add class to
-   * @param {String} className Class to add to an element
-   */
-  function addClass(element, className) {
-    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
-      element.className += (element.className ? ' ' : '') + className;
+  // this will run over a path segment ( a cubic or quadratic segment) and approximate it
+  // with 100 segemnts. This will good enough to calculate the length of the curve
+  function pathIterator(iterator, x1, y1) {
+    var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
+    for (perc = 1; perc <= 100; perc += 1) {
+      p = iterator(perc / 100);
+      tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
+      tempP = p;
     }
+    return tmpLen;
   }
 
   /**
-   * Wraps element with another element
-   * @memberOf fabric.util
-   * @param {HTMLElement} element Element to wrap
-   * @param {HTMLElement|String} wrapper Element to wrap with
-   * @param {Object} [attributes] Attributes to set on a wrapper
-   * @return {HTMLElement} wrapper
-   */
-  function wrapElement(element, wrapper, attributes) {
-    if (typeof wrapper === 'string') {
-      wrapper = makeElement(wrapper, attributes);
-    }
-    if (element.parentNode) {
-      element.parentNode.replaceChild(wrapper, element);
-    }
-    wrapper.appendChild(element);
-    return wrapper;
-  }
-
-  /**
-   * Returns element scroll offsets
-   * @memberOf fabric.util
-   * @param {HTMLElement} element Element to operate on
-   * @return {Object} Object with left/top values
+   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1
+   * that correspond to that pixels run over the path.
+   * The percentage will be then used to find the correct point on the canvas for the path.
+   * @param {Array} segInfo fabricJS collection of information on a parsed path
+   * @param {Number} distance from starting point, in pixels.
+   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;
    */
-  function getScrollLeftTop(element) {
-
-    var left = 0,
-        top = 0,
-        docElement = fabric.document.documentElement,
-        body = fabric.document.body || {
-          scrollLeft: 0, scrollTop: 0
-        };
-
-    // While loop checks (and then sets element to) .parentNode OR .host
-    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
-    //  but the .parentNode of a root ShadowDOM node will always be null, instead
-    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
-    while (element && (element.parentNode || element.host)) {
-
-      // Set element to element parent, or 'host' in case of ShadowDOM
-      element = element.parentNode || element.host;
-
-      if (element === fabric.document) {
-        left = body.scrollLeft || docElement.scrollLeft || 0;
-        top = body.scrollTop ||  docElement.scrollTop || 0;
+  function findPercentageForDistance(segInfo, distance) {
+    var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y },
+        p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
+    // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
+    // the path
+    while (tmpLen < distance && perc <= 1 && nextStep > 0.0001) {
+      p = iterator(perc);
+      lastPerc = perc;
+      nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
+      // compare tmpLen each cycle with distance, decide next perc to test.
+      if ((nextLen + tmpLen) > distance) {
+        // we discard this step and we make smaller steps.
+        nextStep /= 2;
+        perc -= nextStep;
       }
       else {
-        left += element.scrollLeft || 0;
-        top += element.scrollTop || 0;
-      }
-
-      if (element.nodeType === 1 && element.style.position === 'fixed') {
-        break;
+        tempP = p;
+        perc += nextStep;
+        tmpLen += nextLen;
       }
     }
-
-    return { left: left, top: top };
+    p.angle = angleFinder(lastPerc);
+    return p;
   }
 
   /**
-   * Returns offset for a given element
-   * @function
-   * @memberOf fabric.util
-   * @param {HTMLElement} element Element to get offset for
-   * @return {Object} Object with "left" and "top" properties
+   * Run over a parsed and simplifed path and extrac some informations.
+   * informations are length of each command and starting point
+   * @param {Array} path fabricJS parsed path commands
+   * @return {Array} path commands informations
    */
-  function getElementOffset(element) {
-    var docElem,
-        doc = element && element.ownerDocument,
-        box = { left: 0, top: 0 },
-        offset = { left: 0, top: 0 },
-        scrollLeftTop,
-        offsetAttributes = {
-          borderLeftWidth: 'left',
-          borderTopWidth:  'top',
-          paddingLeft:     'left',
-          paddingTop:      'top'
-        };
-
-    if (!doc) {
-      return offset;
+  function getPathSegmentsInfo(path) {
+    var totalLength = 0, len = path.length, current,
+        //x2 and y2 are the coords of segment start
+        //x1 and y1 are the coords of the current point
+        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
+    for (var i = 0; i < len; i++) {
+      current = path[i];
+      tempInfo = {
+        x: x1,
+        y: y1,
+        command: current[0],
+      };
+      switch (current[0]) { //first letter
+        case 'M':
+          tempInfo.length = 0;
+          x2 = x1 = current[1];
+          y2 = y1 = current[2];
+          break;
+        case 'L':
+          tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
+          x1 = current[1];
+          y1 = current[2];
+          break;
+        case 'C':
+          iterator = getPointOnCubicBezierIterator(
+            x1,
+            y1,
+            current[1],
+            current[2],
+            current[3],
+            current[4],
+            current[5],
+            current[6]
+          );
+          angleFinder = getTangentCubicIterator(
+            x1,
+            y1,
+            current[1],
+            current[2],
+            current[3],
+            current[4],
+            current[5],
+            current[6]
+          );
+          tempInfo.iterator = iterator;
+          tempInfo.angleFinder = angleFinder;
+          tempInfo.length = pathIterator(iterator, x1, y1);
+          x1 = current[5];
+          y1 = current[6];
+          break;
+        case 'Q':
+          iterator = getPointOnQuadraticBezierIterator(
+            x1,
+            y1,
+            current[1],
+            current[2],
+            current[3],
+            current[4]
+          );
+          angleFinder = getTangentQuadraticIterator(
+            x1,
+            y1,
+            current[1],
+            current[2],
+            current[3],
+            current[4]
+          );
+          tempInfo.iterator = iterator;
+          tempInfo.angleFinder = angleFinder;
+          tempInfo.length = pathIterator(iterator, x1, y1);
+          x1 = current[3];
+          y1 = current[4];
+          break;
+        case 'Z':
+        case 'z':
+          // we add those in order to ease calculations later
+          tempInfo.destX = x2;
+          tempInfo.destY = y2;
+          tempInfo.length = calcLineLength(x1, y1, x2, y2);
+          x1 = x2;
+          y1 = y2;
+          break;
+      }
+      totalLength += tempInfo.length;
+      info.push(tempInfo);
     }
+    info.push({ length: totalLength, x: x1, y: y1 });
+    return info;
+  }
 
-    for (var attr in offsetAttributes) {
-      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
+  function getPointOnPath(path, distance, infos) {
+    if (!infos) {
+      infos = getPathSegmentsInfo(path);
     }
-
-    docElem = doc.documentElement;
-    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
-      box = element.getBoundingClientRect();
+    var i = 0;
+    while ((distance - infos[i].length > 0) && i < (infos.length - 2)) {
+      distance -= infos[i].length;
+      i++;
     }
+    // var distance = infos[infos.length - 1] * perc;
+    var segInfo = infos[i], segPercent = distance / segInfo.length,
+        command = segInfo.command, segment = path[i], info;
 
-    scrollLeftTop = getScrollLeftTop(element);
-
-    return {
-      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
-      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
-    };
+    switch (command) {
+      case 'M':
+        return { x: segInfo.x, y: segInfo.y, angle: 0 };
+      case 'Z':
+      case 'z':
+        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
+          new fabric.Point(segInfo.destX, segInfo.destY),
+          segPercent
+        );
+        info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
+        return info;
+      case 'L':
+        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
+          new fabric.Point(segment[1], segment[2]),
+          segPercent
+        );
+        info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
+        return info;
+      case 'C':
+        return findPercentageForDistance(segInfo, distance);
+      case 'Q':
+        return findPercentageForDistance(segInfo, distance);
+    }
   }
 
   /**
-   * Returns style attribute value of a given element
-   * @memberOf fabric.util
-   * @param {HTMLElement} element Element to get style attribute for
-   * @param {String} attr Style attribute to get for element
-   * @return {String} Style attribute value of the given element.
+   *
+   * @param {string} pathString
+   * @return {(string|number)[][]} An array of SVG path commands
+   * @example <caption>Usage</caption>
+   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [
+   *   ['M', 3, 4],
+   *   ['Q', 3, 5, 2, 1, 4, 0],
+   *   ['Q', 9, 12, 2, 1, 4, 0],
+   * ];
+   *
    */
-  var getElementStyle;
-  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
-    getElementStyle = function(element, attr) {
-      var style = fabric.document.defaultView.getComputedStyle(element, null);
-      return style ? style[attr] : undefined;
-    };
-  }
-  else {
-    getElementStyle = function(element, attr) {
-      var value = element.style[attr];
-      if (!value && element.currentStyle) {
-        value = element.currentStyle[attr];
-      }
-      return value;
-    };
-  }
+  function parsePath(pathString) {
+    var result = [],
+        coords = [],
+        currentPath,
+        parsed,
+        re = fabric.rePathCommand,
+        rNumber = '[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*',
+        rNumberCommaWsp = '(' + rNumber + ')' + fabric.commaWsp,
+        rFlagCommaWsp = '([01])' + fabric.commaWsp + '?',
+        rArcSeq = rNumberCommaWsp + '?' + rNumberCommaWsp + '?' + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp +
+          rNumberCommaWsp + '?(' + rNumber + ')',
+        regArcArgumentSequence = new RegExp(rArcSeq, 'g'),
+        match,
+        coordsStr,
+        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
+        path;
+    if (!pathString || !pathString.match) {
+      return result;
+    }
+    path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
 
-  (function () {
-    var style = fabric.document.documentElement.style,
-        selectProp = 'userSelect' in style
-          ? 'userSelect'
-          : 'MozUserSelect' in style
-            ? 'MozUserSelect'
-            : 'WebkitUserSelect' in style
-              ? 'WebkitUserSelect'
-              : 'KhtmlUserSelect' in style
-                ? 'KhtmlUserSelect'
-                : '';
+    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
+      currentPath = path[i];
 
-    /**
-     * Makes element unselectable
-     * @memberOf fabric.util
-     * @param {HTMLElement} element Element to make unselectable
-     * @return {HTMLElement} Element that was passed in
-     */
-    function makeElementUnselectable(element) {
-      if (typeof element.onselectstart !== 'undefined') {
-        element.onselectstart = fabric.util.falseFunction;
-      }
-      if (selectProp) {
-        element.style[selectProp] = 'none';
+      coordsStr = currentPath.slice(1).trim();
+      coords.length = 0;
+
+      var command = currentPath.charAt(0);
+      coordsParsed = [command];
+
+      if (command.toLowerCase() === 'a') {
+        // arcs have special flags that apparently don't require spaces so handle special
+        for (var args; (args = regArcArgumentSequence.exec(coordsStr));) {
+          for (var j = 1; j < args.length; j++) {
+            coords.push(args[j]);
+          }
+        }
       }
-      else if (typeof element.unselectable === 'string') {
-        element.unselectable = 'on';
+      else {
+        while ((match = re.exec(coordsStr))) {
+          coords.push(match[0]);
+        }
       }
-      return element;
-    }
 
-    /**
-     * Makes element selectable
-     * @memberOf fabric.util
-     * @param {HTMLElement} element Element to make selectable
-     * @return {HTMLElement} Element that was passed in
-     */
-    function makeElementSelectable(element) {
-      if (typeof element.onselectstart !== 'undefined') {
-        element.onselectstart = null;
+      for (var j = 0, jlen = coords.length; j < jlen; j++) {
+        parsed = parseFloat(coords[j]);
+        if (!isNaN(parsed)) {
+          coordsParsed.push(parsed);
+        }
       }
-      if (selectProp) {
-        element.style[selectProp] = '';
+
+      var commandLength = commandLengths[command.toLowerCase()],
+          repeatedCommand = repeatedCommands[command] || command;
+
+      if (coordsParsed.length - 1 > commandLength) {
+        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
+          result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
+          command = repeatedCommand;
+        }
       }
-      else if (typeof element.unselectable === 'string') {
-        element.unselectable = '';
+      else {
+        result.push(coordsParsed);
       }
-      return element;
     }
 
-    fabric.util.makeElementUnselectable = makeElementUnselectable;
-    fabric.util.makeElementSelectable = makeElementSelectable;
-  })();
-
-  function getNodeCanvas(element) {
-    var impl = fabric.jsdomImplForWrapper(element);
-    return impl._canvas || impl._image;
+    return result;
   };
 
-  function cleanUpJsdomNode(element) {
-    if (!fabric.isLikelyNode) {
-      return;
+  /**
+   *
+   * Converts points to a smooth SVG path
+   * @param {{ x: number,y: number }[]} points Array of points
+   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.
+   * @return {(string|number)[][]} An array of SVG path commands
+   */
+  function getSmoothPathFromPoints(points, correction) {
+    var path = [], i,
+        p1 = new fabric.Point(points[0].x, points[0].y),
+        p2 = new fabric.Point(points[1].x, points[1].y),
+        len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;
+    correction = correction || 0;
+
+    if (manyPoints) {
+      multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
+      multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
     }
-    var impl = fabric.jsdomImplForWrapper(element);
-    if (impl) {
-      impl._image = null;
-      impl._canvas = null;
-      // unsure if necessary
-      impl._currentSrc = null;
-      impl._attributes = null;
-      impl._classList = null;
+    path.push(['M', p1.x - multSignX * correction, p1.y - multSignY * correction]);
+    for (i = 1; i < len; i++) {
+      if (!p1.eq(p2)) {
+        var midPoint = p1.midPointFrom(p2);
+        // p1 is our bezier control point
+        // midpoint is our endpoint
+        // start point is p(i-1) value.
+        path.push(['Q', p1.x, p1.y, midPoint.x, midPoint.y]);
+      }
+      p1 = points[i];
+      if ((i + 1) < points.length) {
+        p2 = points[i + 1];
+      }
+    }
+    if (manyPoints) {
+      multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
+      multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
     }
+    path.push(['L', p1.x + multSignX * correction, p1.y + multSignY * correction]);
+    return path;
   }
-
-  function setImageSmoothing(ctx, value) {
-    ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
-      || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
-    ctx.imageSmoothingEnabled = value;
+  /**
+   * Transform a path by transforming each segment.
+   * it has to be a simplified path or it won't work.
+   * WARNING: this depends from pathOffset for correct operation
+   * @param {Array} path fabricJS parsed and simplified path commands
+   * @param {Array} transform matrix that represent the transformation
+   * @param {Object} [pathOffset] the fabric.Path pathOffset
+   * @param {Number} pathOffset.x
+   * @param {Number} pathOffset.y
+   * @returns {Array} the transformed path
+   */
+  function transformPath(path, transform, pathOffset) {
+    if (pathOffset) {
+      transform = fabric.util.multiplyTransformMatrices(
+        transform,
+        [1, 0, 0, 1, -pathOffset.x, -pathOffset.y]
+      );
+    }
+    return path.map(function(pathSegment) {
+      var newSegment = pathSegment.slice(0), point = {};
+      for (var i = 1; i < pathSegment.length - 1; i += 2) {
+        point.x = pathSegment[i];
+        point.y = pathSegment[i + 1];
+        point = fabric.util.transformPoint(point, transform);
+        newSegment[i] = point.x;
+        newSegment[i + 1] = point.y;
+      }
+      return newSegment;
+    });
   }
 
   /**
-   * setImageSmoothing sets the context imageSmoothingEnabled property.
-   * Used by canvas and by ImageObject.
-   * @memberOf fabric.util
-   * @since 4.0.0
-   * @param {HTMLRenderingContext2D} ctx to set on
-   * @param {Boolean} value true or false
+   * Calculate bounding box of a elliptic-arc
+   * @deprecated
+   * @param {Number} fx start point of arc
+   * @param {Number} fy
+   * @param {Number} rx horizontal radius
+   * @param {Number} ry vertical radius
+   * @param {Number} rot angle of horizontal axis
+   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
+   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
+   * @param {Number} tx end point of arc
+   * @param {Number} ty
    */
-  fabric.util.setImageSmoothing = setImageSmoothing;
-  fabric.util.getById = getById;
-  fabric.util.toArray = toArray;
-  fabric.util.addClass = addClass;
-  fabric.util.makeElement = makeElement;
-  fabric.util.wrapElement = wrapElement;
-  fabric.util.getScrollLeftTop = getScrollLeftTop;
-  fabric.util.getElementOffset = getElementOffset;
-  fabric.util.getNodeCanvas = getNodeCanvas;
-  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;
-
-})();
-
-
-(function() {
+  function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
 
-  function addParamToUrl(url, param) {
-    return url + (/\?/.test(url) ? '&' : '?') + param;
-  }
+    var fromX = 0, fromY = 0, bound, bounds = [],
+        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
 
-  function emptyFn() { }
+    for (var i = 0, len = segs.length; i < len; i++) {
+      bound = getBoundsOfCurve(fromX, fromY, segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5], segs[i][6]);
+      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
+      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
+      fromX = segs[i][5];
+      fromY = segs[i][6];
+    }
+    return bounds;
+  };
 
   /**
-   * Cross-browser abstraction for sending XMLHttpRequest
-   * @memberOf fabric.util
-   * @param {String} url URL to send XMLHttpRequest to
-   * @param {Object} [options] Options object
-   * @param {String} [options.method="GET"]
-   * @param {String} [options.parameters] parameters to append to url in GET or in body
-   * @param {String} [options.body] body to send with POST or PUT request
-   * @param {Function} options.onComplete Callback to invoke when request is completed
-   * @return {XMLHttpRequest} request
+   * Draws arc
+   * @deprecated
+   * @param {CanvasRenderingContext2D} ctx
+   * @param {Number} fx
+   * @param {Number} fy
+   * @param {Array} coords coords of the arc, without the front 'A/a'
    */
-  function request(url, options) {
-    options || (options = { });
-
-    var method = options.method ? options.method.toUpperCase() : 'GET',
-        onComplete = options.onComplete || function() { },
-        xhr = new fabric.window.XMLHttpRequest(),
-        body = options.body || options.parameters;
-
-    /** @ignore */
-    xhr.onreadystatechange = function() {
-      if (xhr.readyState === 4) {
-        onComplete(xhr);
-        xhr.onreadystatechange = emptyFn;
-      }
-    };
-
-    if (method === 'GET') {
-      body = null;
-      if (typeof options.parameters === 'string') {
-        url = addParamToUrl(url, options.parameters);
-      }
-    }
-
-    xhr.open(method, url, true);
-
-    if (method === 'POST' || method === 'PUT') {
-      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
-    }
-
-    xhr.send(body);
-    return xhr;
-  }
+  function drawArc(ctx, fx, fy, coords) {
+    coords = coords.slice(0).unshift('X'); // command A or a does not matter
+    var beziers = fromArcToBeziers(fx, fy, coords);
+    beziers.forEach(function(bezier) {
+      ctx.bezierCurveTo.apply(ctx, bezier.slice(1));
+    });
+  };
 
-  fabric.util.request = request;
+  /**
+   * Join path commands to go back to svg format
+   * @param {Array} pathData fabricJS parsed path commands
+   * @return {String} joined path 'M 0 0 L 20 30'
+   */
+  fabric.util.joinPath = function(pathData) {
+    return pathData.map(function (segment) { return segment.join(' '); }).join(' ');
+  };
+  fabric.util.parsePath = parsePath;
+  fabric.util.makePathSimpler = makePathSimpler;
+  fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;
+  fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
+  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
+  fabric.util.getPointOnPath = getPointOnPath;
+  fabric.util.transformPath = transformPath;
+  /**
+   * Typo of `fromArcToBeziers` kept for not breaking the api once corrected.
+   * Will be removed in fabric 5.0
+   * @deprecated
+   */
+  fabric.util.fromArcToBeizers = fromArcToBeziers;
+  // kept because we do not want to make breaking changes.
+  // but useless and deprecated.
+  fabric.util.getBoundsOfArc = getBoundsOfArc;
+  fabric.util.drawArc = drawArc;
 })();
 
 
-/**
- * Wrapper around `console.log` (when available)
- * @param {*} [values] Values to log
- */
-fabric.log = console.log;
-
-/**
- * Wrapper around `console.warn` (when available)
- * @param {*} [values] Values to log as a warning
- */
-fabric.warn = console.warn;
-
-
 (function() {
 
-  function noop() {
-    return false;
+  var slice = Array.prototype.slice;
+
+  /**
+   * Invokes method on all items in a given array
+   * @memberOf fabric.util.array
+   * @param {Array} array Array to iterate over
+   * @param {String} method Name of a method to invoke
+   * @return {Array}
+   */
+  function invoke(array, method) {
+    var args = slice.call(arguments, 2), result = [];
+    for (var i = 0, len = array.length; i < len; i++) {
+      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
+    }
+    return result;
   }
 
-  function defaultEasing(t, b, c, d) {
-    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
+  /**
+   * Finds maximum value in array (not necessarily "first" one)
+   * @memberOf fabric.util.array
+   * @param {Array} array Array to iterate over
+   * @param {String} byProperty
+   * @return {*}
+   */
+  function max(array, byProperty) {
+    return find(array, byProperty, function(value1, value2) {
+      return value1 >= value2;
+    });
   }
 
   /**
-   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
-   * @memberOf fabric.util
-   * @param {Object} [options] Animation options
-   * @param {Function} [options.onChange] Callback; invoked on every value change
-   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
-   * @param {Number} [options.startValue=0] Starting value
-   * @param {Number} [options.endValue=100] Ending value
-   * @param {Number} [options.byValue=100] Value to modify the property by
-   * @param {Function} [options.easing] Easing function
-   * @param {Number} [options.duration=500] Duration of change (in ms)
-   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
-   * @returns {Function} abort function
+   * Finds minimum value in array (not necessarily "first" one)
+   * @memberOf fabric.util.array
+   * @param {Array} array Array to iterate over
+   * @param {String} byProperty
+   * @return {*}
    */
-  function animate(options) {
-    var cancel = false;
-    requestAnimFrame(function(timestamp) {
-      options || (options = { });
+  function min(array, byProperty) {
+    return find(array, byProperty, function(value1, value2) {
+      return value1 < value2;
+    });
+  }
 
-      var start = timestamp || +new Date(),
-          duration = options.duration || 500,
-          finish = start + duration, time,
-          onChange = options.onChange || noop,
-          abort = options.abort || noop,
-          onComplete = options.onComplete || noop,
-          easing = options.easing || defaultEasing,
-          startValue = 'startValue' in options ? options.startValue : 0,
-          endValue = 'endValue' in options ? options.endValue : 100,
-          byValue = options.byValue || endValue - startValue;
+  /**
+   * @private
+   */
+  function fill(array, value) {
+    var k = array.length;
+    while (k--) {
+      array[k] = value;
+    }
+    return array;
+  }
 
-      options.onStart && options.onStart();
+  /**
+   * @private
+   */
+  function find(array, byProperty, condition) {
+    if (!array || array.length === 0) {
+      return;
+    }
 
-      (function tick(ticktime) {
-        // TODO: move abort call after calculation
-        // and pass (current,valuePerc, timePerc) as arguments
-        time = ticktime || +new Date();
-        var currentTime = time > finish ? duration : (time - start),
-            timePerc = currentTime / duration,
-            current = easing(currentTime, startValue, byValue, duration),
-            valuePerc = Math.abs((current - startValue) / byValue);
-        if (cancel) {
-          return;
-        }
-        if (abort(current, valuePerc, timePerc)) {
-          // remove this in 4.0
-          // does to even make sense to abort and run onComplete?
-          onComplete(endValue, 1, 1);
-          return;
-        }
-        if (time > finish) {
-          onChange(endValue, 1, 1);
-          onComplete(endValue, 1, 1);
-          return;
+    var i = array.length - 1,
+        result = byProperty ? array[i][byProperty] : array[i];
+    if (byProperty) {
+      while (i--) {
+        if (condition(array[i][byProperty], result)) {
+          result = array[i][byProperty];
         }
-        else {
-          onChange(current, valuePerc, timePerc);
-          requestAnimFrame(tick);
+      }
+    }
+    else {
+      while (i--) {
+        if (condition(array[i], result)) {
+          result = array[i];
         }
-      })(start);
-    });
-    return function() {
-      cancel = true;
-    };
+      }
+    }
+    return result;
   }
 
-  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
-                          fabric.window.webkitRequestAnimationFrame ||
-                          fabric.window.mozRequestAnimationFrame    ||
-                          fabric.window.oRequestAnimationFrame      ||
-                          fabric.window.msRequestAnimationFrame     ||
-                          function(callback) {
-                            return fabric.window.setTimeout(callback, 1000 / 60);
-                          };
-
-  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;
-
   /**
-   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
-   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
-   * @memberOf fabric.util
-   * @param {Function} callback Callback to invoke
-   * @param {DOMElement} element optional Element to associate with animation
+   * @namespace fabric.util.array
    */
-  function requestAnimFrame() {
-    return _requestAnimFrame.apply(fabric.window, arguments);
-  }
-
-  function cancelAnimFrame() {
-    return _cancelAnimFrame.apply(fabric.window, arguments);
-  }
+  fabric.util.array = {
+    fill: fill,
+    invoke: invoke,
+    min: min,
+    max: max
+  };
 
-  fabric.util.animate = animate;
-  fabric.util.requestAnimFrame = requestAnimFrame;
-  fabric.util.cancelAnimFrame = cancelAnimFrame;
 })();
 
 
 (function() {
-  // Calculate an in-between color. Returns a "rgba()" string.
-  // Credit: Edwin Martin <edwin@bitstorm.org>
-  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
-  function calculateColor(begin, end, pos) {
-    var color = 'rgba('
-        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
-        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
-        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);
-
-    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
-    color += ')';
-    return color;
-  }
-
   /**
-   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
-   * @memberOf fabric.util
-   * @param {String} fromColor The starting color in hex or rgb(a) format.
-   * @param {String} toColor The starting color in hex or rgb(a) format.
-   * @param {Number} [duration] Duration of change (in ms).
-   * @param {Object} [options] Animation options
-   * @param {Function} [options.onChange] Callback; invoked on every value change
-   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
-   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
-   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
-   * @returns {Function} abort function
+   * Copies all enumerable properties of one js object to another
+   * this does not and cannot compete with generic utils.
+   * Does not clone or extend fabric.Object subclasses.
+   * This is mostly for internal use and has extra handling for fabricJS objects
+   * it skips the canvas and group properties in deep cloning.
+   * @memberOf fabric.util.object
+   * @param {Object} destination Where to copy to
+   * @param {Object} source Where to copy from
+   * @param {Boolean} [deep] Whether to extend nested objects
+   * @return {Object}
    */
-  function animateColor(fromColor, toColor, duration, options) {
-    var startColor = new fabric.Color(fromColor).getSource(),
-        endColor = new fabric.Color(toColor).getSource(),
-        originalOnComplete = options.onComplete,
-        originalOnChange = options.onChange;
-    options = options || {};
 
-    return fabric.util.animate(fabric.util.object.extend(options, {
-      duration: duration || 500,
-      startValue: startColor,
-      endValue: endColor,
-      byValue: endColor,
-      easing: function (currentTime, startValue, byValue, duration) {
-        var posValue = options.colorEasing
-          ? options.colorEasing(currentTime, duration)
-          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
-        return calculateColor(startValue, byValue, posValue);
-      },
-      // has to take in account for color restoring;
-      onComplete: function(current, valuePerc, timePerc) {
-        if (originalOnComplete) {
-          return originalOnComplete(
-            calculateColor(endColor, endColor, 0),
-            valuePerc,
-            timePerc
-          );
+  function extend(destination, source, deep) {
+    // JScript DontEnum bug is not taken care of
+    // the deep clone is for internal use, is not meant to avoid
+    // javascript traps or cloning html element or self referenced objects.
+    if (deep) {
+      if (!fabric.isLikelyNode && source instanceof Element) {
+        // avoid cloning deep images, canvases,
+        destination = source;
+      }
+      else if (source instanceof Array) {
+        destination = [];
+        for (var i = 0, len = source.length; i < len; i++) {
+          destination[i] = extend({ }, source[i], deep);
         }
-      },
-      onChange: function(current, valuePerc, timePerc) {
-        if (originalOnChange) {
-          if (Array.isArray(current)) {
-            return originalOnChange(
-              calculateColor(current, current, 0),
-              valuePerc,
-              timePerc
-            );
+      }
+      else if (source && typeof source === 'object') {
+        for (var property in source) {
+          if (property === 'canvas' || property === 'group') {
+            // we do not want to clone this props at all.
+            // we want to keep the keys in the copy
+            destination[property] = null;
+          }
+          else if (source.hasOwnProperty(property)) {
+            destination[property] = extend({ }, source[property], deep);
           }
-          originalOnChange(current, valuePerc, timePerc);
         }
       }
-    }));
-  }
-
-  fabric.util.animateColor = animateColor;
-
-})();
-
-
-(function() {
-
-  function normalize(a, c, p, s) {
-    if (a < Math.abs(c)) {
-      a = c;
-      s = p / 4;
+      else {
+        // this sounds odd for an extend but is ok for recursive use
+        destination = source;
+      }
     }
     else {
-      //handle the 0/0 case:
-      if (c === 0 && a === 0) {
-        s = p / (2 * Math.PI) * Math.asin(1);
-      }
-      else {
-        s = p / (2 * Math.PI) * Math.asin(c / a);
+      for (var property in source) {
+        destination[property] = source[property];
       }
     }
-    return { a: a, c: c, p: p, s: s };
-  }
-
-  function elastic(opts, t, d) {
-    return opts.a *
-      Math.pow(2, 10 * (t -= 1)) *
-      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
+    return destination;
   }
 
   /**
-   * Cubic easing out
-   * @memberOf fabric.util.ease
+   * Creates an empty object and copies all enumerable properties of another object to it
+   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. 
+   * @memberOf fabric.util.object
+   * @param {Object} object Object to clone
+   * @param {Boolean} [deep] Whether to clone nested objects
+   * @return {Object}
    */
-  function easeOutCubic(t, b, c, d) {
-    return c * ((t = t / d - 1) * t * t + 1) + b;
+
+  //TODO: this function return an empty object if you try to clone null
+  function clone(object, deep) {
+    return extend({ }, object, deep);
   }
 
+  /** @namespace fabric.util.object */
+  fabric.util.object = {
+    extend: extend,
+    clone: clone
+  };
+  fabric.util.object.extend(fabric.util, fabric.Observable);
+})();
+
+
+(function() {
+
   /**
-   * Cubic easing in and out
-   * @memberOf fabric.util.ease
+   * Camelizes a string
+   * @memberOf fabric.util.string
+   * @param {String} string String to camelize
+   * @return {String} Camelized version of a string
    */
-  function easeInOutCubic(t, b, c, d) {
-    t /= d / 2;
-    if (t < 1) {
-      return c / 2 * t * t * t + b;
-    }
-    return c / 2 * ((t -= 2) * t * t + 2) + b;
+  function camelize(string) {
+    return string.replace(/-+(.)?/g, function(match, character) {
+      return character ? character.toUpperCase() : '';
+    });
   }
 
   /**
-   * Quartic easing in
-   * @memberOf fabric.util.ease
+   * Capitalizes a string
+   * @memberOf fabric.util.string
+   * @param {String} string String to capitalize
+   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
+   * and other letters stay untouched, if false first letter is capitalized
+   * and other letters are converted to lowercase.
+   * @return {String} Capitalized version of a string
    */
-  function easeInQuart(t, b, c, d) {
-    return c * (t /= d) * t * t * t + b;
+  function capitalize(string, firstLetterOnly) {
+    return string.charAt(0).toUpperCase() +
+      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
   }
 
   /**
-   * Quartic easing out
-   * @memberOf fabric.util.ease
+   * Escapes XML in a string
+   * @memberOf fabric.util.string
+   * @param {String} string String to escape
+   * @return {String} Escaped version of a string
    */
-  function easeOutQuart(t, b, c, d) {
-    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
+  function escapeXml(string) {
+    return string.replace(/&/g, '&amp;')
+      .replace(/"/g, '&quot;')
+      .replace(/'/g, '&apos;')
+      .replace(/</g, '&lt;')
+      .replace(/>/g, '&gt;');
   }
 
   /**
-   * Quartic easing in and out
-   * @memberOf fabric.util.ease
+   * Divide a string in the user perceived single units
+   * @memberOf fabric.util.string
+   * @param {String} textstring String to escape
+   * @return {Array} array containing the graphemes
    */
-  function easeInOutQuart(t, b, c, d) {
-    t /= d / 2;
-    if (t < 1) {
-      return c / 2 * t * t * t * t + b;
+  function graphemeSplit(textstring) {
+    var i = 0, chr, graphemes = [];
+    for (i = 0, chr; i < textstring.length; i++) {
+      if ((chr = getWholeChar(textstring, i)) === false) {
+        continue;
+      }
+      graphemes.push(chr);
     }
-    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
+    return graphemes;
   }
 
-  /**
-   * Quintic easing in
-   * @memberOf fabric.util.ease
-   */
-  function easeInQuint(t, b, c, d) {
-    return c * (t /= d) * t * t * t * t + b;
-  }
+  // taken from mdn in the charAt doc page.
+  function getWholeChar(str, i) {
+    var code = str.charCodeAt(i);
 
-  /**
-   * Quintic easing out
-   * @memberOf fabric.util.ease
-   */
-  function easeOutQuint(t, b, c, d) {
-    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
-  }
+    if (isNaN(code)) {
+      return ''; // Position not found
+    }
+    if (code < 0xD800 || code > 0xDFFF) {
+      return str.charAt(i);
+    }
 
-  /**
-   * Quintic easing in and out
-   * @memberOf fabric.util.ease
-   */
-  function easeInOutQuint(t, b, c, d) {
-    t /= d / 2;
-    if (t < 1) {
-      return c / 2 * t * t * t * t * t + b;
+    // High surrogate (could change last hex to 0xDB7F to treat high private
+    // surrogates as single characters)
+    if (0xD800 <= code && code <= 0xDBFF) {
+      if (str.length <= (i + 1)) {
+        throw 'High surrogate without following low surrogate';
+      }
+      var next = str.charCodeAt(i + 1);
+      if (0xDC00 > next || next > 0xDFFF) {
+        throw 'High surrogate without following low surrogate';
+      }
+      return str.charAt(i) + str.charAt(i + 1);
     }
-    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
+    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
+    if (i === 0) {
+      throw 'Low surrogate without preceding high surrogate';
+    }
+    var prev = str.charCodeAt(i - 1);
+
+    // (could change last hex to 0xDB7F to treat high private
+    // surrogates as single characters)
+    if (0xD800 > prev || prev > 0xDBFF) {
+      throw 'Low surrogate without preceding high surrogate';
+    }
+    // We can pass over low surrogates now as the second component
+    // in a pair which we have already processed
+    return false;
   }
 
+
   /**
-   * Sinusoidal easing in
-   * @memberOf fabric.util.ease
+   * String utilities
+   * @namespace fabric.util.string
    */
-  function easeInSine(t, b, c, d) {
-    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
-  }
+  fabric.util.string = {
+    camelize: camelize,
+    capitalize: capitalize,
+    escapeXml: escapeXml,
+    graphemeSplit: graphemeSplit
+  };
+})();
 
-  /**
-   * Sinusoidal easing out
-   * @memberOf fabric.util.ease
-   */
-  function easeOutSine(t, b, c, d) {
-    return c * Math.sin(t / d * (Math.PI / 2)) + b;
-  }
 
-  /**
-   * Sinusoidal easing in and out
-   * @memberOf fabric.util.ease
-   */
-  function easeInOutSine(t, b, c, d) {
-    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
-  }
+(function() {
 
-  /**
-   * Exponential easing in
-   * @memberOf fabric.util.ease
-   */
-  function easeInExpo(t, b, c, d) {
-    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
-  }
+  var slice = Array.prototype.slice, emptyFunction = function() { },
 
-  /**
-   * Exponential easing out
-   * @memberOf fabric.util.ease
-   */
-  function easeOutExpo(t, b, c, d) {
-    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
+      IS_DONTENUM_BUGGY = (function() {
+        for (var p in { toString: 1 }) {
+          if (p === 'toString') {
+            return false;
+          }
+        }
+        return true;
+      })(),
+
+      /** @ignore */
+      addMethods = function(klass, source, parent) {
+        for (var property in source) {
+
+          if (property in klass.prototype &&
+              typeof klass.prototype[property] === 'function' &&
+              (source[property] + '').indexOf('callSuper') > -1) {
+
+            klass.prototype[property] = (function(property) {
+              return function() {
+
+                var superclass = this.constructor.superclass;
+                this.constructor.superclass = parent;
+                var returnValue = source[property].apply(this, arguments);
+                this.constructor.superclass = superclass;
+
+                if (property !== 'initialize') {
+                  return returnValue;
+                }
+              };
+            })(property);
+          }
+          else {
+            klass.prototype[property] = source[property];
+          }
+
+          if (IS_DONTENUM_BUGGY) {
+            if (source.toString !== Object.prototype.toString) {
+              klass.prototype.toString = source.toString;
+            }
+            if (source.valueOf !== Object.prototype.valueOf) {
+              klass.prototype.valueOf = source.valueOf;
+            }
+          }
+        }
+      };
+
+  function Subclass() { }
+
+  function callSuper(methodName) {
+    var parentMethod = null,
+        _this = this;
+
+    // climb prototype chain to find method not equal to callee's method
+    while (_this.constructor.superclass) {
+      var superClassMethod = _this.constructor.superclass.prototype[methodName];
+      if (_this[methodName] !== superClassMethod) {
+        parentMethod = superClassMethod;
+        break;
+      }
+      // eslint-disable-next-line
+      _this = _this.constructor.superclass.prototype;
+    }
+
+    if (!parentMethod) {
+      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
+    }
+
+    return (arguments.length > 1)
+      ? parentMethod.apply(this, slice.call(arguments, 1))
+      : parentMethod.call(this);
   }
 
   /**
-   * Exponential easing in and out
-   * @memberOf fabric.util.ease
+   * Helper for creation of "classes".
+   * @memberOf fabric.util
+   * @param {Function} [parent] optional "Class" to inherit from
+   * @param {Object} [properties] Properties shared by all instances of this class
+   *                  (be careful modifying objects defined here as this would affect all instances)
    */
-  function easeInOutExpo(t, b, c, d) {
-    if (t === 0) {
-      return b;
+  function createClass() {
+    var parent = null,
+        properties = slice.call(arguments, 0);
+
+    if (typeof properties[0] === 'function') {
+      parent = properties.shift();
     }
-    if (t === d) {
-      return b + c;
+    function klass() {
+      this.initialize.apply(this, arguments);
     }
-    t /= d / 2;
-    if (t < 1) {
-      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
+
+    klass.superclass = parent;
+    klass.subclasses = [];
+
+    if (parent) {
+      Subclass.prototype = parent.prototype;
+      klass.prototype = new Subclass();
+      parent.subclasses.push(klass);
     }
-    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
+    for (var i = 0, length = properties.length; i < length; i++) {
+      addMethods(klass, properties[i], parent);
+    }
+    if (!klass.prototype.initialize) {
+      klass.prototype.initialize = emptyFunction;
+    }
+    klass.prototype.constructor = klass;
+    klass.prototype.callSuper = callSuper;
+    return klass;
   }
 
-  /**
-   * Circular easing in
-   * @memberOf fabric.util.ease
-   */
-  function easeInCirc(t, b, c, d) {
-    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
-  }
+  fabric.util.createClass = createClass;
+})();
 
+
+(function () {
+  // since ie11 can use addEventListener but they do not support options, i need to check
+  var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent,
+      touchEvents = ['touchstart', 'touchmove', 'touchend'];
   /**
-   * Circular easing out
-   * @memberOf fabric.util.ease
+   * Adds an event listener to an element
+   * @function
+   * @memberOf fabric.util
+   * @param {HTMLElement} element
+   * @param {String} eventName
+   * @param {Function} handler
    */
-  function easeOutCirc(t, b, c, d) {
-    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
-  }
+  fabric.util.addListener = function(element, eventName, handler, options) {
+    element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
+  };
 
   /**
-   * Circular easing in and out
-   * @memberOf fabric.util.ease
+   * Removes an event listener from an element
+   * @function
+   * @memberOf fabric.util
+   * @param {HTMLElement} element
+   * @param {String} eventName
+   * @param {Function} handler
    */
-  function easeInOutCirc(t, b, c, d) {
-    t /= d / 2;
-    if (t < 1) {
-      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
+  fabric.util.removeListener = function(element, eventName, handler, options) {
+    element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
+  };
+
+  function getTouchInfo(event) {
+    var touchProp = event.changedTouches;
+    if (touchProp && touchProp[0]) {
+      return touchProp[0];
     }
-    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
+    return event;
   }
 
+  fabric.util.getPointer = function(event) {
+    var element = event.target,
+        scroll = fabric.util.getScrollLeftTop(element),
+        _evt = getTouchInfo(event);
+    return {
+      x: _evt.clientX + scroll.left,
+      y: _evt.clientY + scroll.top
+    };
+  };
+
+  fabric.util.isTouchEvent = function(event) {
+    return touchEvents.indexOf(event.type) > -1 || event.pointerType === 'touch';
+  };
+})();
+
+
+(function () {
+
   /**
-   * Elastic easing in
-   * @memberOf fabric.util.ease
+   * Cross-browser wrapper for setting element's style
+   * @memberOf fabric.util
+   * @param {HTMLElement} element
+   * @param {Object} styles
+   * @return {HTMLElement} Element that was passed as a first argument
    */
-  function easeInElastic(t, b, c, d) {
-    var s = 1.70158, p = 0, a = c;
-    if (t === 0) {
-      return b;
+  function setStyle(element, styles) {
+    var elementStyle = element.style;
+    if (!elementStyle) {
+      return element;
     }
-    t /= d;
-    if (t === 1) {
-      return b + c;
+    if (typeof styles === 'string') {
+      element.style.cssText += ';' + styles;
+      return styles.indexOf('opacity') > -1
+        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
+        : element;
     }
-    if (!p) {
-      p = d * 0.3;
+    for (var property in styles) {
+      if (property === 'opacity') {
+        setOpacity(element, styles[property]);
+      }
+      else {
+        var normalizedProperty = (property === 'float' || property === 'cssFloat')
+          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
+          : property;
+        elementStyle[normalizedProperty] = styles[property];
+      }
     }
-    var opts = normalize(a, c, p, s);
-    return -elastic(opts, t, d) + b;
+    return element;
   }
 
-  /**
-   * Elastic easing out
-   * @memberOf fabric.util.ease
-   */
-  function easeOutElastic(t, b, c, d) {
-    var s = 1.70158, p = 0, a = c;
-    if (t === 0) {
-      return b;
-    }
-    t /= d;
-    if (t === 1) {
-      return b + c;
-    }
-    if (!p) {
-      p = d * 0.3;
-    }
-    var opts = normalize(a, c, p, s);
-    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
+  var parseEl = fabric.document.createElement('div'),
+      supportsOpacity = typeof parseEl.style.opacity === 'string',
+      supportsFilters = typeof parseEl.style.filter === 'string',
+      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
+
+      /** @ignore */
+      setOpacity = function (element) { return element; };
+
+  if (supportsOpacity) {
+    /** @ignore */
+    setOpacity = function(element, value) {
+      element.style.opacity = value;
+      return element;
+    };
+  }
+  else if (supportsFilters) {
+    /** @ignore */
+    setOpacity = function(element, value) {
+      var es = element.style;
+      if (element.currentStyle && !element.currentStyle.hasLayout) {
+        es.zoom = 1;
+      }
+      if (reOpacity.test(es.filter)) {
+        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
+        es.filter = es.filter.replace(reOpacity, value);
+      }
+      else {
+        es.filter += ' alpha(opacity=' + (value * 100) + ')';
+      }
+      return element;
+    };
   }
 
+  fabric.util.setStyle = setStyle;
+
+})();
+
+
+(function() {
+
+  var _slice = Array.prototype.slice;
+
   /**
-   * Elastic easing in and out
-   * @memberOf fabric.util.ease
+   * Takes id and returns an element with that id (if one exists in a document)
+   * @memberOf fabric.util
+   * @param {String|HTMLElement} id
+   * @return {HTMLElement|null}
    */
-  function easeInOutElastic(t, b, c, d) {
-    var s = 1.70158, p = 0, a = c;
-    if (t === 0) {
-      return b;
-    }
-    t /= d / 2;
-    if (t === 2) {
-      return b + c;
-    }
-    if (!p) {
-      p = d * (0.3 * 1.5);
-    }
-    var opts = normalize(a, c, p, s);
-    if (t < 1) {
-      return -0.5 * elastic(opts, t, d) + b;
-    }
-    return opts.a * Math.pow(2, -10 * (t -= 1)) *
-      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
+  function getById(id) {
+    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
+  }
+
+  var sliceCanConvertNodelists,
+      /**
+       * Converts an array-like object (e.g. arguments or NodeList) to an array
+       * @memberOf fabric.util
+       * @param {Object} arrayLike
+       * @return {Array}
+       */
+      toArray = function(arrayLike) {
+        return _slice.call(arrayLike, 0);
+      };
+
+  try {
+    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
+  }
+  catch (err) { }
+
+  if (!sliceCanConvertNodelists) {
+    toArray = function(arrayLike) {
+      var arr = new Array(arrayLike.length), i = arrayLike.length;
+      while (i--) {
+        arr[i] = arrayLike[i];
+      }
+      return arr;
+    };
   }
 
   /**
-   * Backwards easing in
-   * @memberOf fabric.util.ease
+   * Creates specified element with specified attributes
+   * @memberOf fabric.util
+   * @param {String} tagName Type of an element to create
+   * @param {Object} [attributes] Attributes to set on an element
+   * @return {HTMLElement} Newly created element
    */
-  function easeInBack(t, b, c, d, s) {
-    if (s === undefined) {
-      s = 1.70158;
+  function makeElement(tagName, attributes) {
+    var el = fabric.document.createElement(tagName);
+    for (var prop in attributes) {
+      if (prop === 'class') {
+        el.className = attributes[prop];
+      }
+      else if (prop === 'for') {
+        el.htmlFor = attributes[prop];
+      }
+      else {
+        el.setAttribute(prop, attributes[prop]);
+      }
     }
-    return c * (t /= d) * t * ((s + 1) * t - s) + b;
+    return el;
   }
 
   /**
-   * Backwards easing out
-   * @memberOf fabric.util.ease
+   * Adds class to an element
+   * @memberOf fabric.util
+   * @param {HTMLElement} element Element to add class to
+   * @param {String} className Class to add to an element
    */
-  function easeOutBack(t, b, c, d, s) {
-    if (s === undefined) {
-      s = 1.70158;
+  function addClass(element, className) {
+    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
+      element.className += (element.className ? ' ' : '') + className;
     }
-    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
   }
 
   /**
-   * Backwards easing in and out
-   * @memberOf fabric.util.ease
+   * Wraps element with another element
+   * @memberOf fabric.util
+   * @param {HTMLElement} element Element to wrap
+   * @param {HTMLElement|String} wrapper Element to wrap with
+   * @param {Object} [attributes] Attributes to set on a wrapper
+   * @return {HTMLElement} wrapper
    */
-  function easeInOutBack(t, b, c, d, s) {
-    if (s === undefined) {
-      s = 1.70158;
+  function wrapElement(element, wrapper, attributes) {
+    if (typeof wrapper === 'string') {
+      wrapper = makeElement(wrapper, attributes);
     }
-    t /= d / 2;
-    if (t < 1) {
-      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
+    if (element.parentNode) {
+      element.parentNode.replaceChild(wrapper, element);
     }
-    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
+    wrapper.appendChild(element);
+    return wrapper;
   }
 
   /**
-   * Bouncing easing in
-   * @memberOf fabric.util.ease
+   * Returns element scroll offsets
+   * @memberOf fabric.util
+   * @param {HTMLElement} element Element to operate on
+   * @return {Object} Object with left/top values
    */
-  function easeInBounce(t, b, c, d) {
-    return c - easeOutBounce (d - t, 0, c, d) + b;
+  function getScrollLeftTop(element) {
+
+    var left = 0,
+        top = 0,
+        docElement = fabric.document.documentElement,
+        body = fabric.document.body || {
+          scrollLeft: 0, scrollTop: 0
+        };
+
+    // While loop checks (and then sets element to) .parentNode OR .host
+    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
+    //  but the .parentNode of a root ShadowDOM node will always be null, instead
+    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
+    while (element && (element.parentNode || element.host)) {
+
+      // Set element to element parent, or 'host' in case of ShadowDOM
+      element = element.parentNode || element.host;
+
+      if (element === fabric.document) {
+        left = body.scrollLeft || docElement.scrollLeft || 0;
+        top = body.scrollTop ||  docElement.scrollTop || 0;
+      }
+      else {
+        left += element.scrollLeft || 0;
+        top += element.scrollTop || 0;
+      }
+
+      if (element.nodeType === 1 && element.style.position === 'fixed') {
+        break;
+      }
+    }
+
+    return { left: left, top: top };
   }
 
   /**
-   * Bouncing easing out
-   * @memberOf fabric.util.ease
+   * Returns offset for a given element
+   * @function
+   * @memberOf fabric.util
+   * @param {HTMLElement} element Element to get offset for
+   * @return {Object} Object with "left" and "top" properties
    */
-  function easeOutBounce(t, b, c, d) {
-    if ((t /= d) < (1 / 2.75)) {
-      return c * (7.5625 * t * t) + b;
-    }
-    else if (t < (2 / 2.75)) {
-      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
+  function getElementOffset(element) {
+    var docElem,
+        doc = element && element.ownerDocument,
+        box = { left: 0, top: 0 },
+        offset = { left: 0, top: 0 },
+        scrollLeftTop,
+        offsetAttributes = {
+          borderLeftWidth: 'left',
+          borderTopWidth:  'top',
+          paddingLeft:     'left',
+          paddingTop:      'top'
+        };
+
+    if (!doc) {
+      return offset;
     }
-    else if (t < (2.5 / 2.75)) {
-      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
+
+    for (var attr in offsetAttributes) {
+      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
     }
-    else {
-      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
+
+    docElem = doc.documentElement;
+    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
+      box = element.getBoundingClientRect();
     }
+
+    scrollLeftTop = getScrollLeftTop(element);
+
+    return {
+      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
+      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
+    };
   }
 
   /**
-   * Bouncing easing in and out
-   * @memberOf fabric.util.ease
+   * Returns style attribute value of a given element
+   * @memberOf fabric.util
+   * @param {HTMLElement} element Element to get style attribute for
+   * @param {String} attr Style attribute to get for element
+   * @return {String} Style attribute value of the given element.
    */
-  function easeInOutBounce(t, b, c, d) {
-    if (t < d / 2) {
-      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
-    }
-    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
+  var getElementStyle;
+  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
+    getElementStyle = function(element, attr) {
+      var style = fabric.document.defaultView.getComputedStyle(element, null);
+      return style ? style[attr] : undefined;
+    };
+  }
+  else {
+    getElementStyle = function(element, attr) {
+      var value = element.style[attr];
+      if (!value && element.currentStyle) {
+        value = element.currentStyle[attr];
+      }
+      return value;
+    };
   }
 
-  /**
-   * Easing functions
-   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
-   * @namespace fabric.util.ease
-   */
-  fabric.util.ease = {
-
-    /**
-     * Quadratic easing in
-     * @memberOf fabric.util.ease
-     */
-    easeInQuad: function(t, b, c, d) {
-      return c * (t /= d) * t + b;
-    },
+  (function () {
+    var style = fabric.document.documentElement.style,
+        selectProp = 'userSelect' in style
+          ? 'userSelect'
+          : 'MozUserSelect' in style
+            ? 'MozUserSelect'
+            : 'WebkitUserSelect' in style
+              ? 'WebkitUserSelect'
+              : 'KhtmlUserSelect' in style
+                ? 'KhtmlUserSelect'
+                : '';
 
     /**
-     * Quadratic easing out
-     * @memberOf fabric.util.ease
+     * Makes element unselectable
+     * @memberOf fabric.util
+     * @param {HTMLElement} element Element to make unselectable
+     * @return {HTMLElement} Element that was passed in
      */
-    easeOutQuad: function(t, b, c, d) {
-      return -c * (t /= d) * (t - 2) + b;
-    },
+    function makeElementUnselectable(element) {
+      if (typeof element.onselectstart !== 'undefined') {
+        element.onselectstart = fabric.util.falseFunction;
+      }
+      if (selectProp) {
+        element.style[selectProp] = 'none';
+      }
+      else if (typeof element.unselectable === 'string') {
+        element.unselectable = 'on';
+      }
+      return element;
+    }
 
     /**
-     * Quadratic easing in and out
-     * @memberOf fabric.util.ease
+     * Makes element selectable
+     * @memberOf fabric.util
+     * @param {HTMLElement} element Element to make selectable
+     * @return {HTMLElement} Element that was passed in
      */
-    easeInOutQuad: function(t, b, c, d) {
-      t /= (d / 2);
-      if (t < 1) {
-        return c / 2 * t * t + b;
+    function makeElementSelectable(element) {
+      if (typeof element.onselectstart !== 'undefined') {
+        element.onselectstart = null;
       }
-      return -c / 2 * ((--t) * (t - 2) - 1) + b;
-    },
+      if (selectProp) {
+        element.style[selectProp] = '';
+      }
+      else if (typeof element.unselectable === 'string') {
+        element.unselectable = '';
+      }
+      return element;
+    }
 
-    /**
-     * Cubic easing in
-     * @memberOf fabric.util.ease
-     */
-    easeInCubic: function(t, b, c, d) {
-      return c * (t /= d) * t * t + b;
-    },
+    fabric.util.makeElementUnselectable = makeElementUnselectable;
+    fabric.util.makeElementSelectable = makeElementSelectable;
+  })();
 
-    easeOutCubic: easeOutCubic,
-    easeInOutCubic: easeInOutCubic,
-    easeInQuart: easeInQuart,
-    easeOutQuart: easeOutQuart,
-    easeInOutQuart: easeInOutQuart,
-    easeInQuint: easeInQuint,
-    easeOutQuint: easeOutQuint,
-    easeInOutQuint: easeInOutQuint,
-    easeInSine: easeInSine,
-    easeOutSine: easeOutSine,
-    easeInOutSine: easeInOutSine,
-    easeInExpo: easeInExpo,
-    easeOutExpo: easeOutExpo,
-    easeInOutExpo: easeInOutExpo,
-    easeInCirc: easeInCirc,
-    easeOutCirc: easeOutCirc,
-    easeInOutCirc: easeInOutCirc,
-    easeInElastic: easeInElastic,
-    easeOutElastic: easeOutElastic,
-    easeInOutElastic: easeInOutElastic,
-    easeInBack: easeInBack,
-    easeOutBack: easeOutBack,
-    easeInOutBack: easeInOutBack,
-    easeInBounce: easeInBounce,
-    easeOutBounce: easeOutBounce,
-    easeInOutBounce: easeInOutBounce
+  function getNodeCanvas(element) {
+    var impl = fabric.jsdomImplForWrapper(element);
+    return impl._canvas || impl._image;
   };
 
-})();
-
-
-(function(global) {
+  function cleanUpJsdomNode(element) {
+    if (!fabric.isLikelyNode) {
+      return;
+    }
+    var impl = fabric.jsdomImplForWrapper(element);
+    if (impl) {
+      impl._image = null;
+      impl._canvas = null;
+      // unsure if necessary
+      impl._currentSrc = null;
+      impl._attributes = null;
+      impl._classList = null;
+    }
+  }
 
-  'use strict';
+  function setImageSmoothing(ctx, value) {
+    ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
+      || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
+    ctx.imageSmoothingEnabled = value;
+  }
 
   /**
-   * @name fabric
-   * @namespace
+   * setImageSmoothing sets the context imageSmoothingEnabled property.
+   * Used by canvas and by ImageObject.
+   * @memberOf fabric.util
+   * @since 4.0.0
+   * @param {HTMLRenderingContext2D} ctx to set on
+   * @param {Boolean} value true or false
    */
+  fabric.util.setImageSmoothing = setImageSmoothing;
+  fabric.util.getById = getById;
+  fabric.util.toArray = toArray;
+  fabric.util.addClass = addClass;
+  fabric.util.makeElement = makeElement;
+  fabric.util.wrapElement = wrapElement;
+  fabric.util.getScrollLeftTop = getScrollLeftTop;
+  fabric.util.getElementOffset = getElementOffset;
+  fabric.util.getNodeCanvas = getNodeCanvas;
+  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;
 
-  var fabric = global.fabric || (global.fabric = { }),
-      extend = fabric.util.object.extend,
-      clone = fabric.util.object.clone,
-      toFixed = fabric.util.toFixed,
-      parseUnit = fabric.util.parseUnit,
-      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
+})();
 
-      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
-        'image', 'text'],
-      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
-      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
-      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],
 
-      attributesMap = {
-        cx:                   'left',
-        x:                    'left',
-        r:                    'radius',
-        cy:                   'top',
-        y:                    'top',
-        display:              'visible',
-        visibility:           'visible',
-        transform:            'transformMatrix',
-        'fill-opacity':       'fillOpacity',
-        'fill-rule':          'fillRule',
-        'font-family':        'fontFamily',
-        'font-size':          'fontSize',
-        'font-style':         'fontStyle',
-        'font-weight':        'fontWeight',
-        'letter-spacing':     'charSpacing',
-        'paint-order':        'paintFirst',
-        'stroke-dasharray':   'strokeDashArray',
-        'stroke-dashoffset':  'strokeDashOffset',
-        'stroke-linecap':     'strokeLineCap',
-        'stroke-linejoin':    'strokeLineJoin',
-        'stroke-miterlimit':  'strokeMiterLimit',
-        'stroke-opacity':     'strokeOpacity',
-        'stroke-width':       'strokeWidth',
-        'text-decoration':    'textDecoration',
-        'text-anchor':        'textAnchor',
-        opacity:              'opacity',
-        'clip-path':          'clipPath',
-        'clip-rule':          'clipRule',
-        'vector-effect':      'strokeUniform',
-        'image-rendering':    'imageSmoothing',
-      },
+(function() {
 
-      colorAttributes = {
-        stroke: 'strokeOpacity',
-        fill:   'fillOpacity'
-      },
+  function addParamToUrl(url, param) {
+    return url + (/\?/.test(url) ? '&' : '?') + param;
+  }
 
-      fSize = 'font-size', cPath = 'clip-path';
+  function emptyFn() { }
 
-  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
-  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
-  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
-  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);
+  /**
+   * Cross-browser abstraction for sending XMLHttpRequest
+   * @memberOf fabric.util
+   * @param {String} url URL to send XMLHttpRequest to
+   * @param {Object} [options] Options object
+   * @param {String} [options.method="GET"]
+   * @param {String} [options.parameters] parameters to append to url in GET or in body
+   * @param {String} [options.body] body to send with POST or PUT request
+   * @param {Function} options.onComplete Callback to invoke when request is completed
+   * @return {XMLHttpRequest} request
+   */
+  function request(url, options) {
+    options || (options = { });
 
-  fabric.cssRules = { };
-  fabric.gradientDefs = { };
-  fabric.clipPaths = { };
+    var method = options.method ? options.method.toUpperCase() : 'GET',
+        onComplete = options.onComplete || function() { },
+        xhr = new fabric.window.XMLHttpRequest(),
+        body = options.body || options.parameters;
 
-  function normalizeAttr(attr) {
-    // transform attribute names
-    if (attr in attributesMap) {
-      return attributesMap[attr];
-    }
-    return attr;
-  }
-
-  function normalizeValue(attr, value, parentAttributes, fontSize) {
-    var isArray = Object.prototype.toString.call(value) === '[object Array]',
-        parsed;
-
-    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
-      value = '';
-    }
-    else if (attr === 'strokeUniform') {
-      return (value === 'non-scaling-stroke');
-    }
-    else if (attr === 'strokeDashArray') {
-      if (value === 'none') {
-        value = null;
-      }
-      else {
-        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
-      }
-    }
-    else if (attr === 'transformMatrix') {
-      if (parentAttributes && parentAttributes.transformMatrix) {
-        value = multiplyTransformMatrices(
-          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
-      }
-      else {
-        value = fabric.parseTransformAttribute(value);
-      }
-    }
-    else if (attr === 'visible') {
-      value = value !== 'none' && value !== 'hidden';
-      // display=none on parent element always takes precedence over child element
-      if (parentAttributes && parentAttributes.visible === false) {
-        value = false;
-      }
-    }
-    else if (attr === 'opacity') {
-      value = parseFloat(value);
-      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
-        value *= parentAttributes.opacity;
-      }
-    }
-    else if (attr === 'textAnchor' /* text-anchor */) {
-      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
-    }
-    else if (attr === 'charSpacing') {
-      // parseUnit returns px and we convert it to em
-      parsed = parseUnit(value, fontSize) / fontSize * 1000;
-    }
-    else if (attr === 'paintFirst') {
-      var fillIndex = value.indexOf('fill');
-      var strokeIndex = value.indexOf('stroke');
-      var value = 'fill';
-      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
-        value = 'stroke';
+    /** @ignore */
+    xhr.onreadystatechange = function() {
+      if (xhr.readyState === 4) {
+        onComplete(xhr);
+        xhr.onreadystatechange = emptyFn;
       }
-      else if (fillIndex === -1 && strokeIndex > -1) {
-        value = 'stroke';
+    };
+
+    if (method === 'GET') {
+      body = null;
+      if (typeof options.parameters === 'string') {
+        url = addParamToUrl(url, options.parameters);
       }
     }
-    else if (attr === 'href' || attr === 'xlink:href' || attr === 'font') {
-      return value;
-    }
-    else if (attr === 'imageSmoothing') {
-      return (value === 'optimizeQuality');
-    }
-    else {
-      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
+
+    xhr.open(method, url, true);
+
+    if (method === 'POST' || method === 'PUT') {
+      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
     }
 
-    return (!isArray && isNaN(parsed) ? value : parsed);
+    xhr.send(body);
+    return xhr;
   }
 
-  /**
-    * @private
-    */
-  function getSvgRegex(arr) {
-    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
-  }
+  fabric.util.request = request;
+})();
 
-  /**
-   * @private
-   * @param {Object} attributes Array of attributes to parse
-   */
-  function _setStrokeFillOpacity(attributes) {
-    for (var attr in colorAttributes) {
 
-      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
-        continue;
-      }
+/**
+ * Wrapper around `console.log` (when available)
+ * @param {*} [values] Values to log
+ */
+fabric.log = console.log;
 
-      if (typeof attributes[attr] === 'undefined') {
-        if (!fabric.Object.prototype[attr]) {
-          continue;
-        }
-        attributes[attr] = fabric.Object.prototype[attr];
-      }
+/**
+ * Wrapper around `console.warn` (when available)
+ * @param {*} [values] Values to log as a warning
+ */
+fabric.warn = console.warn;
 
-      if (attributes[attr].indexOf('url(') === 0) {
-        continue;
-      }
 
-      var color = new fabric.Color(attributes[attr]);
-      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
-    }
-    return attributes;
+(function() {
+
+  function noop() {
+    return false;
   }
 
-  /**
-   * @private
-   */
-  function _getMultipleNodes(doc, nodeNames) {
-    var nodeName, nodeArray = [], nodeList, i, len;
-    for (i = 0, len = nodeNames.length; i < len; i++) {
-      nodeName = nodeNames[i];
-      nodeList = doc.getElementsByTagName(nodeName);
-      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
-    }
-    return nodeArray;
+  function defaultEasing(t, b, c, d) {
+    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
   }
 
   /**
-   * Parses "transform" attribute, returning an array of values
-   * @static
-   * @function
-   * @memberOf fabric
-   * @param {String} attributeValue String containing attribute value
-   * @return {Array} Array of 6 elements representing transformation matrix
+   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
+   * @memberOf fabric.util
+   * @param {Object} [options] Animation options
+   * @param {Function} [options.onChange] Callback; invoked on every value change
+   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
+   * @param {Number} [options.startValue=0] Starting value
+   * @param {Number} [options.endValue=100] Ending value
+   * @param {Number} [options.byValue=100] Value to modify the property by
+   * @param {Function} [options.easing] Easing function
+   * @param {Number} [options.duration=500] Duration of change (in ms)
+   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
+   * @returns {Function} abort function
    */
-  fabric.parseTransformAttribute = (function() {
-    function rotateMatrix(matrix, args) {
-      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
-          x = 0, y = 0;
-      if (args.length === 3) {
-        x = args[1];
-        y = args[2];
-      }
-
-      matrix[0] = cos;
-      matrix[1] = sin;
-      matrix[2] = -sin;
-      matrix[3] = cos;
-      matrix[4] = x - (cos * x - sin * y);
-      matrix[5] = y - (sin * x + cos * y);
-    }
-
-    function scaleMatrix(matrix, args) {
-      var multiplierX = args[0],
-          multiplierY = (args.length === 2) ? args[1] : args[0];
+  function animate(options) {
+    var cancel = false;
+    requestAnimFrame(function(timestamp) {
+      options || (options = { });
 
-      matrix[0] = multiplierX;
-      matrix[3] = multiplierY;
-    }
+      var start = timestamp || +new Date(),
+          duration = options.duration || 500,
+          finish = start + duration, time,
+          onChange = options.onChange || noop,
+          abort = options.abort || noop,
+          onComplete = options.onComplete || noop,
+          easing = options.easing || defaultEasing,
+          startValue = 'startValue' in options ? options.startValue : 0,
+          endValue = 'endValue' in options ? options.endValue : 100,
+          byValue = options.byValue || endValue - startValue;
 
-    function skewMatrix(matrix, args, pos) {
-      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
-    }
+      options.onStart && options.onStart();
 
-    function translateMatrix(matrix, args) {
-      matrix[4] = args[0];
-      if (args.length === 2) {
-        matrix[5] = args[1];
-      }
-    }
+      (function tick(ticktime) {
+        // TODO: move abort call after calculation
+        // and pass (current,valuePerc, timePerc) as arguments
+        time = ticktime || +new Date();
+        var currentTime = time > finish ? duration : (time - start),
+            timePerc = currentTime / duration,
+            current = easing(currentTime, startValue, byValue, duration),
+            valuePerc = Math.abs((current - startValue) / byValue);
+        if (cancel) {
+          return;
+        }
+        if (abort(current, valuePerc, timePerc)) {
+          // remove this in 4.0
+          // does to even make sense to abort and run onComplete?
+          onComplete(endValue, 1, 1);
+          return;
+        }
+        if (time > finish) {
+          onChange(endValue, 1, 1);
+          onComplete(endValue, 1, 1);
+          return;
+        }
+        else {
+          onChange(current, valuePerc, timePerc);
+          requestAnimFrame(tick);
+        }
+      })(start);
+    });
+    return function() {
+      cancel = true;
+    };
+  }
 
-    // identity matrix
-    var iMatrix = fabric.iMatrix,
+  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
+                          fabric.window.webkitRequestAnimationFrame ||
+                          fabric.window.mozRequestAnimationFrame    ||
+                          fabric.window.oRequestAnimationFrame      ||
+                          fabric.window.msRequestAnimationFrame     ||
+                          function(callback) {
+                            return fabric.window.setTimeout(callback, 1000 / 60);
+                          };
 
-        // == begin transform regexp
-        number = fabric.reNum,
+  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;
 
-        commaWsp = fabric.commaWsp,
-
-        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
-
-        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
-
-        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
-                    commaWsp + '(' + number + ')' +
-                    commaWsp + '(' + number + '))?\\s*\\))',
-
-        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
-                    commaWsp + '(' + number + '))?\\s*\\))',
-
-        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
-                    commaWsp + '(' + number + '))?\\s*\\))',
-
-        matrix = '(?:(matrix)\\s*\\(\\s*' +
-                  '(' + number + ')' + commaWsp +
-                  '(' + number + ')' + commaWsp +
-                  '(' + number + ')' + commaWsp +
-                  '(' + number + ')' + commaWsp +
-                  '(' + number + ')' + commaWsp +
-                  '(' + number + ')' +
-                  '\\s*\\))',
-
-        transform = '(?:' +
-                    matrix + '|' +
-                    translate + '|' +
-                    scale + '|' +
-                    rotate + '|' +
-                    skewX + '|' +
-                    skewY +
-                    ')',
+  /**
+   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
+   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
+   * @memberOf fabric.util
+   * @param {Function} callback Callback to invoke
+   * @param {DOMElement} element optional Element to associate with animation
+   */
+  function requestAnimFrame() {
+    return _requestAnimFrame.apply(fabric.window, arguments);
+  }
 
-        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',
+  function cancelAnimFrame() {
+    return _cancelAnimFrame.apply(fabric.window, arguments);
+  }
 
-        transformList = '^\\s*(?:' + transforms + '?)\\s*$',
+  fabric.util.animate = animate;
+  fabric.util.requestAnimFrame = requestAnimFrame;
+  fabric.util.cancelAnimFrame = cancelAnimFrame;
+})();
 
-        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
-        reTransformList = new RegExp(transformList),
-        // == end transform regexp
 
-        reTransform = new RegExp(transform, 'g');
+(function() {
+  // Calculate an in-between color. Returns a "rgba()" string.
+  // Credit: Edwin Martin <edwin@bitstorm.org>
+  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
+  function calculateColor(begin, end, pos) {
+    var color = 'rgba('
+        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
+        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
+        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);
 
-    return function(attributeValue) {
+    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
+    color += ')';
+    return color;
+  }
 
-      // start with identity matrix
-      var matrix = iMatrix.concat(),
-          matrices = [];
+  /**
+   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
+   * @memberOf fabric.util
+   * @param {String} fromColor The starting color in hex or rgb(a) format.
+   * @param {String} toColor The starting color in hex or rgb(a) format.
+   * @param {Number} [duration] Duration of change (in ms).
+   * @param {Object} [options] Animation options
+   * @param {Function} [options.onChange] Callback; invoked on every value change
+   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
+   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
+   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
+   * @returns {Function} abort function
+   */
+  function animateColor(fromColor, toColor, duration, options) {
+    var startColor = new fabric.Color(fromColor).getSource(),
+        endColor = new fabric.Color(toColor).getSource(),
+        originalOnComplete = options.onComplete,
+        originalOnChange = options.onChange;
+    options = options || {};
 
-      // return if no argument was given or
-      // an argument does not match transform attribute regexp
-      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
-        return matrix;
+    return fabric.util.animate(fabric.util.object.extend(options, {
+      duration: duration || 500,
+      startValue: startColor,
+      endValue: endColor,
+      byValue: endColor,
+      easing: function (currentTime, startValue, byValue, duration) {
+        var posValue = options.colorEasing
+          ? options.colorEasing(currentTime, duration)
+          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
+        return calculateColor(startValue, byValue, posValue);
+      },
+      // has to take in account for color restoring;
+      onComplete: function(current, valuePerc, timePerc) {
+        if (originalOnComplete) {
+          return originalOnComplete(
+            calculateColor(endColor, endColor, 0),
+            valuePerc,
+            timePerc
+          );
+        }
+      },
+      onChange: function(current, valuePerc, timePerc) {
+        if (originalOnChange) {
+          if (Array.isArray(current)) {
+            return originalOnChange(
+              calculateColor(current, current, 0),
+              valuePerc,
+              timePerc
+            );
+          }
+          originalOnChange(current, valuePerc, timePerc);
+        }
       }
+    }));
+  }
 
-      attributeValue.replace(reTransform, function(match) {
+  fabric.util.animateColor = animateColor;
 
-        var m = new RegExp(transform).exec(match).filter(function (match) {
-              // match !== '' && match != null
-              return (!!match);
-            }),
-            operation = m[1],
-            args = m.slice(2).map(parseFloat);
+})();
 
-        switch (operation) {
-          case 'translate':
-            translateMatrix(matrix, args);
-            break;
-          case 'rotate':
-            args[0] = fabric.util.degreesToRadians(args[0]);
-            rotateMatrix(matrix, args);
-            break;
-          case 'scale':
-            scaleMatrix(matrix, args);
-            break;
-          case 'skewX':
-            skewMatrix(matrix, args, 2);
-            break;
-          case 'skewY':
-            skewMatrix(matrix, args, 1);
-            break;
-          case 'matrix':
-            matrix = args;
-            break;
-        }
 
-        // snapshot current matrix into matrices array
-        matrices.push(matrix.concat());
-        // reset
-        matrix = iMatrix.concat();
-      });
+(function() {
 
-      var combinedMatrix = matrices[0];
-      while (matrices.length > 1) {
-        matrices.shift();
-        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
+  function normalize(a, c, p, s) {
+    if (a < Math.abs(c)) {
+      a = c;
+      s = p / 4;
+    }
+    else {
+      //handle the 0/0 case:
+      if (c === 0 && a === 0) {
+        s = p / (2 * Math.PI) * Math.asin(1);
       }
-      return combinedMatrix;
-    };
-  })();
+      else {
+        s = p / (2 * Math.PI) * Math.asin(c / a);
+      }
+    }
+    return { a: a, c: c, p: p, s: s };
+  }
+
+  function elastic(opts, t, d) {
+    return opts.a *
+      Math.pow(2, 10 * (t -= 1)) *
+      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
+  }
 
   /**
-   * @private
+   * Cubic easing out
+   * @memberOf fabric.util.ease
    */
-  function parseStyleString(style, oStyle) {
-    var attr, value;
-    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
-      var pair = chunk.split(':');
-
-      attr = pair[0].trim().toLowerCase();
-      value =  pair[1].trim();
-
-      oStyle[attr] = value;
-    });
+  function easeOutCubic(t, b, c, d) {
+    return c * ((t = t / d - 1) * t * t + 1) + b;
   }
 
   /**
-   * @private
+   * Cubic easing in and out
+   * @memberOf fabric.util.ease
    */
-  function parseStyleObject(style, oStyle) {
-    var attr, value;
-    for (var prop in style) {
-      if (typeof style[prop] === 'undefined') {
-        continue;
-      }
-
-      attr = prop.toLowerCase();
-      value = style[prop];
-
-      oStyle[attr] = value;
+  function easeInOutCubic(t, b, c, d) {
+    t /= d / 2;
+    if (t < 1) {
+      return c / 2 * t * t * t + b;
     }
+    return c / 2 * ((t -= 2) * t * t + 2) + b;
   }
 
   /**
-   * @private
+   * Quartic easing in
+   * @memberOf fabric.util.ease
    */
-  function getGlobalStylesForElement(element, svgUid) {
-    var styles = { };
-    for (var rule in fabric.cssRules[svgUid]) {
-      if (elementMatchesRule(element, rule.split(' '))) {
-        for (var property in fabric.cssRules[svgUid][rule]) {
-          styles[property] = fabric.cssRules[svgUid][rule][property];
-        }
-      }
-    }
-    return styles;
+  function easeInQuart(t, b, c, d) {
+    return c * (t /= d) * t * t * t + b;
   }
 
   /**
-   * @private
+   * Quartic easing out
+   * @memberOf fabric.util.ease
    */
-  function elementMatchesRule(element, selectors) {
-    var firstMatching, parentMatching = true;
-    //start from rightmost selector.
-    firstMatching = selectorMatches(element, selectors.pop());
-    if (firstMatching && selectors.length) {
-      parentMatching = doesSomeParentMatch(element, selectors);
-    }
-    return firstMatching && parentMatching && (selectors.length === 0);
+  function easeOutQuart(t, b, c, d) {
+    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
   }
 
-  function doesSomeParentMatch(element, selectors) {
-    var selector, parentMatching = true;
-    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
-      if (parentMatching) {
-        selector = selectors.pop();
-      }
-      element = element.parentNode;
-      parentMatching = selectorMatches(element, selector);
+  /**
+   * Quartic easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutQuart(t, b, c, d) {
+    t /= d / 2;
+    if (t < 1) {
+      return c / 2 * t * t * t * t + b;
     }
-    return selectors.length === 0;
+    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
   }
 
   /**
-   * @private
+   * Quintic easing in
+   * @memberOf fabric.util.ease
    */
-  function selectorMatches(element, selector) {
-    var nodeName = element.nodeName,
-        classNames = element.getAttribute('class'),
-        id = element.getAttribute('id'), matcher, i;
-    // i check if a selector matches slicing away part from it.
-    // if i get empty string i should match
-    matcher = new RegExp('^' + nodeName, 'i');
-    selector = selector.replace(matcher, '');
-    if (id && selector.length) {
-      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
-      selector = selector.replace(matcher, '');
-    }
-    if (classNames && selector.length) {
-      classNames = classNames.split(' ');
-      for (i = classNames.length; i--;) {
-        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
-        selector = selector.replace(matcher, '');
-      }
-    }
-    return selector.length === 0;
+  function easeInQuint(t, b, c, d) {
+    return c * (t /= d) * t * t * t * t + b;
   }
 
   /**
-   * @private
-   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
+   * Quintic easing out
+   * @memberOf fabric.util.ease
    */
-  function elementById(doc, id) {
-    var el;
-    doc.getElementById && (el = doc.getElementById(id));
-    if (el) {
-      return el;
-    }
-    var node, i, len, nodelist = doc.getElementsByTagName('*');
-    for (i = 0, len = nodelist.length; i < len; i++) {
-      node = nodelist[i];
-      if (id === node.getAttribute('id')) {
-        return node;
-      }
-    }
+  function easeOutQuint(t, b, c, d) {
+    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
   }
 
   /**
-   * @private
+   * Quintic easing in and out
+   * @memberOf fabric.util.ease
    */
-  function parseUseDirectives(doc) {
-    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
-    while (nodelist.length && i < nodelist.length) {
-      var el = nodelist[i],
-          xlinkAttribute = el.getAttribute('xlink:href') || el.getAttribute('href');
-
-      if (xlinkAttribute === null) {
-        return;
-      }
-
-      var xlink = xlinkAttribute.substr(1),
-          x = el.getAttribute('x') || 0,
-          y = el.getAttribute('y') || 0,
-          el2 = elementById(doc, xlink).cloneNode(true),
-          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
-          parentNode,
-          oldLength = nodelist.length, attr,
-          j,
-          attrs,
-          len,
-          namespace = fabric.svgNS;
+  function easeInOutQuint(t, b, c, d) {
+    t /= d / 2;
+    if (t < 1) {
+      return c / 2 * t * t * t * t * t + b;
+    }
+    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
+  }
 
-      applyViewboxTransform(el2);
-      if (/^svg$/i.test(el2.nodeName)) {
-        var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
-        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
-          attr = attrs.item(j);
-          el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
-        }
-        // el2.firstChild != null
-        while (el2.firstChild) {
-          el3.appendChild(el2.firstChild);
-        }
-        el2 = el3;
-      }
+  /**
+   * Sinusoidal easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInSine(t, b, c, d) {
+    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
+  }
 
-      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
-        attr = attrs.item(j);
-        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
-          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
-          continue;
-        }
+  /**
+   * Sinusoidal easing out
+   * @memberOf fabric.util.ease
+   */
+  function easeOutSine(t, b, c, d) {
+    return c * Math.sin(t / d * (Math.PI / 2)) + b;
+  }
 
-        if (attr.nodeName === 'transform') {
-          currentTrans = attr.nodeValue + ' ' + currentTrans;
-        }
-        else {
-          el2.setAttribute(attr.nodeName, attr.nodeValue);
-        }
-      }
+  /**
+   * Sinusoidal easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutSine(t, b, c, d) {
+    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
+  }
 
-      el2.setAttribute('transform', currentTrans);
-      el2.setAttribute('instantiated_by_use', '1');
-      el2.removeAttribute('id');
-      parentNode = el.parentNode;
-      parentNode.replaceChild(el2, el);
-      // some browsers do not shorten nodelist after replaceChild (IE8)
-      if (nodelist.length === oldLength) {
-        i++;
-      }
-    }
+  /**
+   * Exponential easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInExpo(t, b, c, d) {
+    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
   }
 
-  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
-  // matches, e.g.: +14.56e-12, etc.
-  var reViewBoxAttrValue = new RegExp(
-    '^' +
-    '\\s*(' + fabric.reNum + '+)\\s*,?' +
-    '\\s*(' + fabric.reNum + '+)\\s*,?' +
-    '\\s*(' + fabric.reNum + '+)\\s*,?' +
-    '\\s*(' + fabric.reNum + '+)\\s*' +
-    '$'
-  );
+  /**
+   * Exponential easing out
+   * @memberOf fabric.util.ease
+   */
+  function easeOutExpo(t, b, c, d) {
+    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
+  }
 
   /**
-   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
+   * Exponential easing in and out
+   * @memberOf fabric.util.ease
    */
-  function applyViewboxTransform(element) {
-    if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {
-      return {};
+  function easeInOutExpo(t, b, c, d) {
+    if (t === 0) {
+      return b;
     }
-    var viewBoxAttr = element.getAttribute('viewBox'),
-        scaleX = 1,
-        scaleY = 1,
-        minX = 0,
-        minY = 0,
-        viewBoxWidth, viewBoxHeight, matrix, el,
-        widthAttr = element.getAttribute('width'),
-        heightAttr = element.getAttribute('height'),
-        x = element.getAttribute('x') || 0,
-        y = element.getAttribute('y') || 0,
-        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
-        missingViewBox = (!viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
-        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
-        toBeParsed = missingViewBox && missingDimAttr,
-        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;
+    if (t === d) {
+      return b + c;
+    }
+    t /= d / 2;
+    if (t < 1) {
+      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
+    }
+    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
+  }
 
-    parsedDim.width = 0;
-    parsedDim.height = 0;
-    parsedDim.toBeParsed = toBeParsed;
+  /**
+   * Circular easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInCirc(t, b, c, d) {
+    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
+  }
 
-    if (missingViewBox) {
-      if (((x || y) && element.parentNode && element.parentNode.nodeName !== '#document')) {
-        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
-        matrix = (element.getAttribute('transform') || '') + translateMatrix;
-        element.setAttribute('transform', matrix);
-        element.removeAttribute('x');
-        element.removeAttribute('y');
-      }
-    }
+  /**
+   * Circular easing out
+   * @memberOf fabric.util.ease
+   */
+  function easeOutCirc(t, b, c, d) {
+    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
+  }
 
-    if (toBeParsed) {
-      return parsedDim;
+  /**
+   * Circular easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutCirc(t, b, c, d) {
+    t /= d / 2;
+    if (t < 1) {
+      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
     }
+    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
+  }
 
-    if (missingViewBox) {
-      parsedDim.width = parseUnit(widthAttr);
-      parsedDim.height = parseUnit(heightAttr);
-      // set a transform for elements that have x y and are inner(only) SVGs
-      return parsedDim;
+  /**
+   * Elastic easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInElastic(t, b, c, d) {
+    var s = 1.70158, p = 0, a = c;
+    if (t === 0) {
+      return b;
     }
-    minX = -parseFloat(viewBoxAttr[1]);
-    minY = -parseFloat(viewBoxAttr[2]);
-    viewBoxWidth = parseFloat(viewBoxAttr[3]);
-    viewBoxHeight = parseFloat(viewBoxAttr[4]);
-    parsedDim.minX = minX;
-    parsedDim.minY = minY;
-    parsedDim.viewBoxWidth = viewBoxWidth;
-    parsedDim.viewBoxHeight = viewBoxHeight;
-    if (!missingDimAttr) {
-      parsedDim.width = parseUnit(widthAttr);
-      parsedDim.height = parseUnit(heightAttr);
-      scaleX = parsedDim.width / viewBoxWidth;
-      scaleY = parsedDim.height / viewBoxHeight;
+    t /= d;
+    if (t === 1) {
+      return b + c;
     }
-    else {
-      parsedDim.width = viewBoxWidth;
-      parsedDim.height = viewBoxHeight;
+    if (!p) {
+      p = d * 0.3;
     }
+    var opts = normalize(a, c, p, s);
+    return -elastic(opts, t, d) + b;
+  }
 
-    // default is to preserve aspect ratio
-    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
-    if (preserveAspectRatio.alignX !== 'none') {
-      //translate all container for the effect of Mid, Min, Max
-      if (preserveAspectRatio.meetOrSlice === 'meet') {
-        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
-        // calculate additional translation to move the viewbox
-      }
-      if (preserveAspectRatio.meetOrSlice === 'slice') {
-        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
-        // calculate additional translation to move the viewbox
-      }
-      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
-      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
-      if (preserveAspectRatio.alignX === 'Mid') {
-        widthDiff /= 2;
-      }
-      if (preserveAspectRatio.alignY === 'Mid') {
-        heightDiff /= 2;
-      }
-      if (preserveAspectRatio.alignX === 'Min') {
-        widthDiff = 0;
-      }
-      if (preserveAspectRatio.alignY === 'Min') {
-        heightDiff = 0;
-      }
+  /**
+   * Elastic easing out
+   * @memberOf fabric.util.ease
+   */
+  function easeOutElastic(t, b, c, d) {
+    var s = 1.70158, p = 0, a = c;
+    if (t === 0) {
+      return b;
     }
-
-    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
-      return parsedDim;
+    t /= d;
+    if (t === 1) {
+      return b + c;
     }
-    if ((x || y) && element.parentNode.nodeName !== '#document') {
-      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
+    if (!p) {
+      p = d * 0.3;
     }
+    var opts = normalize(a, c, p, s);
+    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
+  }
 
-    matrix = translateMatrix + ' matrix(' + scaleX +
-                  ' 0' +
-                  ' 0 ' +
-                  scaleY + ' ' +
-                  (minX * scaleX + widthDiff) + ' ' +
-                  (minY * scaleY + heightDiff) + ') ';
-    // seems unused.
-    // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
-    if (element.nodeName === 'svg') {
-      el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
-      // element.firstChild != null
-      while (element.firstChild) {
-        el.appendChild(element.firstChild);
-      }
-      element.appendChild(el);
+  /**
+   * Elastic easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutElastic(t, b, c, d) {
+    var s = 1.70158, p = 0, a = c;
+    if (t === 0) {
+      return b;
     }
-    else {
-      el = element;
-      el.removeAttribute('x');
-      el.removeAttribute('y');
-      matrix = el.getAttribute('transform') + matrix;
+    t /= d / 2;
+    if (t === 2) {
+      return b + c;
     }
-    el.setAttribute('transform', matrix);
-    return parsedDim;
+    if (!p) {
+      p = d * (0.3 * 1.5);
+    }
+    var opts = normalize(a, c, p, s);
+    if (t < 1) {
+      return -0.5 * elastic(opts, t, d) + b;
+    }
+    return opts.a * Math.pow(2, -10 * (t -= 1)) *
+      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
   }
 
-  function hasAncestorWithNodeName(element, nodeName) {
-    while (element && (element = element.parentNode)) {
-      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
-        && !element.getAttribute('instantiated_by_use')) {
-        return true;
-      }
+  /**
+   * Backwards easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInBack(t, b, c, d, s) {
+    if (s === undefined) {
+      s = 1.70158;
     }
-    return false;
+    return c * (t /= d) * t * ((s + 1) * t - s) + b;
   }
 
   /**
-   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
-   * @static
-   * @function
-   * @memberOf fabric
-   * @param {SVGDocument} doc SVG document to parse
-   * @param {Function} callback Callback to call when parsing is finished;
-   * It's being passed an array of elements (parsed from a document).
-   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
-   * @param {Object} [parsingOptions] options for parsing document
-   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
+   * Backwards easing out
+   * @memberOf fabric.util.ease
    */
-  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
-    if (!doc) {
-      return;
+  function easeOutBack(t, b, c, d, s) {
+    if (s === undefined) {
+      s = 1.70158;
     }
+    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
+  }
 
-    parseUseDirectives(doc);
+  /**
+   * Backwards easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutBack(t, b, c, d, s) {
+    if (s === undefined) {
+      s = 1.70158;
+    }
+    t /= d / 2;
+    if (t < 1) {
+      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
+    }
+    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
+  }
 
-    var svgUid =  fabric.Object.__uid++, i, len,
-        options = applyViewboxTransform(doc),
-        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
-    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
-    options.svgUid = svgUid;
+  /**
+   * Bouncing easing in
+   * @memberOf fabric.util.ease
+   */
+  function easeInBounce(t, b, c, d) {
+    return c - easeOutBounce (d - t, 0, c, d) + b;
+  }
 
-    if (descendants.length === 0 && fabric.isLikelyNode) {
-      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
-      // https://github.com/ajaxorg/node-o3-xml/issues/21
-      descendants = doc.selectNodes('//*[name(.)!="svg"]');
-      var arr = [];
-      for (i = 0, len = descendants.length; i < len; i++) {
-        arr[i] = descendants[i];
-      }
-      descendants = arr;
+  /**
+   * Bouncing easing out
+   * @memberOf fabric.util.ease
+   */
+  function easeOutBounce(t, b, c, d) {
+    if ((t /= d) < (1 / 2.75)) {
+      return c * (7.5625 * t * t) + b;
     }
-
-    var elements = descendants.filter(function(el) {
-      applyViewboxTransform(el);
-      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
-            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
-    });
-    if (!elements || (elements && !elements.length)) {
-      callback && callback([], {});
-      return;
+    else if (t < (2 / 2.75)) {
+      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
     }
-    var clipPaths = { };
-    descendants.filter(function(el) {
-      return el.nodeName.replace('svg:', '') === 'clipPath';
-    }).forEach(function(el) {
-      var id = el.getAttribute('id');
-      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
-        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
-      });
-    });
-    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
-    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
-    fabric.clipPaths[svgUid] = clipPaths;
-    // Precedence of rules:   style > class > attribute
-    fabric.parseElements(elements, function(instances, elements) {
-      if (callback) {
-        callback(instances, options, elements, descendants);
-        delete fabric.gradientDefs[svgUid];
-        delete fabric.cssRules[svgUid];
-        delete fabric.clipPaths[svgUid];
-      }
-    }, clone(options), reviver, parsingOptions);
-  };
-
-  function recursivelyParseGradientsXlink(doc, gradient) {
-    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
-        xlinkAttr = 'xlink:href',
-        xLink = gradient.getAttribute(xlinkAttr).substr(1),
-        referencedGradient = elementById(doc, xLink);
-    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
-      recursivelyParseGradientsXlink(doc, referencedGradient);
+    else if (t < (2.5 / 2.75)) {
+      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
     }
-    gradientsAttrs.forEach(function(attr) {
-      if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
-        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
-      }
-    });
-    if (!gradient.children.length) {
-      var referenceClone = referencedGradient.cloneNode(true);
-      while (referenceClone.firstChild) {
-        gradient.appendChild(referenceClone.firstChild);
-      }
+    else {
+      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
     }
-    gradient.removeAttribute(xlinkAttr);
   }
 
-  var reFontDeclaration = new RegExp(
-    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
-    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
-      fabric.reNum +
-    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');
-
-  extend(fabric, {
-    /**
-     * Parses a short font declaration, building adding its properties to a style object
-     * @static
-     * @function
-     * @memberOf fabric
-     * @param {String} value font declaration
-     * @param {Object} oStyle definition
-     */
-    parseFontDeclaration: function(value, oStyle) {
-      var match = value.match(reFontDeclaration);
-
-      if (!match) {
-        return;
-      }
-      var fontStyle = match[1],
-          // font variant is not used
-          // fontVariant = match[2],
-          fontWeight = match[3],
-          fontSize = match[4],
-          lineHeight = match[5],
-          fontFamily = match[6];
+  /**
+   * Bouncing easing in and out
+   * @memberOf fabric.util.ease
+   */
+  function easeInOutBounce(t, b, c, d) {
+    if (t < d / 2) {
+      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
+    }
+    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
+  }
 
-      if (fontStyle) {
-        oStyle.fontStyle = fontStyle;
-      }
-      if (fontWeight) {
-        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
-      }
-      if (fontSize) {
-        oStyle.fontSize = parseUnit(fontSize);
-      }
-      if (fontFamily) {
-        oStyle.fontFamily = fontFamily;
-      }
-      if (lineHeight) {
-        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
-      }
-    },
+  /**
+   * Easing functions
+   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
+   * @namespace fabric.util.ease
+   */
+  fabric.util.ease = {
 
     /**
-     * Parses an SVG document, returning all of the gradient declarations found in it
-     * @static
-     * @function
-     * @memberOf fabric
-     * @param {SVGDocument} doc SVG document to parse
-     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
+     * Quadratic easing in
+     * @memberOf fabric.util.ease
      */
-    getGradientDefs: function(doc) {
-      var tagArray = [
-            'linearGradient',
-            'radialGradient',
-            'svg:linearGradient',
-            'svg:radialGradient'],
-          elList = _getMultipleNodes(doc, tagArray),
-          el, j = 0, gradientDefs = { };
-      j = elList.length;
-      while (j--) {
-        el = elList[j];
-        if (el.getAttribute('xlink:href')) {
-          recursivelyParseGradientsXlink(doc, el);
-        }
-        gradientDefs[el.getAttribute('id')] = el;
-      }
-      return gradientDefs;
+    easeInQuad: function(t, b, c, d) {
+      return c * (t /= d) * t + b;
     },
 
     /**
-     * Returns an object of attributes' name/value, given element and an array of attribute names;
-     * Parses parent "g" nodes recursively upwards.
-     * @static
-     * @memberOf fabric
-     * @param {DOMElement} element Element to parse
-     * @param {Array} attributes Array of attributes to parse
-     * @return {Object} object containing parsed attributes' names/values
+     * Quadratic easing out
+     * @memberOf fabric.util.ease
      */
-    parseAttributes: function(element, attributes, svgUid) {
-
-      if (!element) {
-        return;
-      }
-
-      var value,
-          parentAttributes = { },
-          fontSize, parentFontSize;
-
-      if (typeof svgUid === 'undefined') {
-        svgUid = element.getAttribute('svgUid');
-      }
-      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
-      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
-        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
-      }
-
-      var ownAttributes = attributes.reduce(function(memo, attr) {
-        value = element.getAttribute(attr);
-        if (value) { // eslint-disable-line
-          memo[attr] = value;
-        }
-        return memo;
-      }, { });
-      // add values parsed from style, which take precedence over attributes
-      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
-      var cssAttrs = extend(
-        getGlobalStylesForElement(element, svgUid),
-        fabric.parseStyleAttribute(element)
-      );
-      ownAttributes = extend(
-        ownAttributes,
-        cssAttrs
-      );
-      if (cssAttrs[cPath]) {
-        element.setAttribute(cPath, cssAttrs[cPath]);
-      }
-      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
-      if (ownAttributes[fSize]) {
-        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
-        ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
-      }
-
-      var normalizedAttr, normalizedValue, normalizedStyle = {};
-      for (var attr in ownAttributes) {
-        normalizedAttr = normalizeAttr(attr);
-        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
-        normalizedStyle[normalizedAttr] = normalizedValue;
-      }
-      if (normalizedStyle && normalizedStyle.font) {
-        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
-      }
-      var mergedAttrs = extend(parentAttributes, normalizedStyle);
-      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
+    easeOutQuad: function(t, b, c, d) {
+      return -c * (t /= d) * (t - 2) + b;
     },
 
     /**
-     * Transforms an array of svg elements to corresponding fabric.* instances
-     * @static
-     * @memberOf fabric
-     * @param {Array} elements Array of elements to parse
-     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
-     * @param {Object} [options] Options object
-     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
+     * Quadratic easing in and out
+     * @memberOf fabric.util.ease
      */
-    parseElements: function(elements, callback, options, reviver, parsingOptions) {
-      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
+    easeInOutQuad: function(t, b, c, d) {
+      t /= (d / 2);
+      if (t < 1) {
+        return c / 2 * t * t + b;
+      }
+      return -c / 2 * ((--t) * (t - 2) - 1) + b;
     },
 
     /**
-     * Parses "style" attribute, retuning an object with values
-     * @static
-     * @memberOf fabric
-     * @param {SVGElement} element Element to parse
-     * @return {Object} Objects with values parsed from style attribute of an element
+     * Cubic easing in
+     * @memberOf fabric.util.ease
      */
-    parseStyleAttribute: function(element) {
-      var oStyle = { },
-          style = element.getAttribute('style');
-
-      if (!style) {
-        return oStyle;
-      }
-
-      if (typeof style === 'string') {
-        parseStyleString(style, oStyle);
-      }
-      else {
-        parseStyleObject(style, oStyle);
-      }
-
-      return oStyle;
+    easeInCubic: function(t, b, c, d) {
+      return c * (t /= d) * t * t + b;
     },
 
-    /**
-     * Parses "points" attribute, returning an array of values
-     * @static
-     * @memberOf fabric
-     * @param {String} points points attribute string
-     * @return {Array} array of points
-     */
-    parsePointsAttribute: function(points) {
+    easeOutCubic: easeOutCubic,
+    easeInOutCubic: easeInOutCubic,
+    easeInQuart: easeInQuart,
+    easeOutQuart: easeOutQuart,
+    easeInOutQuart: easeInOutQuart,
+    easeInQuint: easeInQuint,
+    easeOutQuint: easeOutQuint,
+    easeInOutQuint: easeInOutQuint,
+    easeInSine: easeInSine,
+    easeOutSine: easeOutSine,
+    easeInOutSine: easeInOutSine,
+    easeInExpo: easeInExpo,
+    easeOutExpo: easeOutExpo,
+    easeInOutExpo: easeInOutExpo,
+    easeInCirc: easeInCirc,
+    easeOutCirc: easeOutCirc,
+    easeInOutCirc: easeInOutCirc,
+    easeInElastic: easeInElastic,
+    easeOutElastic: easeOutElastic,
+    easeInOutElastic: easeInOutElastic,
+    easeInBack: easeInBack,
+    easeOutBack: easeOutBack,
+    easeInOutBack: easeInOutBack,
+    easeInBounce: easeInBounce,
+    easeOutBounce: easeOutBounce,
+    easeInOutBounce: easeInOutBounce
+  };
 
-      // points attribute is required and must not be empty
-      if (!points) {
-        return null;
-      }
+})();
 
-      // replace commas with whitespace and remove bookending whitespace
-      points = points.replace(/,/g, ' ').trim();
 
-      points = points.split(/\s+/);
-      var parsedPoints = [], i, len;
+(function(global) {
 
-      for (i = 0, len = points.length; i < len; i += 2) {
-        parsedPoints.push({
-          x: parseFloat(points[i]),
-          y: parseFloat(points[i + 1])
-        });
-      }
+  'use strict';
 
-      // odd number of points is an error
-      // if (parsedPoints.length % 2 !== 0) {
-      //   return null;
-      // }
+  /**
+   * @name fabric
+   * @namespace
+   */
 
-      return parsedPoints;
-    },
+  var fabric = global.fabric || (global.fabric = { }),
+      extend = fabric.util.object.extend,
+      clone = fabric.util.object.clone,
+      toFixed = fabric.util.toFixed,
+      parseUnit = fabric.util.parseUnit,
+      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
 
-    /**
-     * Returns CSS rules for a given SVG document
-     * @static
-     * @function
-     * @memberOf fabric
-     * @param {SVGDocument} doc SVG document to parse
-     * @return {Object} CSS rules of this document
-     */
-    getCSSRules: function(doc) {
-      var styles = doc.getElementsByTagName('style'), i, len,
-          allRules = { }, rules;
-
-      // very crude parsing of style contents
-      for (i = 0, len = styles.length; i < len; i++) {
-        var styleContents = styles[i].textContent;
-
-        // remove comments
-        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
-        if (styleContents.trim() === '') {
-          continue;
-        }
-        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
-        rules = rules.map(function(rule) { return rule.trim(); });
-        // eslint-disable-next-line no-loop-func
-        rules.forEach(function(rule) {
-
-          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
-              ruleObj = { }, declaration = match[2].trim(),
-              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
-
-          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
-            var pair = propertyValuePairs[i].split(/\s*:\s*/),
-                property = pair[0],
-                value = pair[1];
-            ruleObj[property] = value;
-          }
-          rule = match[1];
-          rule.split(',').forEach(function(_rule) {
-            _rule = _rule.replace(/^svg/i, '').trim();
-            if (_rule === '') {
-              return;
-            }
-            if (allRules[_rule]) {
-              fabric.util.object.extend(allRules[_rule], ruleObj);
-            }
-            else {
-              allRules[_rule] = fabric.util.object.clone(ruleObj);
-            }
-          });
-        });
-      }
-      return allRules;
-    },
+      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
+        'image', 'text'],
+      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
+      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
+      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],
 
-    /**
-     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
-     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
-     * @memberOf fabric
-     * @param {String} url
-     * @param {Function} callback
-     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
-     * @param {Object} [options] Object containing options for parsing
-     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
-     */
-    loadSVGFromURL: function(url, callback, reviver, options) {
+      attributesMap = {
+        cx:                   'left',
+        x:                    'left',
+        r:                    'radius',
+        cy:                   'top',
+        y:                    'top',
+        display:              'visible',
+        visibility:           'visible',
+        transform:            'transformMatrix',
+        'fill-opacity':       'fillOpacity',
+        'fill-rule':          'fillRule',
+        'font-family':        'fontFamily',
+        'font-size':          'fontSize',
+        'font-style':         'fontStyle',
+        'font-weight':        'fontWeight',
+        'letter-spacing':     'charSpacing',
+        'paint-order':        'paintFirst',
+        'stroke-dasharray':   'strokeDashArray',
+        'stroke-dashoffset':  'strokeDashOffset',
+        'stroke-linecap':     'strokeLineCap',
+        'stroke-linejoin':    'strokeLineJoin',
+        'stroke-miterlimit':  'strokeMiterLimit',
+        'stroke-opacity':     'strokeOpacity',
+        'stroke-width':       'strokeWidth',
+        'text-decoration':    'textDecoration',
+        'text-anchor':        'textAnchor',
+        opacity:              'opacity',
+        'clip-path':          'clipPath',
+        'clip-rule':          'clipRule',
+        'vector-effect':      'strokeUniform',
+        'image-rendering':    'imageSmoothing',
+      },
 
-      url = url.replace(/^\n\s*/, '').trim();
-      new fabric.util.request(url, {
-        method: 'get',
-        onComplete: onComplete
-      });
+      colorAttributes = {
+        stroke: 'strokeOpacity',
+        fill:   'fillOpacity'
+      },
 
-      function onComplete(r) {
+      fSize = 'font-size', cPath = 'clip-path';
 
-        var xml = r.responseXML;
-        if (!xml || !xml.documentElement) {
-          callback && callback(null);
-          return false;
-        }
+  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
+  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
+  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
+  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);
 
-        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
-          callback && callback(results, _options, elements, allElements);
-        }, reviver, options);
-      }
-    },
+  fabric.cssRules = { };
+  fabric.gradientDefs = { };
+  fabric.clipPaths = { };
 
-    /**
-     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
-     * @memberOf fabric
-     * @param {String} string
-     * @param {Function} callback
-     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
-     * @param {Object} [options] Object containing options for parsing
-     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
-     */
-    loadSVGFromString: function(string, callback, reviver, options) {
-      var parser = new fabric.window.DOMParser(),
-          doc = parser.parseFromString(string.trim(), 'text/xml');
-      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
-        callback(results, _options, elements, allElements);
-      }, reviver, options);
+  function normalizeAttr(attr) {
+    // transform attribute names
+    if (attr in attributesMap) {
+      return attributesMap[attr];
     }
-  });
-
-})(typeof exports !== 'undefined' ? exports : this);
-
-
-fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
-  this.elements = elements;
-  this.callback = callback;
-  this.options = options;
-  this.reviver = reviver;
-  this.svgUid = (options && options.svgUid) || 0;
-  this.parsingOptions = parsingOptions;
-  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
-  this.doc = doc;
-};
-
-(function(proto) {
-  proto.parse = function() {
-    this.instances = new Array(this.elements.length);
-    this.numElements = this.elements.length;
-    this.createObjects();
-  };
-
-  proto.createObjects = function() {
-    var _this = this;
-    this.elements.forEach(function(element, i) {
-      element.setAttribute('svgUid', _this.svgUid);
-      _this.createObject(element, i);
-    });
-  };
+    return attr;
+  }
 
-  proto.findTag = function(el) {
-    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
-  };
+  function normalizeValue(attr, value, parentAttributes, fontSize) {
+    var isArray = Object.prototype.toString.call(value) === '[object Array]',
+        parsed;
 
-  proto.createObject = function(el, index) {
-    var klass = this.findTag(el);
-    if (klass && klass.fromElement) {
-      try {
-        klass.fromElement(el, this.createCallback(index, el), this.options);
+    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
+      value = '';
+    }
+    else if (attr === 'strokeUniform') {
+      return (value === 'non-scaling-stroke');
+    }
+    else if (attr === 'strokeDashArray') {
+      if (value === 'none') {
+        value = null;
       }
-      catch (err) {
-        fabric.log(err);
+      else {
+        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
       }
     }
-    else {
-      this.checkIfDone();
+    else if (attr === 'transformMatrix') {
+      if (parentAttributes && parentAttributes.transformMatrix) {
+        value = multiplyTransformMatrices(
+          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
+      }
+      else {
+        value = fabric.parseTransformAttribute(value);
+      }
     }
-  };
-
-  proto.createCallback = function(index, el) {
-    var _this = this;
-    return function(obj) {
-      var _options;
-      _this.resolveGradient(obj, el, 'fill');
-      _this.resolveGradient(obj, el, 'stroke');
-      if (obj instanceof fabric.Image && obj._originalElement) {
-        _options = obj.parsePreserveAspectRatioAttribute(el);
+    else if (attr === 'visible') {
+      value = value !== 'none' && value !== 'hidden';
+      // display=none on parent element always takes precedence over child element
+      if (parentAttributes && parentAttributes.visible === false) {
+        value = false;
       }
-      obj._removeTransformMatrix(_options);
-      _this.resolveClipPath(obj, el);
-      _this.reviver && _this.reviver(el, obj);
-      _this.instances[index] = obj;
-      _this.checkIfDone();
-    };
-  };
-
-  proto.extractPropertyDefinition = function(obj, property, storage) {
-    var value = obj[property], regex = this.regexUrl;
-    if (!regex.test(value)) {
-      return;
     }
-    regex.lastIndex = 0;
-    var id = regex.exec(value)[1];
-    regex.lastIndex = 0;
-    return fabric[storage][this.svgUid][id];
-  };
-
-  proto.resolveGradient = function(obj, el, property) {
-    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
-    if (gradientDef) {
-      var opacityAttr = el.getAttribute(property + '-opacity');
-      var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
-      obj.set(property, gradient);
+    else if (attr === 'opacity') {
+      value = parseFloat(value);
+      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
+        value *= parentAttributes.opacity;
+      }
     }
-  };
-
-  proto.createClipPathCallback = function(obj, container) {
-    return function(_newObj) {
-      _newObj._removeTransformMatrix();
-      _newObj.fillRule = _newObj.clipRule;
-      container.push(_newObj);
-    };
-  };
-
-  proto.resolveClipPath = function(obj, usingElement) {
-    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
-        element, klass, objTransformInv, container, gTransform, options;
-    if (clipPath) {
-      container = [];
-      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
-      // move the clipPath tag as sibling to the real element that is using it
-      var clipPathTag = clipPath[0].parentNode;
-      var clipPathOwner = usingElement;
-      while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
-        clipPathOwner = clipPathOwner.parentNode;
-      }
-      clipPathOwner.parentNode.appendChild(clipPathTag);
-      for (var i = 0; i < clipPath.length; i++) {
-        element = clipPath[i];
-        klass = this.findTag(element);
-        klass.fromElement(
-          element,
-          this.createClipPathCallback(obj, container),
-          this.options
-        );
-      }
-      if (container.length === 1) {
-        clipPath = container[0];
-      }
-      else {
-        clipPath = new fabric.Group(container);
+    else if (attr === 'textAnchor' /* text-anchor */) {
+      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
+    }
+    else if (attr === 'charSpacing') {
+      // parseUnit returns px and we convert it to em
+      parsed = parseUnit(value, fontSize) / fontSize * 1000;
+    }
+    else if (attr === 'paintFirst') {
+      var fillIndex = value.indexOf('fill');
+      var strokeIndex = value.indexOf('stroke');
+      var value = 'fill';
+      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
+        value = 'stroke';
       }
-      gTransform = fabric.util.multiplyTransformMatrices(
-        objTransformInv,
-        clipPath.calcTransformMatrix()
-      );
-      if (clipPath.clipPath) {
-        this.resolveClipPath(clipPath, clipPathOwner);
+      else if (fillIndex === -1 && strokeIndex > -1) {
+        value = 'stroke';
       }
-      var options = fabric.util.qrDecompose(gTransform);
-      clipPath.flipX = false;
-      clipPath.flipY = false;
-      clipPath.set('scaleX', options.scaleX);
-      clipPath.set('scaleY', options.scaleY);
-      clipPath.angle = options.angle;
-      clipPath.skewX = options.skewX;
-      clipPath.skewY = 0;
-      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
-      obj.clipPath = clipPath;
+    }
+    else if (attr === 'href' || attr === 'xlink:href' || attr === 'font') {
+      return value;
+    }
+    else if (attr === 'imageSmoothing') {
+      return (value === 'optimizeQuality');
     }
     else {
-      // if clip-path does not resolve to any element, delete the property.
-      delete obj.clipPath;
+      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
     }
-  };
 
-  proto.checkIfDone = function() {
-    if (--this.numElements === 0) {
-      this.instances = this.instances.filter(function(el) {
-        // eslint-disable-next-line no-eq-null, eqeqeq
-        return el != null;
-      });
-      this.callback(this.instances, this.elements);
-    }
-  };
-})(fabric.ElementsParser.prototype);
+    return (!isArray && isNaN(parsed) ? value : parsed);
+  }
 
+  /**
+    * @private
+    */
+  function getSvgRegex(arr) {
+    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
+  }
 
-(function(global) {
+  /**
+   * @private
+   * @param {Object} attributes Array of attributes to parse
+   */
+  function _setStrokeFillOpacity(attributes) {
+    for (var attr in colorAttributes) {
 
-  'use strict';
+      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
+        continue;
+      }
 
-  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
+      if (typeof attributes[attr] === 'undefined') {
+        if (!fabric.Object.prototype[attr]) {
+          continue;
+        }
+        attributes[attr] = fabric.Object.prototype[attr];
+      }
 
-  var fabric = global.fabric || (global.fabric = { });
+      if (attributes[attr].indexOf('url(') === 0) {
+        continue;
+      }
 
-  if (fabric.Point) {
-    fabric.warn('fabric.Point is already defined');
-    return;
+      var color = new fabric.Color(attributes[attr]);
+      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
+    }
+    return attributes;
   }
 
-  fabric.Point = Point;
+  /**
+   * @private
+   */
+  function _getMultipleNodes(doc, nodeNames) {
+    var nodeName, nodeArray = [], nodeList, i, len;
+    for (i = 0, len = nodeNames.length; i < len; i++) {
+      nodeName = nodeNames[i];
+      nodeList = doc.getElementsByTagName(nodeName);
+      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
+    }
+    return nodeArray;
+  }
 
   /**
-   * Point class
-   * @class fabric.Point
+   * Parses "transform" attribute, returning an array of values
+   * @static
+   * @function
    * @memberOf fabric
-   * @constructor
-   * @param {Number} x
-   * @param {Number} y
-   * @return {fabric.Point} thisArg
+   * @param {String} attributeValue String containing attribute value
+   * @return {Array} Array of 6 elements representing transformation matrix
    */
-  function Point(x, y) {
-    this.x = x;
-    this.y = y;
-  }
+  fabric.parseTransformAttribute = (function() {
+    function rotateMatrix(matrix, args) {
+      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
+          x = 0, y = 0;
+      if (args.length === 3) {
+        x = args[1];
+        y = args[2];
+      }
 
-  Point.prototype = /** @lends fabric.Point.prototype */ {
+      matrix[0] = cos;
+      matrix[1] = sin;
+      matrix[2] = -sin;
+      matrix[3] = cos;
+      matrix[4] = x - (cos * x - sin * y);
+      matrix[5] = y - (sin * x + cos * y);
+    }
 
-    type: 'point',
+    function scaleMatrix(matrix, args) {
+      var multiplierX = args[0],
+          multiplierY = (args.length === 2) ? args[1] : args[0];
 
-    constructor: Point,
+      matrix[0] = multiplierX;
+      matrix[3] = multiplierY;
+    }
 
-    /**
-     * Adds another point to this one and returns another one
-     * @param {fabric.Point} that
-     * @return {fabric.Point} new Point instance with added values
-     */
-    add: function (that) {
-      return new Point(this.x + that.x, this.y + that.y);
-    },
+    function skewMatrix(matrix, args, pos) {
+      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
+    }
 
-    /**
-     * Adds another point to this one
-     * @param {fabric.Point} that
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    addEquals: function (that) {
-      this.x += that.x;
-      this.y += that.y;
-      return this;
-    },
+    function translateMatrix(matrix, args) {
+      matrix[4] = args[0];
+      if (args.length === 2) {
+        matrix[5] = args[1];
+      }
+    }
 
-    /**
-     * Adds value to this point and returns a new one
-     * @param {Number} scalar
-     * @return {fabric.Point} new Point with added value
-     */
-    scalarAdd: function (scalar) {
-      return new Point(this.x + scalar, this.y + scalar);
-    },
+    // identity matrix
+    var iMatrix = fabric.iMatrix,
 
-    /**
-     * Adds value to this point
-     * @param {Number} scalar
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    scalarAddEquals: function (scalar) {
-      this.x += scalar;
-      this.y += scalar;
-      return this;
-    },
+        // == begin transform regexp
+        number = fabric.reNum,
 
-    /**
-     * Subtracts another point from this point and returns a new one
-     * @param {fabric.Point} that
-     * @return {fabric.Point} new Point object with subtracted values
-     */
-    subtract: function (that) {
-      return new Point(this.x - that.x, this.y - that.y);
-    },
+        commaWsp = fabric.commaWsp,
 
-    /**
-     * Subtracts another point from this point
-     * @param {fabric.Point} that
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    subtractEquals: function (that) {
-      this.x -= that.x;
-      this.y -= that.y;
-      return this;
-    },
+        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
 
-    /**
-     * Subtracts value from this point and returns a new one
-     * @param {Number} scalar
-     * @return {fabric.Point}
-     */
-    scalarSubtract: function (scalar) {
-      return new Point(this.x - scalar, this.y - scalar);
-    },
+        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
 
-    /**
-     * Subtracts value from this point
-     * @param {Number} scalar
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    scalarSubtractEquals: function (scalar) {
-      this.x -= scalar;
-      this.y -= scalar;
-      return this;
-    },
+        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
+                    commaWsp + '(' + number + ')' +
+                    commaWsp + '(' + number + '))?\\s*\\))',
 
-    /**
-     * Multiplies this point by a value and returns a new one
-     * TODO: rename in scalarMultiply in 2.0
-     * @param {Number} scalar
-     * @return {fabric.Point}
-     */
-    multiply: function (scalar) {
-      return new Point(this.x * scalar, this.y * scalar);
-    },
+        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
+                    commaWsp + '(' + number + '))?\\s*\\))',
 
-    /**
-     * Multiplies this point by a value
-     * TODO: rename in scalarMultiplyEquals in 2.0
-     * @param {Number} scalar
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    multiplyEquals: function (scalar) {
-      this.x *= scalar;
-      this.y *= scalar;
-      return this;
-    },
+        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
+                    commaWsp + '(' + number + '))?\\s*\\))',
 
-    /**
-     * Divides this point by a value and returns a new one
-     * TODO: rename in scalarDivide in 2.0
-     * @param {Number} scalar
-     * @return {fabric.Point}
-     */
-    divide: function (scalar) {
-      return new Point(this.x / scalar, this.y / scalar);
-    },
+        matrix = '(?:(matrix)\\s*\\(\\s*' +
+                  '(' + number + ')' + commaWsp +
+                  '(' + number + ')' + commaWsp +
+                  '(' + number + ')' + commaWsp +
+                  '(' + number + ')' + commaWsp +
+                  '(' + number + ')' + commaWsp +
+                  '(' + number + ')' +
+                  '\\s*\\))',
 
-    /**
-     * Divides this point by a value
-     * TODO: rename in scalarDivideEquals in 2.0
-     * @param {Number} scalar
-     * @return {fabric.Point} thisArg
-     * @chainable
-     */
-    divideEquals: function (scalar) {
-      this.x /= scalar;
-      this.y /= scalar;
-      return this;
-    },
+        transform = '(?:' +
+                    matrix + '|' +
+                    translate + '|' +
+                    scale + '|' +
+                    rotate + '|' +
+                    skewX + '|' +
+                    skewY +
+                    ')',
 
-    /**
-     * Returns true if this point is equal to another one
-     * @param {fabric.Point} that
-     * @return {Boolean}
-     */
-    eq: function (that) {
-      return (this.x === that.x && this.y === that.y);
-    },
+        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',
 
-    /**
-     * Returns true if this point is less than another one
-     * @param {fabric.Point} that
-     * @return {Boolean}
-     */
-    lt: function (that) {
-      return (this.x < that.x && this.y < that.y);
-    },
+        transformList = '^\\s*(?:' + transforms + '?)\\s*$',
 
-    /**
-     * Returns true if this point is less than or equal to another one
-     * @param {fabric.Point} that
-     * @return {Boolean}
-     */
-    lte: function (that) {
-      return (this.x <= that.x && this.y <= that.y);
-    },
+        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
+        reTransformList = new RegExp(transformList),
+        // == end transform regexp
 
-    /**
+        reTransform = new RegExp(transform, 'g');
 
-     * Returns true if this point is greater another one
-     * @param {fabric.Point} that
-     * @return {Boolean}
-     */
-    gt: function (that) {
-      return (this.x > that.x && this.y > that.y);
-    },
+    return function(attributeValue) {
 
-    /**
-     * Returns true if this point is greater than or equal to another one
-     * @param {fabric.Point} that
-     * @return {Boolean}
-     */
-    gte: function (that) {
-      return (this.x >= that.x && this.y >= that.y);
-    },
+      // start with identity matrix
+      var matrix = iMatrix.concat(),
+          matrices = [];
 
-    /**
-     * Returns new point which is the result of linear interpolation with this one and another one
-     * @param {fabric.Point} that
-     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
-     * @return {fabric.Point}
-     */
-    lerp: function (that, t) {
-      if (typeof t === 'undefined') {
-        t = 0.5;
+      // return if no argument was given or
+      // an argument does not match transform attribute regexp
+      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
+        return matrix;
       }
-      t = Math.max(Math.min(1, t), 0);
-      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
-    },
 
-    /**
-     * Returns distance from this point and another one
-     * @param {fabric.Point} that
-     * @return {Number}
-     */
-    distanceFrom: function (that) {
-      var dx = this.x - that.x,
-          dy = this.y - that.y;
-      return Math.sqrt(dx * dx + dy * dy);
-    },
+      attributeValue.replace(reTransform, function(match) {
 
-    /**
-     * Returns the point between this point and another one
-     * @param {fabric.Point} that
-     * @return {fabric.Point}
-     */
-    midPointFrom: function (that) {
-      return this.lerp(that);
-    },
+        var m = new RegExp(transform).exec(match).filter(function (match) {
+              // match !== '' && match != null
+              return (!!match);
+            }),
+            operation = m[1],
+            args = m.slice(2).map(parseFloat);
 
-    /**
-     * Returns a new point which is the min of this and another one
-     * @param {fabric.Point} that
-     * @return {fabric.Point}
-     */
-    min: function (that) {
-      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
-    },
+        switch (operation) {
+          case 'translate':
+            translateMatrix(matrix, args);
+            break;
+          case 'rotate':
+            args[0] = fabric.util.degreesToRadians(args[0]);
+            rotateMatrix(matrix, args);
+            break;
+          case 'scale':
+            scaleMatrix(matrix, args);
+            break;
+          case 'skewX':
+            skewMatrix(matrix, args, 2);
+            break;
+          case 'skewY':
+            skewMatrix(matrix, args, 1);
+            break;
+          case 'matrix':
+            matrix = args;
+            break;
+        }
 
-    /**
-     * Returns a new point which is the max of this and another one
-     * @param {fabric.Point} that
-     * @return {fabric.Point}
-     */
-    max: function (that) {
-      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
-    },
+        // snapshot current matrix into matrices array
+        matrices.push(matrix.concat());
+        // reset
+        matrix = iMatrix.concat();
+      });
 
-    /**
-     * Returns string representation of this point
-     * @return {String}
-     */
-    toString: function () {
-      return this.x + ',' + this.y;
-    },
+      var combinedMatrix = matrices[0];
+      while (matrices.length > 1) {
+        matrices.shift();
+        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
+      }
+      return combinedMatrix;
+    };
+  })();
 
-    /**
-     * Sets x/y of this point
-     * @param {Number} x
-     * @param {Number} y
-     * @chainable
-     */
-    setXY: function (x, y) {
-      this.x = x;
-      this.y = y;
-      return this;
-    },
+  /**
+   * @private
+   */
+  function parseStyleString(style, oStyle) {
+    var attr, value;
+    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
+      var pair = chunk.split(':');
 
-    /**
-     * Sets x of this point
-     * @param {Number} x
-     * @chainable
-     */
-    setX: function (x) {
-      this.x = x;
-      return this;
-    },
+      attr = pair[0].trim().toLowerCase();
+      value =  pair[1].trim();
 
-    /**
-     * Sets y of this point
-     * @param {Number} y
-     * @chainable
-     */
-    setY: function (y) {
-      this.y = y;
-      return this;
-    },
+      oStyle[attr] = value;
+    });
+  }
 
-    /**
-     * Sets x/y of this point from another point
-     * @param {fabric.Point} that
-     * @chainable
-     */
-    setFromPoint: function (that) {
-      this.x = that.x;
-      this.y = that.y;
-      return this;
-    },
+  /**
+   * @private
+   */
+  function parseStyleObject(style, oStyle) {
+    var attr, value;
+    for (var prop in style) {
+      if (typeof style[prop] === 'undefined') {
+        continue;
+      }
 
-    /**
-     * Swaps x/y of this point and another point
-     * @param {fabric.Point} that
-     */
-    swap: function (that) {
-      var x = this.x,
-          y = this.y;
-      this.x = that.x;
-      this.y = that.y;
-      that.x = x;
-      that.y = y;
-    },
+      attr = prop.toLowerCase();
+      value = style[prop];
 
-    /**
-     * return a cloned instance of the point
-     * @return {fabric.Point}
-     */
-    clone: function () {
-      return new Point(this.x, this.y);
+      oStyle[attr] = value;
     }
-  };
-
-})(typeof exports !== 'undefined' ? exports : this);
-
-
-(function(global) {
-
-  'use strict';
-
-  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
-  var fabric = global.fabric || (global.fabric = { });
-
-  if (fabric.Intersection) {
-    fabric.warn('fabric.Intersection is already defined');
-    return;
   }
 
   /**
-   * Intersection class
-   * @class fabric.Intersection
-   * @memberOf fabric
-   * @constructor
+   * @private
    */
-  function Intersection(status) {
-    this.status = status;
-    this.points = [];
-  }
-
-  fabric.Intersection = Intersection;
-
-  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {
-
-    constructor: Intersection,
-
-    /**
-     * Appends a point to intersection
-     * @param {fabric.Point} point
-     * @return {fabric.Intersection} thisArg
-     * @chainable
-     */
-    appendPoint: function (point) {
-      this.points.push(point);
-      return this;
-    },
-
-    /**
-     * Appends points to intersection
-     * @param {Array} points
-     * @return {fabric.Intersection} thisArg
-     * @chainable
-     */
-    appendPoints: function (points) {
-      this.points = this.points.concat(points);
-      return this;
+  function getGlobalStylesForElement(element, svgUid) {
+    var styles = { };
+    for (var rule in fabric.cssRules[svgUid]) {
+      if (elementMatchesRule(element, rule.split(' '))) {
+        for (var property in fabric.cssRules[svgUid][rule]) {
+          styles[property] = fabric.cssRules[svgUid][rule][property];
+        }
+      }
     }
-  };
+    return styles;
+  }
 
   /**
-   * Checks if one line intersects another
-   * TODO: rename in intersectSegmentSegment
-   * @static
-   * @param {fabric.Point} a1
-   * @param {fabric.Point} a2
-   * @param {fabric.Point} b1
-   * @param {fabric.Point} b2
-   * @return {fabric.Intersection}
+   * @private
    */
-  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
-    var result,
-        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
-        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
-        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
-    if (uB !== 0) {
-      var ua = uaT / uB,
-          ub = ubT / uB;
-      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
-        result = new Intersection('Intersection');
-        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
-      }
-      else {
-        result = new Intersection();
-      }
+  function elementMatchesRule(element, selectors) {
+    var firstMatching, parentMatching = true;
+    //start from rightmost selector.
+    firstMatching = selectorMatches(element, selectors.pop());
+    if (firstMatching && selectors.length) {
+      parentMatching = doesSomeParentMatch(element, selectors);
     }
-    else {
-      if (uaT === 0 || ubT === 0) {
-        result = new Intersection('Coincident');
-      }
-      else {
-        result = new Intersection('Parallel');
+    return firstMatching && parentMatching && (selectors.length === 0);
+  }
+
+  function doesSomeParentMatch(element, selectors) {
+    var selector, parentMatching = true;
+    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
+      if (parentMatching) {
+        selector = selectors.pop();
       }
+      element = element.parentNode;
+      parentMatching = selectorMatches(element, selector);
     }
-    return result;
-  };
+    return selectors.length === 0;
+  }
 
   /**
-   * Checks if line intersects polygon
-   * TODO: rename in intersectSegmentPolygon
-   * fix detection of coincident
-   * @static
-   * @param {fabric.Point} a1
-   * @param {fabric.Point} a2
-   * @param {Array} points
-   * @return {fabric.Intersection}
+   * @private
    */
-  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
-    var result = new Intersection(),
-        length = points.length,
-        b1, b2, inter, i;
-
-    for (i = 0; i < length; i++) {
-      b1 = points[i];
-      b2 = points[(i + 1) % length];
-      inter = Intersection.intersectLineLine(a1, a2, b1, b2);
-
-      result.appendPoints(inter.points);
+  function selectorMatches(element, selector) {
+    var nodeName = element.nodeName,
+        classNames = element.getAttribute('class'),
+        id = element.getAttribute('id'), matcher, i;
+    // i check if a selector matches slicing away part from it.
+    // if i get empty string i should match
+    matcher = new RegExp('^' + nodeName, 'i');
+    selector = selector.replace(matcher, '');
+    if (id && selector.length) {
+      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
+      selector = selector.replace(matcher, '');
     }
-    if (result.points.length > 0) {
-      result.status = 'Intersection';
+    if (classNames && selector.length) {
+      classNames = classNames.split(' ');
+      for (i = classNames.length; i--;) {
+        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
+        selector = selector.replace(matcher, '');
+      }
     }
-    return result;
-  };
+    return selector.length === 0;
+  }
 
   /**
-   * Checks if polygon intersects another polygon
-   * @static
-   * @param {Array} points1
-   * @param {Array} points2
-   * @return {fabric.Intersection}
+   * @private
+   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
    */
-  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
-    var result = new Intersection(),
-        length = points1.length, i;
-
-    for (i = 0; i < length; i++) {
-      var a1 = points1[i],
-          a2 = points1[(i + 1) % length],
-          inter = Intersection.intersectLinePolygon(a1, a2, points2);
-
-      result.appendPoints(inter.points);
+  function elementById(doc, id) {
+    var el;
+    doc.getElementById && (el = doc.getElementById(id));
+    if (el) {
+      return el;
     }
-    if (result.points.length > 0) {
-      result.status = 'Intersection';
+    var node, i, len, nodelist = doc.getElementsByTagName('*');
+    for (i = 0, len = nodelist.length; i < len; i++) {
+      node = nodelist[i];
+      if (id === node.getAttribute('id')) {
+        return node;
+      }
     }
-    return result;
-  };
+  }
 
   /**
-   * Checks if polygon intersects rectangle
-   * @static
-   * @param {Array} points
-   * @param {fabric.Point} r1
-   * @param {fabric.Point} r2
-   * @return {fabric.Intersection}
+   * @private
    */
-  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
-    var min = r1.min(r2),
-        max = r1.max(r2),
-        topRight = new fabric.Point(max.x, min.y),
-        bottomLeft = new fabric.Point(min.x, max.y),
-        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
-        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
-        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
-        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
-        result = new Intersection();
-
-    result.appendPoints(inter1.points);
-    result.appendPoints(inter2.points);
-    result.appendPoints(inter3.points);
-    result.appendPoints(inter4.points);
-
-    if (result.points.length > 0) {
-      result.status = 'Intersection';
-    }
-    return result;
-  };
+  function parseUseDirectives(doc) {
+    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
+    while (nodelist.length && i < nodelist.length) {
+      var el = nodelist[i],
+          xlinkAttribute = el.getAttribute('xlink:href') || el.getAttribute('href');
 
-})(typeof exports !== 'undefined' ? exports : this);
+      if (xlinkAttribute === null) {
+        return;
+      }
 
+      var xlink = xlinkAttribute.substr(1),
+          x = el.getAttribute('x') || 0,
+          y = el.getAttribute('y') || 0,
+          el2 = elementById(doc, xlink).cloneNode(true),
+          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
+          parentNode,
+          oldLength = nodelist.length, attr,
+          j,
+          attrs,
+          len,
+          namespace = fabric.svgNS;
 
-(function(global) {
+      applyViewboxTransform(el2);
+      if (/^svg$/i.test(el2.nodeName)) {
+        var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
+        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
+          attr = attrs.item(j);
+          el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
+        }
+        // el2.firstChild != null
+        while (el2.firstChild) {
+          el3.appendChild(el2.firstChild);
+        }
+        el2 = el3;
+      }
 
-  'use strict';
+      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
+        attr = attrs.item(j);
+        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
+          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
+          continue;
+        }
 
-  var fabric = global.fabric || (global.fabric = { });
+        if (attr.nodeName === 'transform') {
+          currentTrans = attr.nodeValue + ' ' + currentTrans;
+        }
+        else {
+          el2.setAttribute(attr.nodeName, attr.nodeValue);
+        }
+      }
 
-  if (fabric.Color) {
-    fabric.warn('fabric.Color is already defined.');
-    return;
+      el2.setAttribute('transform', currentTrans);
+      el2.setAttribute('instantiated_by_use', '1');
+      el2.removeAttribute('id');
+      parentNode = el.parentNode;
+      parentNode.replaceChild(el2, el);
+      // some browsers do not shorten nodelist after replaceChild (IE8)
+      if (nodelist.length === oldLength) {
+        i++;
+      }
+    }
   }
 
+  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
+  // matches, e.g.: +14.56e-12, etc.
+  var reViewBoxAttrValue = new RegExp(
+    '^' +
+    '\\s*(' + fabric.reNum + '+)\\s*,?' +
+    '\\s*(' + fabric.reNum + '+)\\s*,?' +
+    '\\s*(' + fabric.reNum + '+)\\s*,?' +
+    '\\s*(' + fabric.reNum + '+)\\s*' +
+    '$'
+  );
+
   /**
-   * Color class
-   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
-   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
-   *
-   * @class fabric.Color
-   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
-   * @return {fabric.Color} thisArg
-   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
+   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
    */
-  function Color(color) {
-    if (!color) {
-      this.setSource([0, 0, 0, 1]);
-    }
-    else {
-      this._tryParsingColor(color);
+  function applyViewboxTransform(element) {
+    if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {
+      return {};
     }
-  }
+    var viewBoxAttr = element.getAttribute('viewBox'),
+        scaleX = 1,
+        scaleY = 1,
+        minX = 0,
+        minY = 0,
+        viewBoxWidth, viewBoxHeight, matrix, el,
+        widthAttr = element.getAttribute('width'),
+        heightAttr = element.getAttribute('height'),
+        x = element.getAttribute('x') || 0,
+        y = element.getAttribute('y') || 0,
+        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
+        missingViewBox = (!viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
+        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
+        toBeParsed = missingViewBox && missingDimAttr,
+        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;
 
-  fabric.Color = Color;
+    parsedDim.width = 0;
+    parsedDim.height = 0;
+    parsedDim.toBeParsed = toBeParsed;
 
-  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {
+    if (missingViewBox) {
+      if (((x || y) && element.parentNode && element.parentNode.nodeName !== '#document')) {
+        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
+        matrix = (element.getAttribute('transform') || '') + translateMatrix;
+        element.setAttribute('transform', matrix);
+        element.removeAttribute('x');
+        element.removeAttribute('y');
+      }
+    }
 
-    /**
-     * @private
-     * @param {String|Array} color Color value to parse
-     */
-    _tryParsingColor: function(color) {
-      var source;
+    if (toBeParsed) {
+      return parsedDim;
+    }
 
-      if (color in Color.colorNameMap) {
-        color = Color.colorNameMap[color];
-      }
+    if (missingViewBox) {
+      parsedDim.width = parseUnit(widthAttr);
+      parsedDim.height = parseUnit(heightAttr);
+      // set a transform for elements that have x y and are inner(only) SVGs
+      return parsedDim;
+    }
+    minX = -parseFloat(viewBoxAttr[1]);
+    minY = -parseFloat(viewBoxAttr[2]);
+    viewBoxWidth = parseFloat(viewBoxAttr[3]);
+    viewBoxHeight = parseFloat(viewBoxAttr[4]);
+    parsedDim.minX = minX;
+    parsedDim.minY = minY;
+    parsedDim.viewBoxWidth = viewBoxWidth;
+    parsedDim.viewBoxHeight = viewBoxHeight;
+    if (!missingDimAttr) {
+      parsedDim.width = parseUnit(widthAttr);
+      parsedDim.height = parseUnit(heightAttr);
+      scaleX = parsedDim.width / viewBoxWidth;
+      scaleY = parsedDim.height / viewBoxHeight;
+    }
+    else {
+      parsedDim.width = viewBoxWidth;
+      parsedDim.height = viewBoxHeight;
+    }
 
-      if (color === 'transparent') {
-        source = [255, 255, 255, 0];
+    // default is to preserve aspect ratio
+    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
+    if (preserveAspectRatio.alignX !== 'none') {
+      //translate all container for the effect of Mid, Min, Max
+      if (preserveAspectRatio.meetOrSlice === 'meet') {
+        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
+        // calculate additional translation to move the viewbox
       }
-
-      if (!source) {
-        source = Color.sourceFromHex(color);
+      if (preserveAspectRatio.meetOrSlice === 'slice') {
+        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
+        // calculate additional translation to move the viewbox
       }
-      if (!source) {
-        source = Color.sourceFromRgb(color);
+      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
+      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
+      if (preserveAspectRatio.alignX === 'Mid') {
+        widthDiff /= 2;
       }
-      if (!source) {
-        source = Color.sourceFromHsl(color);
+      if (preserveAspectRatio.alignY === 'Mid') {
+        heightDiff /= 2;
       }
-      if (!source) {
-        //if color is not recognize let's make black as canvas does
-        source = [0, 0, 0, 1];
+      if (preserveAspectRatio.alignX === 'Min') {
+        widthDiff = 0;
       }
-      if (source) {
-        this.setSource(source);
+      if (preserveAspectRatio.alignY === 'Min') {
+        heightDiff = 0;
       }
-    },
-
-    /**
-     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
-     * @private
-     * @param {Number} r Red color value
-     * @param {Number} g Green color value
-     * @param {Number} b Blue color value
-     * @return {Array} Hsl color
-     */
-    _rgbToHsl: function(r, g, b) {
-      r /= 255; g /= 255; b /= 255;
-
-      var h, s, l,
-          max = fabric.util.array.max([r, g, b]),
-          min = fabric.util.array.min([r, g, b]);
+    }
 
-      l = (max + min) / 2;
+    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
+      return parsedDim;
+    }
+    if ((x || y) && element.parentNode.nodeName !== '#document') {
+      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
+    }
 
-      if (max === min) {
-        h = s = 0; // achromatic
+    matrix = translateMatrix + ' matrix(' + scaleX +
+                  ' 0' +
+                  ' 0 ' +
+                  scaleY + ' ' +
+                  (minX * scaleX + widthDiff) + ' ' +
+                  (minY * scaleY + heightDiff) + ') ';
+    // seems unused.
+    // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
+    if (element.nodeName === 'svg') {
+      el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
+      // element.firstChild != null
+      while (element.firstChild) {
+        el.appendChild(element.firstChild);
       }
-      else {
-        var d = max - min;
-        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
-        switch (max) {
-          case r:
-            h = (g - b) / d + (g < b ? 6 : 0);
-            break;
-          case g:
-            h = (b - r) / d + 2;
-            break;
-          case b:
-            h = (r - g) / d + 4;
-            break;
-        }
-        h /= 6;
+      element.appendChild(el);
+    }
+    else {
+      el = element;
+      el.removeAttribute('x');
+      el.removeAttribute('y');
+      matrix = el.getAttribute('transform') + matrix;
+    }
+    el.setAttribute('transform', matrix);
+    return parsedDim;
+  }
+
+  function hasAncestorWithNodeName(element, nodeName) {
+    while (element && (element = element.parentNode)) {
+      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
+        && !element.getAttribute('instantiated_by_use')) {
+        return true;
       }
+    }
+    return false;
+  }
 
-      return [
-        Math.round(h * 360),
-        Math.round(s * 100),
-        Math.round(l * 100)
-      ];
-    },
+  /**
+   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
+   * @static
+   * @function
+   * @memberOf fabric
+   * @param {SVGDocument} doc SVG document to parse
+   * @param {Function} callback Callback to call when parsing is finished;
+   * It's being passed an array of elements (parsed from a document).
+   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
+   * @param {Object} [parsingOptions] options for parsing document
+   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
+   */
+  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
+    if (!doc) {
+      return;
+    }
 
-    /**
-     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
-     * @return {Array}
-     */
-    getSource: function() {
-      return this._source;
-    },
+    parseUseDirectives(doc);
 
-    /**
-     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
-     * @param {Array} source
-     */
-    setSource: function(source) {
-      this._source = source;
-    },
+    var svgUid =  fabric.Object.__uid++, i, len,
+        options = applyViewboxTransform(doc),
+        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
+    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
+    options.svgUid = svgUid;
 
-    /**
-     * Returns color representation in RGB format
-     * @return {String} ex: rgb(0-255,0-255,0-255)
-     */
-    toRgb: function() {
-      var source = this.getSource();
-      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
-    },
+    if (descendants.length === 0 && fabric.isLikelyNode) {
+      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
+      // https://github.com/ajaxorg/node-o3-xml/issues/21
+      descendants = doc.selectNodes('//*[name(.)!="svg"]');
+      var arr = [];
+      for (i = 0, len = descendants.length; i < len; i++) {
+        arr[i] = descendants[i];
+      }
+      descendants = arr;
+    }
 
-    /**
-     * Returns color representation in RGBA format
-     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
-     */
-    toRgba: function() {
-      var source = this.getSource();
-      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
-    },
+    var elements = descendants.filter(function(el) {
+      applyViewboxTransform(el);
+      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
+            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
+    });
+    if (!elements || (elements && !elements.length)) {
+      callback && callback([], {});
+      return;
+    }
+    var clipPaths = { };
+    descendants.filter(function(el) {
+      return el.nodeName.replace('svg:', '') === 'clipPath';
+    }).forEach(function(el) {
+      var id = el.getAttribute('id');
+      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
+        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
+      });
+    });
+    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
+    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
+    fabric.clipPaths[svgUid] = clipPaths;
+    // Precedence of rules:   style > class > attribute
+    fabric.parseElements(elements, function(instances, elements) {
+      if (callback) {
+        callback(instances, options, elements, descendants);
+        delete fabric.gradientDefs[svgUid];
+        delete fabric.cssRules[svgUid];
+        delete fabric.clipPaths[svgUid];
+      }
+    }, clone(options), reviver, parsingOptions);
+  };
 
-    /**
-     * Returns color representation in HSL format
-     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
-     */
-    toHsl: function() {
-      var source = this.getSource(),
-          hsl = this._rgbToHsl(source[0], source[1], source[2]);
+  function recursivelyParseGradientsXlink(doc, gradient) {
+    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
+        xlinkAttr = 'xlink:href',
+        xLink = gradient.getAttribute(xlinkAttr).substr(1),
+        referencedGradient = elementById(doc, xLink);
+    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
+      recursivelyParseGradientsXlink(doc, referencedGradient);
+    }
+    gradientsAttrs.forEach(function(attr) {
+      if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
+        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
+      }
+    });
+    if (!gradient.children.length) {
+      var referenceClone = referencedGradient.cloneNode(true);
+      while (referenceClone.firstChild) {
+        gradient.appendChild(referenceClone.firstChild);
+      }
+    }
+    gradient.removeAttribute(xlinkAttr);
+  }
 
-      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
-    },
+  var reFontDeclaration = new RegExp(
+    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
+    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
+      fabric.reNum +
+    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');
 
+  extend(fabric, {
     /**
-     * Returns color representation in HSLA format
-     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
+     * Parses a short font declaration, building adding its properties to a style object
+     * @static
+     * @function
+     * @memberOf fabric
+     * @param {String} value font declaration
+     * @param {Object} oStyle definition
      */
-    toHsla: function() {
-      var source = this.getSource(),
-          hsl = this._rgbToHsl(source[0], source[1], source[2]);
+    parseFontDeclaration: function(value, oStyle) {
+      var match = value.match(reFontDeclaration);
 
-      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
+      if (!match) {
+        return;
+      }
+      var fontStyle = match[1],
+          // font variant is not used
+          // fontVariant = match[2],
+          fontWeight = match[3],
+          fontSize = match[4],
+          lineHeight = match[5],
+          fontFamily = match[6];
+
+      if (fontStyle) {
+        oStyle.fontStyle = fontStyle;
+      }
+      if (fontWeight) {
+        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
+      }
+      if (fontSize) {
+        oStyle.fontSize = parseUnit(fontSize);
+      }
+      if (fontFamily) {
+        oStyle.fontFamily = fontFamily;
+      }
+      if (lineHeight) {
+        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
+      }
     },
 
     /**
-     * Returns color representation in HEX format
-     * @return {String} ex: FF5555
+     * Parses an SVG document, returning all of the gradient declarations found in it
+     * @static
+     * @function
+     * @memberOf fabric
+     * @param {SVGDocument} doc SVG document to parse
+     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
      */
-    toHex: function() {
-      var source = this.getSource(), r, g, b;
-
-      r = source[0].toString(16);
-      r = (r.length === 1) ? ('0' + r) : r;
-
-      g = source[1].toString(16);
-      g = (g.length === 1) ? ('0' + g) : g;
-
-      b = source[2].toString(16);
-      b = (b.length === 1) ? ('0' + b) : b;
-
-      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
+    getGradientDefs: function(doc) {
+      var tagArray = [
+            'linearGradient',
+            'radialGradient',
+            'svg:linearGradient',
+            'svg:radialGradient'],
+          elList = _getMultipleNodes(doc, tagArray),
+          el, j = 0, gradientDefs = { };
+      j = elList.length;
+      while (j--) {
+        el = elList[j];
+        if (el.getAttribute('xlink:href')) {
+          recursivelyParseGradientsXlink(doc, el);
+        }
+        gradientDefs[el.getAttribute('id')] = el;
+      }
+      return gradientDefs;
     },
 
     /**
-     * Returns color representation in HEXA format
-     * @return {String} ex: FF5555CC
+     * Returns an object of attributes' name/value, given element and an array of attribute names;
+     * Parses parent "g" nodes recursively upwards.
+     * @static
+     * @memberOf fabric
+     * @param {DOMElement} element Element to parse
+     * @param {Array} attributes Array of attributes to parse
+     * @return {Object} object containing parsed attributes' names/values
      */
-    toHexa: function() {
-      var source = this.getSource(), a;
+    parseAttributes: function(element, attributes, svgUid) {
 
-      a = Math.round(source[3] * 255);
-      a = a.toString(16);
-      a = (a.length === 1) ? ('0' + a) : a;
+      if (!element) {
+        return;
+      }
 
-      return this.toHex() + a.toUpperCase();
-    },
+      var value,
+          parentAttributes = { },
+          fontSize, parentFontSize;
+
+      if (typeof svgUid === 'undefined') {
+        svgUid = element.getAttribute('svgUid');
+      }
+      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
+      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
+        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
+      }
+
+      var ownAttributes = attributes.reduce(function(memo, attr) {
+        value = element.getAttribute(attr);
+        if (value) { // eslint-disable-line
+          memo[attr] = value;
+        }
+        return memo;
+      }, { });
+      // add values parsed from style, which take precedence over attributes
+      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
+      var cssAttrs = extend(
+        getGlobalStylesForElement(element, svgUid),
+        fabric.parseStyleAttribute(element)
+      );
+      ownAttributes = extend(
+        ownAttributes,
+        cssAttrs
+      );
+      if (cssAttrs[cPath]) {
+        element.setAttribute(cPath, cssAttrs[cPath]);
+      }
+      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
+      if (ownAttributes[fSize]) {
+        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
+        ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
+      }
+
+      var normalizedAttr, normalizedValue, normalizedStyle = {};
+      for (var attr in ownAttributes) {
+        normalizedAttr = normalizeAttr(attr);
+        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
+        normalizedStyle[normalizedAttr] = normalizedValue;
+      }
+      if (normalizedStyle && normalizedStyle.font) {
+        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
+      }
+      var mergedAttrs = extend(parentAttributes, normalizedStyle);
+      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
+    },
 
     /**
-     * Gets value of alpha channel for this color
-     * @return {Number} 0-1
+     * Transforms an array of svg elements to corresponding fabric.* instances
+     * @static
+     * @memberOf fabric
+     * @param {Array} elements Array of elements to parse
+     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
+     * @param {Object} [options] Options object
+     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
      */
-    getAlpha: function() {
-      return this.getSource()[3];
+    parseElements: function(elements, callback, options, reviver, parsingOptions) {
+      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
     },
 
     /**
-     * Sets value of alpha channel for this color
-     * @param {Number} alpha Alpha value 0-1
-     * @return {fabric.Color} thisArg
+     * Parses "style" attribute, retuning an object with values
+     * @static
+     * @memberOf fabric
+     * @param {SVGElement} element Element to parse
+     * @return {Object} Objects with values parsed from style attribute of an element
      */
-    setAlpha: function(alpha) {
-      var source = this.getSource();
-      source[3] = alpha;
-      this.setSource(source);
-      return this;
+    parseStyleAttribute: function(element) {
+      var oStyle = { },
+          style = element.getAttribute('style');
+
+      if (!style) {
+        return oStyle;
+      }
+
+      if (typeof style === 'string') {
+        parseStyleString(style, oStyle);
+      }
+      else {
+        parseStyleObject(style, oStyle);
+      }
+
+      return oStyle;
     },
 
     /**
-     * Transforms color to its grayscale representation
-     * @return {fabric.Color} thisArg
+     * Parses "points" attribute, returning an array of values
+     * @static
+     * @memberOf fabric
+     * @param {String} points points attribute string
+     * @return {Array} array of points
      */
-    toGrayscale: function() {
-      var source = this.getSource(),
-          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
-          currentAlpha = source[3];
-      this.setSource([average, average, average, currentAlpha]);
-      return this;
+    parsePointsAttribute: function(points) {
+
+      // points attribute is required and must not be empty
+      if (!points) {
+        return null;
+      }
+
+      // replace commas with whitespace and remove bookending whitespace
+      points = points.replace(/,/g, ' ').trim();
+
+      points = points.split(/\s+/);
+      var parsedPoints = [], i, len;
+
+      for (i = 0, len = points.length; i < len; i += 2) {
+        parsedPoints.push({
+          x: parseFloat(points[i]),
+          y: parseFloat(points[i + 1])
+        });
+      }
+
+      // odd number of points is an error
+      // if (parsedPoints.length % 2 !== 0) {
+      //   return null;
+      // }
+
+      return parsedPoints;
     },
 
     /**
-     * Transforms color to its black and white representation
-     * @param {Number} threshold
-     * @return {fabric.Color} thisArg
+     * Returns CSS rules for a given SVG document
+     * @static
+     * @function
+     * @memberOf fabric
+     * @param {SVGDocument} doc SVG document to parse
+     * @return {Object} CSS rules of this document
      */
-    toBlackWhite: function(threshold) {
-      var source = this.getSource(),
-          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
-          currentAlpha = source[3];
+    getCSSRules: function(doc) {
+      var styles = doc.getElementsByTagName('style'), i, len,
+          allRules = { }, rules;
 
-      threshold = threshold || 127;
+      // very crude parsing of style contents
+      for (i = 0, len = styles.length; i < len; i++) {
+        var styleContents = styles[i].textContent;
 
-      average = (Number(average) < Number(threshold)) ? 0 : 255;
-      this.setSource([average, average, average, currentAlpha]);
-      return this;
+        // remove comments
+        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
+        if (styleContents.trim() === '') {
+          continue;
+        }
+        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
+        rules = rules.map(function(rule) { return rule.trim(); });
+        // eslint-disable-next-line no-loop-func
+        rules.forEach(function(rule) {
+
+          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
+              ruleObj = { }, declaration = match[2].trim(),
+              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
+
+          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
+            var pair = propertyValuePairs[i].split(/\s*:\s*/),
+                property = pair[0],
+                value = pair[1];
+            ruleObj[property] = value;
+          }
+          rule = match[1];
+          rule.split(',').forEach(function(_rule) {
+            _rule = _rule.replace(/^svg/i, '').trim();
+            if (_rule === '') {
+              return;
+            }
+            if (allRules[_rule]) {
+              fabric.util.object.extend(allRules[_rule], ruleObj);
+            }
+            else {
+              allRules[_rule] = fabric.util.object.clone(ruleObj);
+            }
+          });
+        });
+      }
+      return allRules;
     },
 
     /**
-     * Overlays color with another color
-     * @param {String|fabric.Color} otherColor
-     * @return {fabric.Color} thisArg
+     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
+     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
+     * @memberOf fabric
+     * @param {String} url
+     * @param {Function} callback
+     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
+     * @param {Object} [options] Object containing options for parsing
+     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
      */
-    overlayWith: function(otherColor) {
-      if (!(otherColor instanceof Color)) {
-        otherColor = new Color(otherColor);
-      }
+    loadSVGFromURL: function(url, callback, reviver, options) {
 
-      var result = [],
-          alpha = this.getAlpha(),
-          otherAlpha = 0.5,
-          source = this.getSource(),
-          otherSource = otherColor.getSource(), i;
+      url = url.replace(/^\n\s*/, '').trim();
+      new fabric.util.request(url, {
+        method: 'get',
+        onComplete: onComplete
+      });
 
-      for (i = 0; i < 3; i++) {
-        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
+      function onComplete(r) {
+
+        var xml = r.responseXML;
+        if (!xml || !xml.documentElement) {
+          callback && callback(null);
+          return false;
+        }
+
+        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
+          callback && callback(results, _options, elements, allElements);
+        }, reviver, options);
       }
+    },
 
-      result[3] = alpha;
-      this.setSource(result);
-      return this;
+    /**
+     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
+     * @memberOf fabric
+     * @param {String} string
+     * @param {Function} callback
+     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
+     * @param {Object} [options] Object containing options for parsing
+     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
+     */
+    loadSVGFromString: function(string, callback, reviver, options) {
+      var parser = new fabric.window.DOMParser(),
+          doc = parser.parseFromString(string.trim(), 'text/xml');
+      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
+        callback(results, _options, elements, allElements);
+      }, reviver, options);
     }
-  };
+  });
 
-  /**
-   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
-   * @static
-   * @field
-   * @memberOf fabric.Color
-   */
-  // eslint-disable-next-line max-len
-  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
+  this.elements = elements;
+  this.callback = callback;
+  this.options = options;
+  this.reviver = reviver;
+  this.svgUid = (options && options.svgUid) || 0;
+  this.parsingOptions = parsingOptions;
+  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
+  this.doc = doc;
+};
+
+(function(proto) {
+  proto.parse = function() {
+    this.instances = new Array(this.elements.length);
+    this.numElements = this.elements.length;
+    this.createObjects();
+  };
+
+  proto.createObjects = function() {
+    var _this = this;
+    this.elements.forEach(function(element, i) {
+      element.setAttribute('svgUid', _this.svgUid);
+      _this.createObject(element, i);
+    });
+  };
+
+  proto.findTag = function(el) {
+    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
+  };
+
+  proto.createObject = function(el, index) {
+    var klass = this.findTag(el);
+    if (klass && klass.fromElement) {
+      try {
+        klass.fromElement(el, this.createCallback(index, el), this.options);
+      }
+      catch (err) {
+        fabric.log(err);
+      }
+    }
+    else {
+      this.checkIfDone();
+    }
+  };
+
+  proto.createCallback = function(index, el) {
+    var _this = this;
+    return function(obj) {
+      var _options;
+      _this.resolveGradient(obj, el, 'fill');
+      _this.resolveGradient(obj, el, 'stroke');
+      if (obj instanceof fabric.Image && obj._originalElement) {
+        _options = obj.parsePreserveAspectRatioAttribute(el);
+      }
+      obj._removeTransformMatrix(_options);
+      _this.resolveClipPath(obj, el);
+      _this.reviver && _this.reviver(el, obj);
+      _this.instances[index] = obj;
+      _this.checkIfDone();
+    };
+  };
+
+  proto.extractPropertyDefinition = function(obj, property, storage) {
+    var value = obj[property], regex = this.regexUrl;
+    if (!regex.test(value)) {
+      return;
+    }
+    regex.lastIndex = 0;
+    var id = regex.exec(value)[1];
+    regex.lastIndex = 0;
+    return fabric[storage][this.svgUid][id];
+  };
+
+  proto.resolveGradient = function(obj, el, property) {
+    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
+    if (gradientDef) {
+      var opacityAttr = el.getAttribute(property + '-opacity');
+      var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
+      obj.set(property, gradient);
+    }
+  };
+
+  proto.createClipPathCallback = function(obj, container) {
+    return function(_newObj) {
+      _newObj._removeTransformMatrix();
+      _newObj.fillRule = _newObj.clipRule;
+      container.push(_newObj);
+    };
+  };
+
+  proto.resolveClipPath = function(obj, usingElement) {
+    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
+        element, klass, objTransformInv, container, gTransform, options;
+    if (clipPath) {
+      container = [];
+      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
+      // move the clipPath tag as sibling to the real element that is using it
+      var clipPathTag = clipPath[0].parentNode;
+      var clipPathOwner = usingElement;
+      while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
+        clipPathOwner = clipPathOwner.parentNode;
+      }
+      clipPathOwner.parentNode.appendChild(clipPathTag);
+      for (var i = 0; i < clipPath.length; i++) {
+        element = clipPath[i];
+        klass = this.findTag(element);
+        klass.fromElement(
+          element,
+          this.createClipPathCallback(obj, container),
+          this.options
+        );
+      }
+      if (container.length === 1) {
+        clipPath = container[0];
+      }
+      else {
+        clipPath = new fabric.Group(container);
+      }
+      gTransform = fabric.util.multiplyTransformMatrices(
+        objTransformInv,
+        clipPath.calcTransformMatrix()
+      );
+      if (clipPath.clipPath) {
+        this.resolveClipPath(clipPath, clipPathOwner);
+      }
+      var options = fabric.util.qrDecompose(gTransform);
+      clipPath.flipX = false;
+      clipPath.flipY = false;
+      clipPath.set('scaleX', options.scaleX);
+      clipPath.set('scaleY', options.scaleY);
+      clipPath.angle = options.angle;
+      clipPath.skewX = options.skewX;
+      clipPath.skewY = 0;
+      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
+      obj.clipPath = clipPath;
+    }
+    else {
+      // if clip-path does not resolve to any element, delete the property.
+      delete obj.clipPath;
+    }
+  };
+
+  proto.checkIfDone = function() {
+    if (--this.numElements === 0) {
+      this.instances = this.instances.filter(function(el) {
+        // eslint-disable-next-line no-eq-null, eqeqeq
+        return el != null;
+      });
+      this.callback(this.instances, this.elements);
+    }
+  };
+})(fabric.ElementsParser.prototype);
+
+
+(function(global) {
+
+  'use strict';
+
+  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
+
+  var fabric = global.fabric || (global.fabric = { });
+
+  if (fabric.Point) {
+    fabric.warn('fabric.Point is already defined');
+    return;
+  }
+
+  fabric.Point = Point;
+
+  /**
+   * Point class
+   * @class fabric.Point
+   * @memberOf fabric
+   * @constructor
+   * @param {Number} x
+   * @param {Number} y
+   * @return {fabric.Point} thisArg
+   */
+  function Point(x, y) {
+    this.x = x;
+    this.y = y;
+  }
+
+  Point.prototype = /** @lends fabric.Point.prototype */ {
+
+    type: 'point',
+
+    constructor: Point,
+
+    /**
+     * Adds another point to this one and returns another one
+     * @param {fabric.Point} that
+     * @return {fabric.Point} new Point instance with added values
+     */
+    add: function (that) {
+      return new Point(this.x + that.x, this.y + that.y);
+    },
+
+    /**
+     * Adds another point to this one
+     * @param {fabric.Point} that
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    addEquals: function (that) {
+      this.x += that.x;
+      this.y += that.y;
+      return this;
+    },
+
+    /**
+     * Adds value to this point and returns a new one
+     * @param {Number} scalar
+     * @return {fabric.Point} new Point with added value
+     */
+    scalarAdd: function (scalar) {
+      return new Point(this.x + scalar, this.y + scalar);
+    },
+
+    /**
+     * Adds value to this point
+     * @param {Number} scalar
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    scalarAddEquals: function (scalar) {
+      this.x += scalar;
+      this.y += scalar;
+      return this;
+    },
+
+    /**
+     * Subtracts another point from this point and returns a new one
+     * @param {fabric.Point} that
+     * @return {fabric.Point} new Point object with subtracted values
+     */
+    subtract: function (that) {
+      return new Point(this.x - that.x, this.y - that.y);
+    },
+
+    /**
+     * Subtracts another point from this point
+     * @param {fabric.Point} that
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    subtractEquals: function (that) {
+      this.x -= that.x;
+      this.y -= that.y;
+      return this;
+    },
+
+    /**
+     * Subtracts value from this point and returns a new one
+     * @param {Number} scalar
+     * @return {fabric.Point}
+     */
+    scalarSubtract: function (scalar) {
+      return new Point(this.x - scalar, this.y - scalar);
+    },
+
+    /**
+     * Subtracts value from this point
+     * @param {Number} scalar
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    scalarSubtractEquals: function (scalar) {
+      this.x -= scalar;
+      this.y -= scalar;
+      return this;
+    },
+
+    /**
+     * Multiplies this point by a value and returns a new one
+     * TODO: rename in scalarMultiply in 2.0
+     * @param {Number} scalar
+     * @return {fabric.Point}
+     */
+    multiply: function (scalar) {
+      return new Point(this.x * scalar, this.y * scalar);
+    },
+
+    /**
+     * Multiplies this point by a value
+     * TODO: rename in scalarMultiplyEquals in 2.0
+     * @param {Number} scalar
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    multiplyEquals: function (scalar) {
+      this.x *= scalar;
+      this.y *= scalar;
+      return this;
+    },
+
+    /**
+     * Divides this point by a value and returns a new one
+     * TODO: rename in scalarDivide in 2.0
+     * @param {Number} scalar
+     * @return {fabric.Point}
+     */
+    divide: function (scalar) {
+      return new Point(this.x / scalar, this.y / scalar);
+    },
+
+    /**
+     * Divides this point by a value
+     * TODO: rename in scalarDivideEquals in 2.0
+     * @param {Number} scalar
+     * @return {fabric.Point} thisArg
+     * @chainable
+     */
+    divideEquals: function (scalar) {
+      this.x /= scalar;
+      this.y /= scalar;
+      return this;
+    },
+
+    /**
+     * Returns true if this point is equal to another one
+     * @param {fabric.Point} that
+     * @return {Boolean}
+     */
+    eq: function (that) {
+      return (this.x === that.x && this.y === that.y);
+    },
+
+    /**
+     * Returns true if this point is less than another one
+     * @param {fabric.Point} that
+     * @return {Boolean}
+     */
+    lt: function (that) {
+      return (this.x < that.x && this.y < that.y);
+    },
+
+    /**
+     * Returns true if this point is less than or equal to another one
+     * @param {fabric.Point} that
+     * @return {Boolean}
+     */
+    lte: function (that) {
+      return (this.x <= that.x && this.y <= that.y);
+    },
+
+    /**
+
+     * Returns true if this point is greater another one
+     * @param {fabric.Point} that
+     * @return {Boolean}
+     */
+    gt: function (that) {
+      return (this.x > that.x && this.y > that.y);
+    },
+
+    /**
+     * Returns true if this point is greater than or equal to another one
+     * @param {fabric.Point} that
+     * @return {Boolean}
+     */
+    gte: function (that) {
+      return (this.x >= that.x && this.y >= that.y);
+    },
+
+    /**
+     * Returns new point which is the result of linear interpolation with this one and another one
+     * @param {fabric.Point} that
+     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
+     * @return {fabric.Point}
+     */
+    lerp: function (that, t) {
+      if (typeof t === 'undefined') {
+        t = 0.5;
+      }
+      t = Math.max(Math.min(1, t), 0);
+      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
+    },
+
+    /**
+     * Returns distance from this point and another one
+     * @param {fabric.Point} that
+     * @return {Number}
+     */
+    distanceFrom: function (that) {
+      var dx = this.x - that.x,
+          dy = this.y - that.y;
+      return Math.sqrt(dx * dx + dy * dy);
+    },
+
+    /**
+     * Returns the point between this point and another one
+     * @param {fabric.Point} that
+     * @return {fabric.Point}
+     */
+    midPointFrom: function (that) {
+      return this.lerp(that);
+    },
+
+    /**
+     * Returns a new point which is the min of this and another one
+     * @param {fabric.Point} that
+     * @return {fabric.Point}
+     */
+    min: function (that) {
+      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
+    },
+
+    /**
+     * Returns a new point which is the max of this and another one
+     * @param {fabric.Point} that
+     * @return {fabric.Point}
+     */
+    max: function (that) {
+      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
+    },
+
+    /**
+     * Returns string representation of this point
+     * @return {String}
+     */
+    toString: function () {
+      return this.x + ',' + this.y;
+    },
+
+    /**
+     * Sets x/y of this point
+     * @param {Number} x
+     * @param {Number} y
+     * @chainable
+     */
+    setXY: function (x, y) {
+      this.x = x;
+      this.y = y;
+      return this;
+    },
+
+    /**
+     * Sets x of this point
+     * @param {Number} x
+     * @chainable
+     */
+    setX: function (x) {
+      this.x = x;
+      return this;
+    },
+
+    /**
+     * Sets y of this point
+     * @param {Number} y
+     * @chainable
+     */
+    setY: function (y) {
+      this.y = y;
+      return this;
+    },
+
+    /**
+     * Sets x/y of this point from another point
+     * @param {fabric.Point} that
+     * @chainable
+     */
+    setFromPoint: function (that) {
+      this.x = that.x;
+      this.y = that.y;
+      return this;
+    },
+
+    /**
+     * Swaps x/y of this point and another point
+     * @param {fabric.Point} that
+     */
+    swap: function (that) {
+      var x = this.x,
+          y = this.y;
+      this.x = that.x;
+      this.y = that.y;
+      that.x = x;
+      that.y = y;
+    },
+
+    /**
+     * return a cloned instance of the point
+     * @return {fabric.Point}
+     */
+    clone: function () {
+      return new Point(this.x, this.y);
+    }
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+(function(global) {
+
+  'use strict';
+
+  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
+  var fabric = global.fabric || (global.fabric = { });
+
+  if (fabric.Intersection) {
+    fabric.warn('fabric.Intersection is already defined');
+    return;
+  }
+
+  /**
+   * Intersection class
+   * @class fabric.Intersection
+   * @memberOf fabric
+   * @constructor
+   */
+  function Intersection(status) {
+    this.status = status;
+    this.points = [];
+  }
+
+  fabric.Intersection = Intersection;
+
+  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {
+
+    constructor: Intersection,
+
+    /**
+     * Appends a point to intersection
+     * @param {fabric.Point} point
+     * @return {fabric.Intersection} thisArg
+     * @chainable
+     */
+    appendPoint: function (point) {
+      this.points.push(point);
+      return this;
+    },
+
+    /**
+     * Appends points to intersection
+     * @param {Array} points
+     * @return {fabric.Intersection} thisArg
+     * @chainable
+     */
+    appendPoints: function (points) {
+      this.points = this.points.concat(points);
+      return this;
+    }
+  };
+
+  /**
+   * Checks if one line intersects another
+   * TODO: rename in intersectSegmentSegment
+   * @static
+   * @param {fabric.Point} a1
+   * @param {fabric.Point} a2
+   * @param {fabric.Point} b1
+   * @param {fabric.Point} b2
+   * @return {fabric.Intersection}
+   */
+  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
+    var result,
+        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
+        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
+        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
+    if (uB !== 0) {
+      var ua = uaT / uB,
+          ub = ubT / uB;
+      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
+        result = new Intersection('Intersection');
+        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
+      }
+      else {
+        result = new Intersection();
+      }
+    }
+    else {
+      if (uaT === 0 || ubT === 0) {
+        result = new Intersection('Coincident');
+      }
+      else {
+        result = new Intersection('Parallel');
+      }
+    }
+    return result;
+  };
+
+  /**
+   * Checks if line intersects polygon
+   * TODO: rename in intersectSegmentPolygon
+   * fix detection of coincident
+   * @static
+   * @param {fabric.Point} a1
+   * @param {fabric.Point} a2
+   * @param {Array} points
+   * @return {fabric.Intersection}
+   */
+  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
+    var result = new Intersection(),
+        length = points.length,
+        b1, b2, inter, i;
+
+    for (i = 0; i < length; i++) {
+      b1 = points[i];
+      b2 = points[(i + 1) % length];
+      inter = Intersection.intersectLineLine(a1, a2, b1, b2);
+
+      result.appendPoints(inter.points);
+    }
+    if (result.points.length > 0) {
+      result.status = 'Intersection';
+    }
+    return result;
+  };
+
+  /**
+   * Checks if polygon intersects another polygon
+   * @static
+   * @param {Array} points1
+   * @param {Array} points2
+   * @return {fabric.Intersection}
+   */
+  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
+    var result = new Intersection(),
+        length = points1.length, i;
+
+    for (i = 0; i < length; i++) {
+      var a1 = points1[i],
+          a2 = points1[(i + 1) % length],
+          inter = Intersection.intersectLinePolygon(a1, a2, points2);
+
+      result.appendPoints(inter.points);
+    }
+    if (result.points.length > 0) {
+      result.status = 'Intersection';
+    }
+    return result;
+  };
+
+  /**
+   * Checks if polygon intersects rectangle
+   * @static
+   * @param {Array} points
+   * @param {fabric.Point} r1
+   * @param {fabric.Point} r2
+   * @return {fabric.Intersection}
+   */
+  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
+    var min = r1.min(r2),
+        max = r1.max(r2),
+        topRight = new fabric.Point(max.x, min.y),
+        bottomLeft = new fabric.Point(min.x, max.y),
+        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
+        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
+        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
+        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
+        result = new Intersection();
+
+    result.appendPoints(inter1.points);
+    result.appendPoints(inter2.points);
+    result.appendPoints(inter3.points);
+    result.appendPoints(inter4.points);
+
+    if (result.points.length > 0) {
+      result.status = 'Intersection';
+    }
+    return result;
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+(function(global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = { });
+
+  if (fabric.Color) {
+    fabric.warn('fabric.Color is already defined.');
+    return;
+  }
+
+  /**
+   * Color class
+   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
+   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
+   *
+   * @class fabric.Color
+   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
+   * @return {fabric.Color} thisArg
+   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
+   */
+  function Color(color) {
+    if (!color) {
+      this.setSource([0, 0, 0, 1]);
+    }
+    else {
+      this._tryParsingColor(color);
+    }
+  }
+
+  fabric.Color = Color;
+
+  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {
+
+    /**
+     * @private
+     * @param {String|Array} color Color value to parse
+     */
+    _tryParsingColor: function(color) {
+      var source;
+
+      if (color in Color.colorNameMap) {
+        color = Color.colorNameMap[color];
+      }
+
+      if (color === 'transparent') {
+        source = [255, 255, 255, 0];
+      }
+
+      if (!source) {
+        source = Color.sourceFromHex(color);
+      }
+      if (!source) {
+        source = Color.sourceFromRgb(color);
+      }
+      if (!source) {
+        source = Color.sourceFromHsl(color);
+      }
+      if (!source) {
+        //if color is not recognize let's make black as canvas does
+        source = [0, 0, 0, 1];
+      }
+      if (source) {
+        this.setSource(source);
+      }
+    },
+
+    /**
+     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
+     * @private
+     * @param {Number} r Red color value
+     * @param {Number} g Green color value
+     * @param {Number} b Blue color value
+     * @return {Array} Hsl color
+     */
+    _rgbToHsl: function(r, g, b) {
+      r /= 255; g /= 255; b /= 255;
+
+      var h, s, l,
+          max = fabric.util.array.max([r, g, b]),
+          min = fabric.util.array.min([r, g, b]);
+
+      l = (max + min) / 2;
+
+      if (max === min) {
+        h = s = 0; // achromatic
+      }
+      else {
+        var d = max - min;
+        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
+        switch (max) {
+          case r:
+            h = (g - b) / d + (g < b ? 6 : 0);
+            break;
+          case g:
+            h = (b - r) / d + 2;
+            break;
+          case b:
+            h = (r - g) / d + 4;
+            break;
+        }
+        h /= 6;
+      }
+
+      return [
+        Math.round(h * 360),
+        Math.round(s * 100),
+        Math.round(l * 100)
+      ];
+    },
+
+    /**
+     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
+     * @return {Array}
+     */
+    getSource: function() {
+      return this._source;
+    },
+
+    /**
+     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
+     * @param {Array} source
+     */
+    setSource: function(source) {
+      this._source = source;
+    },
+
+    /**
+     * Returns color representation in RGB format
+     * @return {String} ex: rgb(0-255,0-255,0-255)
+     */
+    toRgb: function() {
+      var source = this.getSource();
+      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
+    },
+
+    /**
+     * Returns color representation in RGBA format
+     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
+     */
+    toRgba: function() {
+      var source = this.getSource();
+      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
+    },
+
+    /**
+     * Returns color representation in HSL format
+     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
+     */
+    toHsl: function() {
+      var source = this.getSource(),
+          hsl = this._rgbToHsl(source[0], source[1], source[2]);
+
+      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
+    },
+
+    /**
+     * Returns color representation in HSLA format
+     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
+     */
+    toHsla: function() {
+      var source = this.getSource(),
+          hsl = this._rgbToHsl(source[0], source[1], source[2]);
+
+      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
+    },
+
+    /**
+     * Returns color representation in HEX format
+     * @return {String} ex: FF5555
+     */
+    toHex: function() {
+      var source = this.getSource(), r, g, b;
+
+      r = source[0].toString(16);
+      r = (r.length === 1) ? ('0' + r) : r;
+
+      g = source[1].toString(16);
+      g = (g.length === 1) ? ('0' + g) : g;
+
+      b = source[2].toString(16);
+      b = (b.length === 1) ? ('0' + b) : b;
+
+      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
+    },
+
+    /**
+     * Returns color representation in HEXA format
+     * @return {String} ex: FF5555CC
+     */
+    toHexa: function() {
+      var source = this.getSource(), a;
+
+      a = Math.round(source[3] * 255);
+      a = a.toString(16);
+      a = (a.length === 1) ? ('0' + a) : a;
+
+      return this.toHex() + a.toUpperCase();
+    },
+
+    /**
+     * Gets value of alpha channel for this color
+     * @return {Number} 0-1
+     */
+    getAlpha: function() {
+      return this.getSource()[3];
+    },
+
+    /**
+     * Sets value of alpha channel for this color
+     * @param {Number} alpha Alpha value 0-1
+     * @return {fabric.Color} thisArg
+     */
+    setAlpha: function(alpha) {
+      var source = this.getSource();
+      source[3] = alpha;
+      this.setSource(source);
+      return this;
+    },
+
+    /**
+     * Transforms color to its grayscale representation
+     * @return {fabric.Color} thisArg
+     */
+    toGrayscale: function() {
+      var source = this.getSource(),
+          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
+          currentAlpha = source[3];
+      this.setSource([average, average, average, currentAlpha]);
+      return this;
+    },
+
+    /**
+     * Transforms color to its black and white representation
+     * @param {Number} threshold
+     * @return {fabric.Color} thisArg
+     */
+    toBlackWhite: function(threshold) {
+      var source = this.getSource(),
+          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
+          currentAlpha = source[3];
+
+      threshold = threshold || 127;
+
+      average = (Number(average) < Number(threshold)) ? 0 : 255;
+      this.setSource([average, average, average, currentAlpha]);
+      return this;
+    },
+
+    /**
+     * Overlays color with another color
+     * @param {String|fabric.Color} otherColor
+     * @return {fabric.Color} thisArg
+     */
+    overlayWith: function(otherColor) {
+      if (!(otherColor instanceof Color)) {
+        otherColor = new Color(otherColor);
+      }
+
+      var result = [],
+          alpha = this.getAlpha(),
+          otherAlpha = 0.5,
+          source = this.getSource(),
+          otherSource = otherColor.getSource(), i;
+
+      for (i = 0; i < 3; i++) {
+        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
+      }
+
+      result[3] = alpha;
+      this.setSource(result);
+      return this;
+    }
+  };
+
+  /**
+   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
+   * @static
+   * @field
+   * @memberOf fabric.Color
+   */
+  // eslint-disable-next-line max-len
+  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;
 
   /**
    * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
@@ -8652,8 +11060,12 @@ fabric.ElementsParser = function(elements, callback, options, reviver, parsingOp
     imageSmoothingEnabled: true,
 
     /**
-     * The transformation (in the format of Canvas transform) which focuses the viewport
+     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport
      * @type Array
+     * @example <caption>Default transform</caption>
+     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
+     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>
+     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];
      * @default
      */
     viewportTransform: fabric.iMatrix.concat(),
@@ -9189,8 +11601,8 @@ fabric.ElementsParser = function(elements, callback, options, reviver, parsingOp
     },
 
     /**
-     * Sets viewport transform of this canvas instance
-     * @param {Array} vpt the transform in the form of context.transform
+     * Sets viewport transformation of this canvas instance
+     * @param {Array} vpt a Canvas 2D API transform matrix
      * @return {fabric.Canvas} instance
      * @chainable true
      */
@@ -10291,7 +12703,7 @@ fabric.ElementsParser = function(elements, callback, options, reviver, parsingOp
       this.contextContainer = null;
       // restore canvas style
       this.lowerCanvasEl.classList.remove('lower-canvas');
-      this.lowerCanvasEl.style = this._originalCanvasStyle;
+      fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);
       delete this._originalCanvasStyle;
       // restore canvas size to original size in case retina scaling was applied
       this.lowerCanvasEl.setAttribute('width', this.width);
@@ -10544,7 +12956,23 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
      * @type Number
      * @default 0.4
      */
-    decimate: 0.4,
+    decimate: 0.4,
+
+    /**
+     * Draws a straight line between last recorded point to current pointer
+     * Used for `shift` functionality
+     *
+     * @type boolean
+     * @default false
+     */
+    drawStraightLine: false,
+
+    /**
+     * The event modifier key that makes the brush draw a straight line.
+     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.
+     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}
+     */
+    straightLineKey: 'shiftKey',
 
     /**
      * Constructor
@@ -10556,6 +12984,10 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       this._points = [];
     },
 
+    needsFullRender: function () {
+      return this.callSuper('needsFullRender') || this._hasStraightLine;
+    },
+
     /**
      * Invoked inside on mouse down and mouse move
      * @param {Object} pointer
@@ -10574,6 +13006,7 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       if (!this.canvas._isMainEvent(options.e)) {
         return;
       }
+      this.drawStraightLine = options.e[this.straightLineKey];
       this._prepareForDrawing(pointer);
       // capture coordinates immediately
       // this allows to draw dots (when movement never occurs)
@@ -10589,6 +13022,7 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       if (!this.canvas._isMainEvent(options.e)) {
         return;
       }
+      this.drawStraightLine = options.e[this.straightLineKey];
       if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
         return;
       }
@@ -10621,6 +13055,7 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       if (!this.canvas._isMainEvent(options.e)) {
         return true;
       }
+      this.drawStraightLine = false;
       this.oldEnd = undefined;
       this._finalizeAndAddPath();
       return false;
@@ -10647,6 +13082,10 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
         return false;
       }
+      if (this.drawStraightLine && this._points.length > 1) {
+        this._hasStraightLine = true;
+        this._points.pop();
+      }
       this._points.push(point);
       return true;
     },
@@ -10659,6 +13098,7 @@ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype
       this._points = [];
       this._setBrushStyles();
       this._setShadow();
+      this._hasStraightLine = false;
     },
 
     /**
@@ -11586,6 +14026,13 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
      */
     targets: [],
 
+    /**
+     * When the option is enabled, PointerEvent is used instead of MouseEvent.
+     * @type Boolean
+     * @default
+     */
+    enablePointerEvents: false,
+
     /**
      * Keep track of the hovered target
      * @type fabric.Object
@@ -11623,15 +14070,21 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
      * @return {Array} objects to render immediately and pushes the other in the activeGroup.
      */
     _chooseObjectsToRender: function() {
-      var activeObjects = this.getActiveObjects(),
+      var activeObjects = this.getActiveObjects(), objects = this._objects,
           object, objsToRender, activeGroupObjects;
 
       if (activeObjects.length > 0 && !this.preserveObjectStacking) {
         objsToRender = [];
         activeGroupObjects = [];
+        var ancestors = activeObjects.map(function (obj) {
+          while (obj && objects.indexOf(obj) === -1) {
+            obj = obj.parent || obj.group;
+          }
+          return obj;
+        });
         for (var i = 0, length = this._objects.length; i < length; i++) {
           object = this._objects[i];
-          if (activeObjects.indexOf(object) === -1 ) {
+          if (activeObjects.indexOf(object) === -1 && ancestors.indexOf(object) === -1) {
             objsToRender.push(object);
           }
           else {
@@ -11641,6 +14094,9 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
         if (activeObjects.length > 1) {
           this._activeObject._objects = activeGroupObjects;
         }
+        else if (activeObjects[0].parent) {
+          activeGroupObjects.push(activeObjects[0]);
+        }
         objsToRender.push.apply(objsToRender, activeGroupObjects);
       }
       else {
@@ -12060,7 +14516,7 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
           this._normalizePointer(objToCheck.group, pointer) : pointer;
         if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
           target = objects[i];
-          if (target.subTargetCheck && target instanceof fabric.Group) {
+          if (target.subTargetCheck && Array.isArray(target._objects)) {
             subTarget = this._searchPossibleTargets(target._objects, pointer);
             subTarget && this.targets.push(subTarget);
           }
@@ -12375,18 +14831,71 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
      * @param {Event} [e] Event (passed along when firing "object:selected")
      * @return {Boolean} true if the selection happened
      */
-    _setActiveObject: function(object, e) {
-      if (this._activeObject === object) {
+    _setActiveObject: function (object, e) {
+      var isCollection = Array.isArray(object._objects), activeObject = this._activeObject;
+      if (this._activeObject === object && !isCollection) {
         return false;
       }
+      //  return if active object doesn't allow to be deselected
       if (!this._discardActiveObject(e, object)) {
         return false;
       }
-      if (object.onSelect({ e: e })) {
+      var subTargets;
+      if (e) {
+        //  prepare subTargets
+        var pointer = this.getPointer(e, true), targets = this.targets, target;
+        this.targets = [];
+        //  push children and `activeObject` to `targets`
+        if (activeObject && activeObject.subTargetCheck && Array.isArray(activeObject._objects)) {
+          target = this._searchPossibleTargets([activeObject], pointer);
+          target && this.targets.push(target);
+        }
+        //  push siblings and parents to `targets` recursively up
+        var parent = activeObject && activeObject.parent;
+        while (parent) {
+          target = this._searchPossibleTargets([parent], pointer);
+          target && this.targets.push(target);
+          parent = parent.parent;
+        }
+        subTargets = this.targets;
+        var lastIndex = subTargets.lastIndexOf(activeObject);
+        //  it is possible that `activeObject` exists twice in `subTargets`
+        //  if so we remove the last ref that was pushed as part of siblings check because we want it to be on top of all it's siblings
+        if (subTargets.indexOf(activeObject) !== lastIndex) {
+          subTargets.splice(lastIndex, 1);
+        }
+        this.targets = targets;
+      }
+      return this.__setActiveObject(object, e, subTargets);
+    },
+
+    __setActiveObject: function (object, e, subTargets) {
+      var activeObject = this._activeObject;
+      var result = object.onSelect({
+        e: e,
+        object: activeObject,
+        subTargets: this.targets.filter(function (object) { return object.isSelectable(); }),
+        activeSubTargets: subTargets && subTargets.filter(function (object) { return object.isSelectable(); })
+      });
+      if (result === true) {
         return false;
       }
-      this._activeObject = object;
-      return true;
+      else if (result && result instanceof fabric.Object && result !== object) {
+        var targets = this.targets;
+        if (e) {
+          //  prepare `targets`          
+          this.targets = [];
+          this._searchPossibleTargets([result], this.getPointer(e, true));
+        }
+        if (this.__setActiveObject(result, e) === true) {
+          //  restore `targets` if object declined selection
+          this.targets = targets;
+        };
+      }
+      else {
+        this._activeObject = object;
+      }
+      return activeObject !== this._activeObject;
     },
 
     /**
@@ -12927,8 +15436,9 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
     /**
      * @private
      */
-    _onResize: function () {
+    _onResize: function (e) {
       this.calcOffset();
+      this.fire('resize', { e: e });
     },
 
     /**
@@ -13008,9 +15518,12 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
           );
         }
       }
+      var actualTarget = target;
       if (target) {
         if (target.selectable && target !== this._activeObject && target.activeOn === 'up') {
           this.setActiveObject(target, e);
+          //  reassign in case a different object was selected
+          actualTarget = this._activeObject;
           shouldRender = true;
         }
         else {
@@ -13027,7 +15540,7 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
         }
         target.isMoving = false;
       }
-      this._setCursorFromEvent(e, target);
+      this._setCursorFromEvent(e, actualTarget);
       this._handleEvent(e, 'up', LEFT_CLICK, isClick);
       this._groupSelector = null;
       this._currentTransform = null;
@@ -13277,11 +15790,16 @@ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fab
         };
       }
 
+      if (target && target.selectable && target.activeOn === 'down') {
+        this.setActiveObject(target, e);
+        //  reassign in case a different object was selected
+        if (target !== this._activeObject) {
+          shouldRender = true;
+          target = this._target = this._activeObject;
+        }
+      }
       if (target) {
         var alreadySelected = target === this._activeObject;
-        if (target.selectable && target.activeOn === 'down') {
-          this.setActiveObject(target, e);
-        }
         var corner = target._findTargetCorner(
           this.getPointer(e, true),
           fabric.util.isTouchEvent(e)
@@ -14077,6 +16595,157 @@ fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.Stati
 });
 
 
+/**
+ * Adds support for multi-touch gestures using the Event.js library.
+ * Fires the following custom events:
+ * - touch:gesture
+ * - touch:drag
+ * - touch:orientation
+ * - touch:shake
+ * - touch:longpress
+ */
+(function() {
+
+  var degreesToRadians = fabric.util.degreesToRadians,
+      radiansToDegrees = fabric.util.radiansToDegrees;
+
+  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
+    /**
+     * Method that defines actions when an Event.js gesture is detected on an object. Currently only supports
+     * 2 finger gestures.
+     * @param {Event} e Event object by Event.js
+     * @param {Event} self Event proxy object by Event.js
+     */
+    __onTransformGesture: function(e, self) {
+
+      if (this.isDrawingMode || !e.touches || e.touches.length !== 2 || 'gesture' !== self.gesture) {
+        return;
+      }
+
+      var target = this.findTarget(e);
+      if ('undefined' !== typeof target) {
+        this.__gesturesParams = {
+          e: e,
+          self: self,
+          target: target
+        };
+
+        this.__gesturesRenderer();
+      }
+
+      this.fire('touch:gesture', {
+        target: target, e: e, self: self
+      });
+    },
+    __gesturesParams: null,
+    __gesturesRenderer: function() {
+
+      if (this.__gesturesParams === null || this._currentTransform === null) {
+        return;
+      }
+
+      var self = this.__gesturesParams.self,
+          t = this._currentTransform,
+          e = this.__gesturesParams.e;
+
+      t.action = 'scale';
+      t.originX = t.originY = 'center';
+
+      this._scaleObjectBy(self.scale, e);
+
+      if (self.rotation !== 0) {
+        t.action = 'rotate';
+        this._rotateObjectByAngle(self.rotation, e);
+      }
+
+      this.requestRenderAll();
+
+      t.action = 'drag';
+    },
+
+    /**
+     * Method that defines actions when an Event.js drag is detected.
+     *
+     * @param {Event} e Event object by Event.js
+     * @param {Event} self Event proxy object by Event.js
+     */
+    __onDrag: function(e, self) {
+      this.fire('touch:drag', {
+        e: e, self: self
+      });
+    },
+
+    /**
+     * Method that defines actions when an Event.js orientation event is detected.
+     *
+     * @param {Event} e Event object by Event.js
+     * @param {Event} self Event proxy object by Event.js
+     */
+    __onOrientationChange: function(e, self) {
+      this.fire('touch:orientation', {
+        e: e, self: self
+      });
+    },
+
+    /**
+     * Method that defines actions when an Event.js shake event is detected.
+     *
+     * @param {Event} e Event object by Event.js
+     * @param {Event} self Event proxy object by Event.js
+     */
+    __onShake: function(e, self) {
+      this.fire('touch:shake', {
+        e: e, self: self
+      });
+    },
+
+    /**
+     * Method that defines actions when an Event.js longpress event is detected.
+     *
+     * @param {Event} e Event object by Event.js
+     * @param {Event} self Event proxy object by Event.js
+     */
+    __onLongPress: function(e, self) {
+      this.fire('touch:longpress', {
+        e: e, self: self
+      });
+    },
+
+    /**
+     * Scales an object by a factor
+     * @param {Number} s The scale factor to apply to the current scale level
+     * @param {Event} e Event object by Event.js
+     */
+    _scaleObjectBy: function(s, e) {
+      var t = this._currentTransform,
+          target = t.target;
+      t.gestureScale = s;
+      target._scaling = true;
+      return fabric.controlsUtils.scalingEqually(e, t, 0, 0);
+    },
+
+    /**
+     * Rotates object by an angle
+     * @param {Number} curAngle The angle of rotation in degrees
+     * @param {Event} e Event object by Event.js
+     */
+    _rotateObjectByAngle: function(curAngle, e) {
+      var t = this._currentTransform;
+
+      if (t.target.get('lockRotation')) {
+        return;
+      }
+      t.target.rotate(radiansToDegrees(degreesToRadians(curAngle) + t.theta));
+      this._fire('rotating', {
+        target: t.target,
+        e: e,
+        transform: t,
+      });
+    }
+  });
+})();
+
+
 (function(global) {
 
   'use strict';
@@ -14495,3548 +17164,4383 @@ fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.Stati
     hasControls:              true,
 
     /**
-     * When set to `false`, object's controlling borders are not rendered
-     * @type Boolean
+     * When set to `false`, object's controlling borders are not rendered
+     * @type Boolean
+     * @default
+     */
+    hasBorders:               true,
+
+    /**
+     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
+     * @type Boolean
+     * @default
+     */
+    perPixelTargetFind:       false,
+
+    /**
+     * When `false`, default object's values are not included in its serialization
+     * @type Boolean
+     * @default
+     */
+    includeDefaultValues:     true,
+
+    /**
+     * When `true`, object horizontal movement is locked
+     * @type Boolean
+     * @default
+     */
+    lockMovementX:            false,
+
+    /**
+     * When `true`, object vertical movement is locked
+     * @type Boolean
+     * @default
+     */
+    lockMovementY:            false,
+
+    /**
+     * When `true`, object rotation is locked
+     * @type Boolean
+     * @default
+     */
+    lockRotation:             false,
+
+    /**
+     * When `true`, object horizontal scaling is locked
+     * @type Boolean
+     * @default
+     */
+    lockScalingX:             false,
+
+    /**
+     * When `true`, object vertical scaling is locked
+     * @type Boolean
+     * @default
+     */
+    lockScalingY:             false,
+
+    /**
+     * When `true`, object horizontal skewing is locked
+     * @type Boolean
+     * @default
+     */
+    lockSkewingX:             false,
+
+    /**
+     * When `true`, object vertical skewing is locked
+     * @type Boolean
+     * @default
+     */
+    lockSkewingY:             false,
+
+    /**
+     * When `true`, object cannot be flipped by scaling into negative values
+     * @type Boolean
+     * @default
+     */
+    lockScalingFlip:          false,
+
+    /**
+     * When `true`, object is not exported in OBJECT/JSON
+     * @since 1.6.3
+     * @type Boolean
+     * @default
+     */
+    excludeFromExport:        false,
+
+    /**
+     * When `true`, object is cached on an additional canvas.
+     * When `false`, object is not cached unless necessary ( clipPath )
+     * default to true
+     * @since 1.7.0
+     * @type Boolean
+     * @default true
+     */
+    objectCaching:            objectCaching,
+
+    /**
+     * When `true`, object properties are checked for cache invalidation. In some particular
+     * situation you may want this to be disabled ( spray brush, very big, groups)
+     * or if your application does not allow you to modify properties for groups child you want
+     * to disable it for groups.
+     * default to false
+     * since 1.7.0
+     * @type Boolean
+     * @default false
+     */
+    statefullCache:            false,
+
+    /**
+     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
+     * too much and will be redrawn with correct details at the end of scaling.
+     * this setting is performance and application dependant.
+     * default to true
+     * since 1.7.0
+     * @type Boolean
+     * @default true
+     */
+    noScaleCache:              true,
+
+    /**
+     * When `false`, the stoke width will scale with the object.
+     * When `true`, the stroke will always match the exact pixel size entered for stroke width.
+     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods
+     * default to false
+     * @since 2.6.0
+     * @type Boolean
+     * @default false
+     * @type Boolean
+     * @default false
+     */
+    strokeUniform:              false,
+
+    /**
+     * When set to `true`, object's cache will be rerendered next render call.
+     * since 1.7.0
+     * @type Boolean
+     * @default true
+     */
+    dirty:                true,
+
+    /**
+     * keeps the value of the last hovered corner during mouse move.
+     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
+     * It should be private, but there is no harm in using it as
+     * a read-only property.
+     * @type number|string|any
+     * @default 0
+     */
+    __corner: 0,
+
+    /**
+     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
+     * @type String
      * @default
      */
-    hasBorders:               true,
+    paintFirst:           'fill',
 
     /**
-     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
-     * @type Boolean
-     * @default
+     * When 'down', object is set to active on mousedown/touchstart
+     * When 'up', object is set to active on mouseup/touchend
+     * Experimental. Let's see if this breaks anything before supporting officially
+     * @private
+     * since 4.4.0
+     * @type String
+     * @default 'down'
      */
-    perPixelTargetFind:       false,
+    activeOn:           'down',
 
     /**
-     * When `false`, default object's values are not included in its serialization
-     * @type Boolean
-     * @default
+     * List of properties to consider when checking if state
+     * of an object is changed (fabric.Object#hasStateChanged)
+     * as well as for history (undo/redo) purposes
+     * @type Array
      */
-    includeDefaultValues:     true,
+    stateProperties: (
+      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
+      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
+      'angle opacity fill globalCompositeOperation shadow visible backgroundColor ' +
+      'skewX skewY fillRule paintFirst clipPath strokeUniform'
+    ).split(' '),
 
     /**
-     * When `true`, object horizontal movement is locked
-     * @type Boolean
-     * @default
+     * List of properties to consider when checking if cache needs refresh
+     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
+     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
+     * and refreshed at the next render
+     * @type Array
      */
-    lockMovementX:            false,
+    cacheProperties: (
+      'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
+      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
+    ).split(' '),
 
     /**
-     * When `true`, object vertical movement is locked
-     * @type Boolean
-     * @default
+     * List of properties to consider for animating colors.
+     * @type Array
      */
-    lockMovementY:            false,
+    colorProperties: (
+      'fill stroke backgroundColor'
+    ).split(' '),
 
     /**
-     * When `true`, object rotation is locked
-     * @type Boolean
-     * @default
+     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
+     * the clipPath object gets used when the object has rendered, and the context is placed in the center
+     * of the object cacheCanvas.
+     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
+     * @type fabric.Object
      */
-    lockRotation:             false,
+    clipPath: undefined,
 
     /**
-     * When `true`, object horizontal scaling is locked
-     * @type Boolean
-     * @default
+     * Meaningful ONLY when the object is used as clipPath.
+     * if true, the clipPath will make the object clip to the outside of the clipPath
+     * since 2.4.0
+     * @type boolean
+     * @default false
      */
-    lockScalingX:             false,
+    inverted: false,
 
     /**
-     * When `true`, object vertical scaling is locked
-     * @type Boolean
-     * @default
+     * Meaningful ONLY when the object is used as clipPath.
+     * if true, the clipPath will have its top and left relative to canvas, and will
+     * not be influenced by the object transform. This will make the clipPath relative
+     * to the canvas, but clipping just a particular object.
+     * WARNING this is beta, this feature may change or be renamed.
+     * since 2.4.0
+     * @type boolean
+     * @default false
      */
-    lockScalingY:             false,
+    absolutePositioned: false,
 
     /**
-     * When `true`, object horizontal skewing is locked
-     * @type Boolean
-     * @default
+     * Constructor
+     * @param {Object} [options] Options object
      */
-    lockSkewingX:             false,
+    initialize: function(options) {
+      if (options) {
+        this.setOptions(options);
+      }
+    },
 
     /**
-     * When `true`, object vertical skewing is locked
-     * @type Boolean
-     * @default
+     * Create a the canvas used to keep the cached copy of the object
+     * @private
      */
-    lockSkewingY:             false,
+    _createCacheCanvas: function() {
+      this._cacheProperties = {};
+      this._cacheCanvas = fabric.util.createCanvasElement();
+      this._cacheContext = this._cacheCanvas.getContext('2d');
+      this._updateCacheCanvas();
+      // if canvas gets created, is empty, so dirty.
+      this.dirty = true;
+    },
 
     /**
-     * When `true`, object cannot be flipped by scaling into negative values
-     * @type Boolean
-     * @default
+     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
+     * and each side do not cross fabric.cacheSideLimit
+     * those numbers are configurable so that you can get as much detail as you want
+     * making bargain with performances.
+     * @param {Object} dims
+     * @param {Object} dims.width width of canvas
+     * @param {Object} dims.height height of canvas
+     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
+     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
+     * @return {Object}.width width of canvas
+     * @return {Object}.height height of canvas
+     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
+     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
      */
-    lockScalingFlip:          false,
+    _limitCacheSize: function(dims) {
+      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
+          width = dims.width, height = dims.height,
+          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
+      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
+        if (width < min) {
+          dims.width = min;
+        }
+        if (height < min) {
+          dims.height = min;
+        }
+        return dims;
+      }
+      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
+          capValue = fabric.util.capValue,
+          x = capValue(min, limitedDims.x, max),
+          y = capValue(min, limitedDims.y, max);
+      if (width > x) {
+        dims.zoomX /= width / x;
+        dims.width = x;
+        dims.capped = true;
+      }
+      if (height > y) {
+        dims.zoomY /= height / y;
+        dims.height = y;
+        dims.capped = true;
+      }
+      return dims;
+    },
 
     /**
-     * When `true`, object is not exported in OBJECT/JSON
-     * @since 1.6.3
-     * @type Boolean
-     * @default
+     * Return the dimension and the zoom level needed to create a cache canvas
+     * big enough to host the object to be cached.
+     * @private
+     * @return {Object}.x width of object to be cached
+     * @return {Object}.y height of object to be cached
+     * @return {Object}.width width of canvas
+     * @return {Object}.height height of canvas
+     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
+     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
      */
-    excludeFromExport:        false,
+    _getCacheCanvasDimensions: function() {
+      var objectScale = this.getTotalObjectScaling(),
+          // caculate dimensions without skewing
+          dim = this._getTransformedDimensions(0, 0),
+          neededX = dim.x * objectScale.scaleX / this.scaleX,
+          neededY = dim.y * objectScale.scaleY / this.scaleY;
+      return {
+        // for sure this ALIASING_LIMIT is slightly creating problem
+        // in situation in which the cache canvas gets an upper limit
+        // also objectScale contains already scaleX and scaleY
+        width: neededX + ALIASING_LIMIT,
+        height: neededY + ALIASING_LIMIT,
+        zoomX: objectScale.scaleX,
+        zoomY: objectScale.scaleY,
+        x: neededX,
+        y: neededY
+      };
+    },
 
     /**
-     * When `true`, object is cached on an additional canvas.
-     * When `false`, object is not cached unless necessary ( clipPath )
-     * default to true
-     * @since 1.7.0
-     * @type Boolean
-     * @default true
+     * Update width and height of the canvas for cache
+     * returns true or false if canvas needed resize.
+     * @private
+     * @return {Boolean} true if the canvas has been resized
      */
-    objectCaching:            objectCaching,
+    _updateCacheCanvas: function() {
+      var targetCanvas = this.canvas;
+      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
+        var target = targetCanvas._currentTransform.target,
+            action = targetCanvas._currentTransform.action;
+        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
+          return false;
+        }
+      }
+      var canvas = this._cacheCanvas,
+          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
+          minCacheSize = fabric.minCacheSideLimit,
+          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
+          zoomX = dims.zoomX, zoomY = dims.zoomY,
+          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
+          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
+          shouldRedraw = dimensionsChanged || zoomChanged,
+          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
+      if (dimensionsChanged) {
+        var canvasWidth = this._cacheCanvas.width,
+            canvasHeight = this._cacheCanvas.height,
+            sizeGrowing = width > canvasWidth || height > canvasHeight,
+            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
+              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
+        shouldResizeCanvas = sizeGrowing || sizeShrinking;
+        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
+          additionalWidth = width * 0.1;
+          additionalHeight = height * 0.1;
+        }
+      }
+      if (this instanceof fabric.Text && this.path) {
+        shouldRedraw = true;
+        shouldResizeCanvas = true;
+        additionalWidth += this.getHeightOfLine(0) * this.zoomX;
+        additionalHeight += this.getHeightOfLine(0) * this.zoomY;
+      }
+      if (shouldRedraw) {
+        if (shouldResizeCanvas) {
+          canvas.width = Math.ceil(width + additionalWidth);
+          canvas.height = Math.ceil(height + additionalHeight);
+        }
+        else {
+          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
+          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
+        }
+        drawingWidth = dims.x / 2;
+        drawingHeight = dims.y / 2;
+        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
+        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
+        this.cacheWidth = width;
+        this.cacheHeight = height;
+        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
+        this._cacheContext.scale(zoomX, zoomY);
+        this.zoomX = zoomX;
+        this.zoomY = zoomY;
+        return true;
+      }
+      return false;
+    },
 
     /**
-     * When `true`, object properties are checked for cache invalidation. In some particular
-     * situation you may want this to be disabled ( spray brush, very big, groups)
-     * or if your application does not allow you to modify properties for groups child you want
-     * to disable it for groups.
-     * default to false
-     * since 1.7.0
-     * @type Boolean
-     * @default false
+     * Sets object's properties from options
+     * @param {Object} [options] Options object
      */
-    statefullCache:            false,
+    setOptions: function(options) {
+      this._setOptions(options);
+      this._initGradient(options.fill, 'fill');
+      this._initGradient(options.stroke, 'stroke');
+      this._initPattern(options.fill, 'fill');
+      this._initPattern(options.stroke, 'stroke');
+    },
 
     /**
-     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
-     * too much and will be redrawn with correct details at the end of scaling.
-     * this setting is performance and application dependant.
-     * default to true
-     * since 1.7.0
-     * @type Boolean
-     * @default true
+     * Transforms context when rendering an object
+     * @param {CanvasRenderingContext2D} ctx Context
      */
-    noScaleCache:              true,
+    transform: function(ctx) {
+      var needFullTransform = (this.group && !this.group._transformDone) ||
+         (this.group && this.canvas && ctx === this.canvas.contextTop);
+      var m = this.calcTransformMatrix(!needFullTransform);
+      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
+    },
 
     /**
-     * When `false`, the stoke width will scale with the object.
-     * When `true`, the stroke will always match the exact pixel size entered for stroke width.
-     * default to false
-     * @since 2.6.0
-     * @type Boolean
-     * @default false
-     * @type Boolean
-     * @default false
+     * Returns an object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} Object representation of an instance
      */
-    strokeUniform:              false,
+    toObject: function(propertiesToInclude) {
+      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
 
-    /**
-     * When set to `true`, object's cache will be rerendered next render call.
-     * since 1.7.0
-     * @type Boolean
-     * @default true
-     */
-    dirty:                true,
+          object = {
+            type:                     this.type,
+            version:                  fabric.version,
+            originX:                  this.originX,
+            originY:                  this.originY,
+            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
+            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
+            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
+            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
+            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
+            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
+            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
+            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
+            strokeLineCap:            this.strokeLineCap,
+            strokeDashOffset:         this.strokeDashOffset,
+            strokeLineJoin:           this.strokeLineJoin,
+            strokeUniform:            this.strokeUniform,
+            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
+            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
+            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
+            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
+            flipX:                    this.flipX,
+            flipY:                    this.flipY,
+            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
+            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
+            visible:                  this.visible,
+            backgroundColor:          this.backgroundColor,
+            fillRule:                 this.fillRule,
+            paintFirst:               this.paintFirst,
+            globalCompositeOperation: this.globalCompositeOperation,
+            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
+            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
+          };
+
+      if (this.clipPath && !this.clipPath.excludeFromExport) {
+        object.clipPath = this.clipPath.toObject(propertiesToInclude);
+        object.clipPath.inverted = this.clipPath.inverted;
+        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
+      }
+
+      fabric.util.populateWithProperties(this, object, propertiesToInclude);
+      if (!this.includeDefaultValues) {
+        object = this._removeDefaultValues(object);
+      }
+
+      return object;
+    },
 
     /**
-     * keeps the value of the last hovered corner during mouse move.
-     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
-     * It should be private, but there is no harm in using it as
-     * a read-only property.
-     * @type number|string|any
-     * @default 0
+     * Returns (dataless) object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} Object representation of an instance
      */
-    __corner: 0,
+    toDatalessObject: function(propertiesToInclude) {
+      // will be overwritten by subclasses
+      return this.toObject(propertiesToInclude);
+    },
 
     /**
-     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
-     * @type String
-     * @default
+     * @private
+     * @param {Object} object
      */
-    paintFirst:           'fill',
+    _removeDefaultValues: function(object) {
+      var prototype = fabric.util.getKlass(object.type).prototype,
+          stateProperties = prototype.stateProperties;
+      stateProperties.forEach(function(prop) {
+        if (prop === 'left' || prop === 'top') {
+          return;
+        }
+        if (object[prop] === prototype[prop]) {
+          delete object[prop];
+        }
+        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
+                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';
+
+        // basically a check for [] === []
+        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
+          delete object[prop];
+        }
+      });
+
+      return object;
+    },
 
     /**
-     * When 'down', object is set to active on mousedown/touchstart
-     * When 'up', object is set to active on mouseup/touchend
-     * Experimental. Let's see if this breaks anything before supporting officially
-     * @private
-     * since 4.4.0
-     * @type String
-     * @default 'down'
+     * Returns a string representation of an instance
+     * @return {String}
      */
-    activeOn:           'down',
+    toString: function() {
+      return '#<fabric.' + capitalize(this.type) + '>';
+    },
 
     /**
-     * List of properties to consider when checking if state
-     * of an object is changed (fabric.Object#hasStateChanged)
-     * as well as for history (undo/redo) purposes
-     * @type Array
+     * Return the object scale factor counting also the group scaling
+     * @return {Object} object with scaleX and scaleY properties
      */
-    stateProperties: (
-      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
-      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
-      'angle opacity fill globalCompositeOperation shadow visible backgroundColor ' +
-      'skewX skewY fillRule paintFirst clipPath strokeUniform'
-    ).split(' '),
+    getObjectScaling: function() {
+      // if the object is a top level one, on the canvas, we go for simple aritmetic
+      // otherwise the complex method with angles will return approximations and decimals
+      // and will likely kill the cache when not needed
+      // https://github.com/fabricjs/fabric.js/issues/7157
+      if (!this.group) {
+        return {
+          scaleX: this.scaleX,
+          scaleY: this.scaleY,
+        };
+      }
+      // if we are inside a group total zoom calculation is complex, we defer to generic matrices
+      var options = fabric.util.qrDecompose(this.calcTransformMatrix());
+      return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
+    },
 
     /**
-     * List of properties to consider when checking if cache needs refresh
-     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
-     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
-     * and refreshed at the next render
-     * @type Array
+     * Return the object scale factor counting also the group scaling, zoom and retina
+     * @return {Object} object with scaleX and scaleY properties
      */
-    cacheProperties: (
-      'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
-      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
-    ).split(' '),
+    getTotalObjectScaling: function() {
+      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
+      if (this.canvas) {
+        var zoom = this.canvas.getZoom();
+        var retina = this.canvas.getRetinaScaling();
+        scaleX *= zoom * retina;
+        scaleY *= zoom * retina;
+      }
+      return { scaleX: scaleX, scaleY: scaleY };
+    },
 
     /**
-     * List of properties to consider for animating colors.
-     * @type Array
+     * Return the object opacity counting also the group property
+     * @return {Number}
      */
-    colorProperties: (
-      'fill stroke backgroundColor'
-    ).split(' '),
+    getObjectOpacity: function() {
+      var opacity = this.opacity, parent = this.group || this.parent;
+      if (parent) {
+        opacity *= parent.getObjectOpacity();
+      }
+      return opacity;
+    },
 
     /**
-     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
-     * the clipPath object gets used when the object has rendered, and the context is placed in the center
-     * of the object cacheCanvas.
-     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
-     * @type fabric.Object
+     * @private
+     * @param {String} key
+     * @param {*} value
+     * @return {fabric.Object} thisArg
      */
-    clipPath: undefined,
+    _set: function(key, value) {
+      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
+          isChanged = this[key] !== value;
+
+      if (shouldConstrainValue) {
+        value = this._constrainScale(value);
+      }
+      if (key === 'scaleX' && value < 0) {
+        this.flipX = !this.flipX;
+        value *= -1;
+      }
+      else if (key === 'scaleY' && value < 0) {
+        this.flipY = !this.flipY;
+        value *= -1;
+      }
+      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
+        value = new fabric.Shadow(value);
+      }
+      else if (key === 'dirty') {
+        this.group && this.group.set('dirty', value);
+        this.parent && this.parent.set('dirty', value);
+      }
+
+      this[key] = value;
+
+      if (isChanged) {
+        var parent = this.group || this.parent;
+        if (this.cacheProperties.indexOf(key) > -1) {
+          this.dirty = true;
+        }
+        if (parent && parent.isOnACache() && (this.dirty || this.stateProperties.indexOf(key) > -1)) {
+          parent.set('dirty', true);
+        }
+      }
+      return this;
+    },
 
     /**
-     * Meaningful ONLY when the object is used as clipPath.
-     * if true, the clipPath will make the object clip to the outside of the clipPath
-     * since 2.4.0
-     * @type boolean
-     * @default false
+     * This callback function is called by the parent group of an object every
+     * time a non-delegated property changes on the group. It is passed the key
+     * and value as parameters. Not adding in this function's signature to avoid
+     * Travis build error about unused variables.
      */
-    inverted: false,
+    setOnGroup: function() {
+      // implemented by sub-classes, as needed.
+    },
 
     /**
-     * Meaningful ONLY when the object is used as clipPath.
-     * if true, the clipPath will have its top and left relative to canvas, and will
-     * not be influenced by the object transform. This will make the clipPath relative
-     * to the canvas, but clipping just a particular object.
-     * WARNING this is beta, this feature may change or be renamed.
-     * since 2.4.0
-     * @type boolean
-     * @default false
+     * Retrieves viewportTransform from Object's canvas if possible
+     * @method getViewportTransform
+     * @memberOf fabric.Object.prototype
+     * @return {Array}
      */
-    absolutePositioned: false,
+    getViewportTransform: function() {
+      if (this.canvas && this.canvas.viewportTransform) {
+        return this.canvas.viewportTransform;
+      }
+      return fabric.iMatrix.concat();
+    },
 
     /**
-     * Constructor
-     * @param {Object} [options] Options object
+     * @private
+     * return if the object would be visible in rendering
+     * @memberOf fabric.Object.prototype
+     * @return {Boolean}
      */
-    initialize: function(options) {
-      if (options) {
-        this.setOptions(options);
-      }
+    isNotVisible: function() {
+      return this.opacity === 0 ||
+        (!this.width && !this.height && this.strokeWidth === 0) ||
+        !this.visible;
     },
 
     /**
-     * Create a the canvas used to keep the cached copy of the object
+     * used by canvas' active object logic to determine `subTargets`
      * @private
+     * @memberOf fabric.Object.prototype
+     * @returns {boolean}
      */
-    _createCacheCanvas: function() {
-      this._cacheProperties = {};
-      this._cacheCanvas = fabric.util.createCanvasElement();
-      this._cacheContext = this._cacheCanvas.getContext('2d');
-      this._updateCacheCanvas();
-      // if canvas gets created, is empty, so dirty.
-      this.dirty = true;
+    isSelectable: function() {
+      return this.selectable && this.evented && !this.isNotVisible() && this.isOnScreen();
     },
 
     /**
-     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
-     * and each side do not cross fabric.cacheSideLimit
-     * those numbers are configurable so that you can get as much detail as you want
-     * making bargain with performances.
-     * @param {Object} dims
-     * @param {Object} dims.width width of canvas
-     * @param {Object} dims.height height of canvas
-     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
-     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
-     * @return {Object}.width width of canvas
-     * @return {Object}.height height of canvas
-     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
-     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
+     * Renders an object on a specified context
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    _limitCacheSize: function(dims) {
-      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
-          width = dims.width, height = dims.height,
-          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
-      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
-        if (width < min) {
-          dims.width = min;
-        }
-        if (height < min) {
-          dims.height = min;
+    render: function(ctx) {
+      // do not render if width/height are zeros or object is not visible
+      if (this.isNotVisible()) {
+        return;
+      }
+      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
+        return;
+      }
+      ctx.save();
+      this._setupCompositeOperation(ctx);
+      this.drawSelectionBackground(ctx);
+      this.transform(ctx);
+      this._setOpacity(ctx);
+      this._setShadow(ctx, this);
+      if (this.shouldCache()) {
+        this.renderCache();
+        this.drawCacheOnCanvas(ctx);
+      }
+      else {
+        this._removeCacheCanvas();
+        this.dirty = false;
+        this.drawObject(ctx);
+        if (this.objectCaching && this.statefullCache) {
+          this.saveState({ propertySet: 'cacheProperties' });
         }
-        return dims;
       }
-      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
-          capValue = fabric.util.capValue,
-          x = capValue(min, limitedDims.x, max),
-          y = capValue(min, limitedDims.y, max);
-      if (width > x) {
-        dims.zoomX /= width / x;
-        dims.width = x;
-        dims.capped = true;
+      ctx.restore();
+    },
+
+    renderCache: function(options) {
+      options = options || {};
+      if (!this._cacheCanvas) {
+        this._createCacheCanvas();
       }
-      if (height > y) {
-        dims.zoomY /= height / y;
-        dims.height = y;
-        dims.capped = true;
+      if (this.isCacheDirty()) {
+        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
+        this.drawObject(this._cacheContext, options.forClipping);
+        this.dirty = false;
       }
-      return dims;
     },
 
     /**
-     * Return the dimension and the zoom level needed to create a cache canvas
-     * big enough to host the object to be cached.
-     * @private
-     * @return {Object}.x width of object to be cached
-     * @return {Object}.y height of object to be cached
-     * @return {Object}.width width of canvas
-     * @return {Object}.height height of canvas
-     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
-     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
+     * Remove cacheCanvas and its dimensions from the objects
      */
-    _getCacheCanvasDimensions: function() {
-      var objectScale = this.getTotalObjectScaling(),
-          // caculate dimensions without skewing
-          dim = this._getTransformedDimensions(0, 0),
-          neededX = dim.x * objectScale.scaleX / this.scaleX,
-          neededY = dim.y * objectScale.scaleY / this.scaleY;
-      return {
-        // for sure this ALIASING_LIMIT is slightly creating problem
-        // in situation in which the cache canvas gets an upper limit
-        // also objectScale contains already scaleX and scaleY
-        width: neededX + ALIASING_LIMIT,
-        height: neededY + ALIASING_LIMIT,
-        zoomX: objectScale.scaleX,
-        zoomY: objectScale.scaleY,
-        x: neededX,
-        y: neededY
-      };
+    _removeCacheCanvas: function() {
+      this._cacheCanvas = null;
+      this.cacheWidth = 0;
+      this.cacheHeight = 0;
     },
 
     /**
-     * Update width and height of the canvas for cache
-     * returns true or false if canvas needed resize.
-     * @private
-     * @return {Boolean} true if the canvas has been resized
+     * return true if the object will draw a stroke
+     * Does not consider text styles. This is just a shortcut used at rendering time
+     * We want it to be an approximation and be fast.
+     * wrote to avoid extra caching, it has to return true when stroke happens,
+     * can guess when it will not happen at 100% chance, does not matter if it misses
+     * some use case where the stroke is invisible.
+     * @since 3.0.0
+     * @returns Boolean
      */
-    _updateCacheCanvas: function() {
-      var targetCanvas = this.canvas;
-      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
-        var target = targetCanvas._currentTransform.target,
-            action = targetCanvas._currentTransform.action;
-        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
-          return false;
-        }
-      }
-      var canvas = this._cacheCanvas,
-          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
-          minCacheSize = fabric.minCacheSideLimit,
-          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
-          zoomX = dims.zoomX, zoomY = dims.zoomY,
-          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
-          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
-          shouldRedraw = dimensionsChanged || zoomChanged,
-          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
-      if (dimensionsChanged) {
-        var canvasWidth = this._cacheCanvas.width,
-            canvasHeight = this._cacheCanvas.height,
-            sizeGrowing = width > canvasWidth || height > canvasHeight,
-            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
-              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
-        shouldResizeCanvas = sizeGrowing || sizeShrinking;
-        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
-          additionalWidth = width * 0.1;
-          additionalHeight = height * 0.1;
-        }
-      }
-      if (this instanceof fabric.Text && this.path) {
-        shouldRedraw = true;
-        shouldResizeCanvas = true;
-        additionalWidth += this.getHeightOfLine(0) * this.zoomX;
-        additionalHeight += this.getHeightOfLine(0) * this.zoomY;
-      }
-      if (shouldRedraw) {
-        if (shouldResizeCanvas) {
-          canvas.width = Math.ceil(width + additionalWidth);
-          canvas.height = Math.ceil(height + additionalHeight);
-        }
-        else {
-          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
-          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
-        }
-        drawingWidth = dims.x / 2;
-        drawingHeight = dims.y / 2;
-        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
-        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
-        this.cacheWidth = width;
-        this.cacheHeight = height;
-        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
-        this._cacheContext.scale(zoomX, zoomY);
-        this.zoomX = zoomX;
-        this.zoomY = zoomY;
+    hasStroke: function() {
+      return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
+    },
+
+    /**
+     * return true if the object will draw a fill
+     * Does not consider text styles. This is just a shortcut used at rendering time
+     * We want it to be an approximation and be fast.
+     * wrote to avoid extra caching, it has to return true when fill happens,
+     * can guess when it will not happen at 100% chance, does not matter if it misses
+     * some use case where the fill is invisible.
+     * @since 3.0.0
+     * @returns Boolean
+     */
+    hasFill: function() {
+      return this.fill && this.fill !== 'transparent';
+    },
+
+    /**
+     * When set to `true`, force the object to have its own cache, even if it is inside a group
+     * it may be needed when your object behave in a particular way on the cache and always needs
+     * its own isolated canvas to render correctly.
+     * Created to be overridden
+     * since 1.7.12
+     * @returns Boolean
+     */
+    needsItsOwnCache: function() {
+      if (this.paintFirst === 'stroke' &&
+        this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
+        return true;
+      }
+      if (this.clipPath) {
         return true;
       }
       return false;
     },
 
     /**
-     * Sets object's properties from options
-     * @param {Object} [options] Options object
+     * Decide if the object should cache or not. Create its own cache level
+     * objectCaching is a global flag, wins over everything
+     * needsItsOwnCache should be used when the object drawing method requires
+     * a cache step. None of the fabric classes requires it.
+     * Generally you do not cache objects in groups because the group outside is cached.
+     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
+     * @return {Boolean}
      */
-    setOptions: function(options) {
-      this._setOptions(options);
-      this._initGradient(options.fill, 'fill');
-      this._initGradient(options.stroke, 'stroke');
-      this._initPattern(options.fill, 'fill');
-      this._initPattern(options.stroke, 'stroke');
+    shouldCache: function () {
+      var parent = this.group || this.parent;
+      this.ownCaching = this.needsItsOwnCache() || (this.objectCaching && (!parent || !parent.isOnACache()));
+      return this.ownCaching;
     },
 
     /**
-     * Transforms context when rendering an object
-     * @param {CanvasRenderingContext2D} ctx Context
+     * Check if this object or a child object will cast a shadow
+     * used by Group.shouldCache to know if child has a shadow recursively
+     * @return {Boolean}
      */
-    transform: function(ctx) {
-      var needFullTransform = (this.group && !this.group._transformDone) ||
-         (this.group && this.canvas && ctx === this.canvas.contextTop);
-      var m = this.calcTransformMatrix(!needFullTransform);
-      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
+    willDrawShadow: function() {
+      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
     },
 
     /**
-     * Returns an object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} Object representation of an instance
+     * Execute the drawing operation for an object clipPath
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    toObject: function(propertiesToInclude) {
-      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
-
-          object = {
-            type:                     this.type,
-            version:                  fabric.version,
-            originX:                  this.originX,
-            originY:                  this.originY,
-            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
-            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
-            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
-            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
-            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
-            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
-            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
-            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
-            strokeLineCap:            this.strokeLineCap,
-            strokeDashOffset:         this.strokeDashOffset,
-            strokeLineJoin:           this.strokeLineJoin,
-            strokeUniform:            this.strokeUniform,
-            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
-            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
-            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
-            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
-            flipX:                    this.flipX,
-            flipY:                    this.flipY,
-            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
-            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
-            visible:                  this.visible,
-            backgroundColor:          this.backgroundColor,
-            fillRule:                 this.fillRule,
-            paintFirst:               this.paintFirst,
-            globalCompositeOperation: this.globalCompositeOperation,
-            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
-            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
-          };
-
-      if (this.clipPath && !this.clipPath.excludeFromExport) {
-        object.clipPath = this.clipPath.toObject(propertiesToInclude);
-        object.clipPath.inverted = this.clipPath.inverted;
-        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
+    drawClipPathOnCache: function(ctx) {
+      var path = this.clipPath;
+      ctx.save();
+      // DEBUG: uncomment this line, comment the following
+      // ctx.globalAlpha = 0.4
+      if (path.inverted) {
+        ctx.globalCompositeOperation = 'destination-out';
+      }
+      else {
+        ctx.globalCompositeOperation = 'destination-in';
+      }
+      //ctx.scale(1 / 2, 1 / 2);
+      if (path.absolutePositioned) {
+        var m = fabric.util.invertTransform(this.calcTransformMatrix());
+        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
       }
+      path.transform(ctx);
+      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
+      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
+      ctx.restore();
+    },
 
-      fabric.util.populateWithProperties(this, object, propertiesToInclude);
-      if (!this.includeDefaultValues) {
-        object = this._removeDefaultValues(object);
+    /**
+     * Execute the drawing operation for an object on a specified context
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     */
+    drawObject: function(ctx, forClipping) {
+      var originalFill = this.fill, originalStroke = this.stroke;
+      if (forClipping) {
+        this.fill = 'black';
+        this.stroke = '';
+        this._setClippingProperties(ctx);
+      }
+      else {
+        this._renderBackground(ctx);
       }
+      this._render(ctx);
+      this._drawClipPath(ctx);
+      this.fill = originalFill;
+      this.stroke = originalStroke;
+    },
 
-      return object;
+    _drawClipPath: function(ctx) {
+      var path = this.clipPath;
+      if (!path) { return; }
+      // needed to setup a couple of variables
+      // path canvas gets overridden with this one.
+      // TODO find a better solution?
+      path.canvas = this.canvas;
+      path.shouldCache();
+      path._transformDone = true;
+      path.renderCache({ forClipping: true });
+      this.drawClipPathOnCache(ctx);
     },
 
     /**
-     * Returns (dataless) object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} Object representation of an instance
+     * Paint the cached copy of the object on the target context.
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    toDatalessObject: function(propertiesToInclude) {
-      // will be overwritten by subclasses
-      return this.toObject(propertiesToInclude);
+    drawCacheOnCanvas: function(ctx) {
+      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
+      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
+    },
+
+    /**
+     * Check if cache is dirty
+     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
+     * on parent canvas.
+     */
+    isCacheDirty: function(skipCanvas) {
+      if (this.isNotVisible()) {
+        return false;
+      }
+      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
+        // in this case the context is already cleared.
+        return true;
+      }
+      else {
+        if (this.dirty ||
+          (this.clipPath && this.clipPath.absolutePositioned) ||
+          (this.statefullCache && this.hasStateChanged('cacheProperties'))
+        ) {
+          if (this._cacheCanvas && !skipCanvas) {
+            var width = this.cacheWidth / this.zoomX;
+            var height = this.cacheHeight / this.zoomY;
+            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
+          }
+          return true;
+        }
+      }
+      return false;
     },
 
     /**
+     * Draws a background for the object big as its untransformed dimensions
      * @private
-     * @param {Object} object
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    _removeDefaultValues: function(object) {
-      var prototype = fabric.util.getKlass(object.type).prototype,
-          stateProperties = prototype.stateProperties;
-      stateProperties.forEach(function(prop) {
-        if (prop === 'left' || prop === 'top') {
-          return;
+    _renderBackground: function(ctx) {
+      if (!this.backgroundColor) {
+        return;
+      }
+      var dim = this._getNonTransformedDimensions();
+      ctx.fillStyle = this.backgroundColor;
+
+      ctx.fillRect(
+        -dim.x / 2,
+        -dim.y / 2,
+        dim.x,
+        dim.y
+      );
+      // if there is background color no other shadows
+      // should be casted
+      this._removeShadow(ctx);
+    },
+
+    /**
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     */
+    _setOpacity: function (ctx) {
+      var parent = this.group || this.parent;
+      if (parent && !parent._transformDone) {
+        ctx.globalAlpha = this.getObjectOpacity();
+      }
+      else {
+        ctx.globalAlpha *= this.opacity;
+      }
+    },
+
+    _setStrokeStyles: function(ctx, decl) {
+      var stroke = decl.stroke;
+      if (stroke) {
+        ctx.lineWidth = decl.strokeWidth;
+        ctx.lineCap = decl.strokeLineCap;
+        ctx.lineDashOffset = decl.strokeDashOffset;
+        ctx.lineJoin = decl.strokeLineJoin;
+        ctx.miterLimit = decl.strokeMiterLimit;
+        if (stroke.toLive) {
+          if (stroke.gradientUnits === 'percentage' || stroke.gradientTransform || stroke.patternTransform) {
+            // need to transform gradient in a pattern.
+            // this is a slow process. If you are hitting this codepath, and the object
+            // is not using caching, you should consider switching it on.
+            // we need a canvas as big as the current object caching canvas.
+            this._applyPatternForTransformedGradient(ctx, stroke);
+          }
+          else {
+            // is a simple gradient or pattern
+            ctx.strokeStyle = stroke.toLive(ctx, this);
+            this._applyPatternGradientTransform(ctx, stroke);
+          }
         }
-        if (object[prop] === prototype[prop]) {
-          delete object[prop];
+        else {
+          // is a color
+          ctx.strokeStyle = decl.stroke;
         }
-        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
-                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';
+      }
+    },
 
-        // basically a check for [] === []
-        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
-          delete object[prop];
+    _setFillStyles: function(ctx, decl) {
+      var fill = decl.fill;
+      if (fill) {
+        if (fill.toLive) {
+          ctx.fillStyle = fill.toLive(ctx, this);
+          this._applyPatternGradientTransform(ctx, decl.fill);
         }
-      });
+        else {
+          ctx.fillStyle = fill;
+        }
+      }
+    },
 
-      return object;
+    _setClippingProperties: function(ctx) {
+      ctx.globalAlpha = 1;
+      ctx.strokeStyle = 'transparent';
+      ctx.fillStyle = '#000000';
     },
 
     /**
-     * Returns a string representation of an instance
-     * @return {String}
+     * @private
+     * Sets line dash
+     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
+     * @param {Array} dashArray array representing dashes
      */
-    toString: function() {
-      return '#<fabric.' + capitalize(this.type) + '>';
+    _setLineDash: function(ctx, dashArray) {
+      if (!dashArray || dashArray.length === 0) {
+        return;
+      }
+      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
+      if (1 & dashArray.length) {
+        dashArray.push.apply(dashArray, dashArray);
+      }
+      ctx.setLineDash(dashArray);
     },
 
     /**
-     * Return the object scale factor counting also the group scaling
-     * @return {Object} object with scaleX and scaleY properties
+     * Renders controls and borders for the object
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * @param {Object} [styleOverride] properties to override the object style
      */
-    getObjectScaling: function() {
-      // if the object is a top level one, on the canvas, we go for simple aritmetic
-      // otherwise the complex method with angles will return approximations and decimals
-      // and will likely kill the cache when not needed
-      // https://github.com/fabricjs/fabric.js/issues/7157
+    _renderControls: function(ctx, styleOverride) {
+      var vpt = this.getViewportTransform(),
+          matrix = this.calcTransformMatrix(),
+          options, drawBorders, drawControls;
+      styleOverride = styleOverride || { };
+      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
+      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
+      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
+      options = fabric.util.qrDecompose(matrix);
+      ctx.save();
+      ctx.translate(options.translateX, options.translateY);
+      ctx.lineWidth = 1 * this.borderScaleFactor;
       if (!this.group) {
-        return {
-          scaleX: this.scaleX,
-          scaleY: this.scaleY,
-        };
+        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
       }
-      // if we are inside a group total zoom calculation is complex, we defer to generic matrices
-      var options = fabric.util.qrDecompose(this.calcTransformMatrix());
-      return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
+      if (this.flipX) {
+        options.angle -= 180;
+      }
+      ctx.rotate(degreesToRadians(options.angle));
+      if (styleOverride.forActiveSelection || this.group) {
+        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
+      }
+      else {
+        drawBorders && this.drawBorders(ctx, styleOverride);
+      }
+      drawControls && this.drawControls(ctx, styleOverride);
+      ctx.restore();
     },
 
     /**
-     * Return the object scale factor counting also the group scaling, zoom and retina
-     * @return {Object} object with scaleX and scaleY properties
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    getTotalObjectScaling: function() {
-      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
-      if (this.canvas) {
-        var zoom = this.canvas.getZoom();
-        var retina = this.canvas.getRetinaScaling();
-        scaleX *= zoom * retina;
-        scaleY *= zoom * retina;
+    _setShadow: function(ctx) {
+      if (!this.shadow) {
+        return;
       }
-      return { scaleX: scaleX, scaleY: scaleY };
+
+      var shadow = this.shadow, canvas = this.canvas, scaling,
+          multX = (canvas && canvas.viewportTransform[0]) || 1,
+          multY = (canvas && canvas.viewportTransform[3]) || 1;
+      if (shadow.nonScaling) {
+        scaling = { scaleX: 1, scaleY: 1 };
+      }
+      else {
+        scaling = this.getObjectScaling();
+      }
+      if (canvas && canvas._isRetinaScaling()) {
+        multX *= fabric.devicePixelRatio;
+        multY *= fabric.devicePixelRatio;
+      }
+      ctx.shadowColor = shadow.color;
+      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
+        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
+      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
+      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
     },
 
     /**
-     * Return the object opacity counting also the group property
-     * @return {Number}
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    getObjectOpacity: function() {
-      var opacity = this.opacity;
-      if (this.group) {
-        opacity *= this.group.getObjectOpacity();
+    _removeShadow: function(ctx) {
+      if (!this.shadow) {
+        return;
       }
-      return opacity;
+
+      ctx.shadowColor = '';
+      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
     },
 
     /**
      * @private
-     * @param {String} key
-     * @param {*} value
-     * @return {fabric.Object} thisArg
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * @param {Object} filler fabric.Pattern or fabric.Gradient
+     * @return {Object} offset.offsetX offset for text rendering
+     * @return {Object} offset.offsetY offset for text rendering
      */
-    _set: function(key, value) {
-      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
-          isChanged = this[key] !== value, groupNeedsUpdate = false;
-
-      if (shouldConstrainValue) {
-        value = this._constrainScale(value);
-      }
-      if (key === 'scaleX' && value < 0) {
-        this.flipX = !this.flipX;
-        value *= -1;
-      }
-      else if (key === 'scaleY' && value < 0) {
-        this.flipY = !this.flipY;
-        value *= -1;
+    _applyPatternGradientTransform: function(ctx, filler) {
+      if (!filler || !filler.toLive) {
+        return { offsetX: 0, offsetY: 0 };
       }
-      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
-        value = new fabric.Shadow(value);
+      var t = filler.gradientTransform || filler.patternTransform;
+      var offsetX = -this.width / 2 + filler.offsetX || 0,
+          offsetY = -this.height / 2 + filler.offsetY || 0;
+
+      if (filler.gradientUnits === 'percentage') {
+        ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
       }
-      else if (key === 'dirty' && this.group) {
-        this.group.set('dirty', value);
+      else {
+        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
       }
-
-      this[key] = value;
-
-      if (isChanged) {
-        groupNeedsUpdate = this.group && this.group.isOnACache();
-        if (this.cacheProperties.indexOf(key) > -1) {
-          this.dirty = true;
-          groupNeedsUpdate && this.group.set('dirty', true);
-        }
-        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
-          this.group.set('dirty', true);
-        }
+      if (t) {
+        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
       }
-      return this;
-    },
-
-    /**
-     * This callback function is called by the parent group of an object every
-     * time a non-delegated property changes on the group. It is passed the key
-     * and value as parameters. Not adding in this function's signature to avoid
-     * Travis build error about unused variables.
-     */
-    setOnGroup: function() {
-      // implemented by sub-classes, as needed.
+      return { offsetX: offsetX, offsetY: offsetY };
     },
 
     /**
-     * Retrieves viewportTransform from Object's canvas if possible
-     * @method getViewportTransform
-     * @memberOf fabric.Object.prototype
-     * @return {Array}
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    getViewportTransform: function() {
-      if (this.canvas && this.canvas.viewportTransform) {
-        return this.canvas.viewportTransform;
+    _renderPaintInOrder: function(ctx) {
+      if (this.paintFirst === 'stroke') {
+        this._renderStroke(ctx);
+        this._renderFill(ctx);
+      }
+      else {
+        this._renderFill(ctx);
+        this._renderStroke(ctx);
       }
-      return fabric.iMatrix.concat();
     },
 
-    /*
+    /**
      * @private
-     * return if the object would be visible in rendering
-     * @memberOf fabric.Object.prototype
-     * @return {Boolean}
+     * function that actually render something on the context.
+     * empty here to allow Obects to work on tests to benchmark fabric functionalites
+     * not related to rendering
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    isNotVisible: function() {
-      return this.opacity === 0 ||
-        (!this.width && !this.height && this.strokeWidth === 0) ||
-        !this.visible;
+    _render: function(/* ctx */) {
+
     },
 
     /**
-     * Renders an object on a specified context
+     * @private
      * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    render: function(ctx) {
-      // do not render if width/height are zeros or object is not visible
-      if (this.isNotVisible()) {
-        return;
-      }
-      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
+    _renderFill: function(ctx) {
+      if (!this.fill) {
         return;
       }
+
       ctx.save();
-      this._setupCompositeOperation(ctx);
-      this.drawSelectionBackground(ctx);
-      this.transform(ctx);
-      this._setOpacity(ctx);
-      this._setShadow(ctx, this);
-      if (this.shouldCache()) {
-        this.renderCache();
-        this.drawCacheOnCanvas(ctx);
+      this._setFillStyles(ctx, this);
+      if (this.fillRule === 'evenodd') {
+        ctx.fill('evenodd');
       }
       else {
-        this._removeCacheCanvas();
-        this.dirty = false;
-        this.drawObject(ctx);
-        if (this.objectCaching && this.statefullCache) {
-          this.saveState({ propertySet: 'cacheProperties' });
-        }
+        ctx.fill();
       }
       ctx.restore();
     },
 
-    renderCache: function(options) {
-      options = options || {};
-      if (!this._cacheCanvas) {
-        this._createCacheCanvas();
+    /**
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     */
+    _renderStroke: function(ctx) {
+      if (!this.stroke || this.strokeWidth === 0) {
+        return;
       }
-      if (this.isCacheDirty()) {
-        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
-        this.drawObject(this._cacheContext, options.forClipping);
-        this.dirty = false;
+
+      if (this.shadow && !this.shadow.affectStroke) {
+        this._removeShadow(ctx);
+      }
+
+      ctx.save();
+      if (this.strokeUniform && this.group) {
+        var scaling = this.getObjectScaling();
+        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
+      }
+      else if (this.strokeUniform) {
+        ctx.scale(1 / this.scaleX, 1 / this.scaleY);
       }
+      this._setLineDash(ctx, this.strokeDashArray);
+      this._setStrokeStyles(ctx, this);
+      ctx.stroke();
+      ctx.restore();
     },
 
     /**
-     * Remove cacheCanvas and its dimensions from the objects
+     * This function try to patch the missing gradientTransform on canvas gradients.
+     * transforming a context to transform the gradient, is going to transform the stroke too.
+     * we want to transform the gradient but not the stroke operation, so we create
+     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
+     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
+     * is limited.
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * @param {fabric.Gradient} filler a fabric gradient instance
      */
-    _removeCacheCanvas: function() {
-      this._cacheCanvas = null;
-      this.cacheWidth = 0;
-      this.cacheHeight = 0;
+    _applyPatternForTransformedGradient: function(ctx, filler) {
+      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
+          pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
+          width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
+      pCanvas.width = width;
+      pCanvas.height = height;
+      pCtx = pCanvas.getContext('2d');
+      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
+      pCtx.lineTo(0, height); pCtx.closePath();
+      pCtx.translate(width / 2, height / 2);
+      pCtx.scale(
+        dims.zoomX / this.scaleX / retinaScaling,
+        dims.zoomY / this.scaleY / retinaScaling
+      );
+      this._applyPatternGradientTransform(pCtx, filler);
+      pCtx.fillStyle = filler.toLive(ctx);
+      pCtx.fill();
+      ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
+      ctx.scale(
+        retinaScaling * this.scaleX / dims.zoomX,
+        retinaScaling * this.scaleY / dims.zoomY
+      );
+      ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
     },
 
     /**
-     * return true if the object will draw a stroke
-     * Does not consider text styles. This is just a shortcut used at rendering time
-     * We want it to be an approximation and be fast.
-     * wrote to avoid extra caching, it has to return true when stroke happens,
-     * can guess when it will not happen at 100% chance, does not matter if it misses
-     * some use case where the stroke is invisible.
-     * @since 3.0.0
-     * @returns Boolean
+     * This function is an helper for svg import. it returns the center of the object in the svg
+     * untransformed coordinates
+     * @private
+     * @return {Object} center point from element coordinates
      */
-    hasStroke: function() {
-      return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
+    _findCenterFromElement: function() {
+      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
     },
 
     /**
-     * return true if the object will draw a fill
-     * Does not consider text styles. This is just a shortcut used at rendering time
-     * We want it to be an approximation and be fast.
-     * wrote to avoid extra caching, it has to return true when fill happens,
-     * can guess when it will not happen at 100% chance, does not matter if it misses
-     * some use case where the fill is invisible.
-     * @since 3.0.0
-     * @returns Boolean
+     * This function is an helper for svg import. it decompose the transformMatrix
+     * and assign properties to object.
+     * untransformed coordinates
+     * @private
+     * @chainable
      */
-    hasFill: function() {
-      return this.fill && this.fill !== 'transparent';
+    _assignTransformMatrixProps: function() {
+      if (this.transformMatrix) {
+        var options = fabric.util.qrDecompose(this.transformMatrix);
+        this.flipX = false;
+        this.flipY = false;
+        this.set('scaleX', options.scaleX);
+        this.set('scaleY', options.scaleY);
+        this.angle = options.angle;
+        this.skewX = options.skewX;
+        this.skewY = 0;
+      }
     },
 
     /**
-     * When set to `true`, force the object to have its own cache, even if it is inside a group
-     * it may be needed when your object behave in a particular way on the cache and always needs
-     * its own isolated canvas to render correctly.
-     * Created to be overridden
-     * since 1.7.12
-     * @returns Boolean
+     * This function is an helper for svg import. it removes the transform matrix
+     * and set to object properties that fabricjs can handle
+     * @private
+     * @param {Object} preserveAspectRatioOptions
+     * @return {thisArg}
      */
-    needsItsOwnCache: function() {
-      if (this.paintFirst === 'stroke' &&
-        this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
-        return true;
+    _removeTransformMatrix: function(preserveAspectRatioOptions) {
+      var center = this._findCenterFromElement();
+      if (this.transformMatrix) {
+        this._assignTransformMatrixProps();
+        center = fabric.util.transformPoint(center, this.transformMatrix);
       }
-      if (this.clipPath) {
-        return true;
+      this.transformMatrix = null;
+      if (preserveAspectRatioOptions) {
+        this.scaleX *= preserveAspectRatioOptions.scaleX;
+        this.scaleY *= preserveAspectRatioOptions.scaleY;
+        this.cropX = preserveAspectRatioOptions.cropX;
+        this.cropY = preserveAspectRatioOptions.cropY;
+        center.x += preserveAspectRatioOptions.offsetLeft;
+        center.y += preserveAspectRatioOptions.offsetTop;
+        this.width = preserveAspectRatioOptions.width;
+        this.height = preserveAspectRatioOptions.height;
       }
-      return false;
+      this.setPositionByOrigin(center, 'center', 'center');
     },
 
     /**
-     * Decide if the object should cache or not. Create its own cache level
-     * objectCaching is a global flag, wins over everything
-     * needsItsOwnCache should be used when the object drawing method requires
-     * a cache step. None of the fabric classes requires it.
-     * Generally you do not cache objects in groups because the group outside is cached.
-     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
-     * @return {Boolean}
+     * Clones an instance, using a callback method will work for every object.
+     * @param {Function} callback Callback is invoked with a clone as a first argument
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
      */
-    shouldCache: function() {
-      this.ownCaching = this.needsItsOwnCache() || (
-        this.objectCaching &&
-        (!this.group || !this.group.isOnACache())
-      );
-      return this.ownCaching;
+    clone: function(callback, propertiesToInclude) {
+      var objectForm = this.toObject(propertiesToInclude);
+      if (this.constructor.fromObject) {
+        this.constructor.fromObject(objectForm, callback);
+      }
+      else {
+        fabric.Object._fromObject('Object', objectForm, callback);
+      }
     },
 
     /**
-     * Check if this object or a child object will cast a shadow
-     * used by Group.shouldCache to know if child has a shadow recursively
-     * @return {Boolean}
+     * Creates an instance of fabric.Image out of an object
+     * makes use of toCanvasElement.
+     * Once this method was based on toDataUrl and loadImage, so it also had a quality
+     * and format option. toCanvasElement is faster and produce no loss of quality.
+     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
+     * toCanvasElement and then toBlob from the obtained canvas is also a good option.
+     * This method is sync now, but still support the callback because we did not want to break.
+     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
+     * @param {Function} callback callback, invoked with an instance as a first argument
+     * @param {Object} [options] for clone as image, passed to toDataURL
+     * @param {Number} [options.multiplier=1] Multiplier to scale by
+     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
+     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
+     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
+     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
+     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
+     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
+     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
+     * @return {fabric.Object} thisArg
      */
-    willDrawShadow: function() {
-      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
+    cloneAsImage: function(callback, options) {
+      var canvasEl = this.toCanvasElement(options);
+      if (callback) {
+        callback(new fabric.Image(canvasEl));
+      }
+      return this;
     },
 
     /**
-     * Execute the drawing operation for an object clipPath
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Converts an object into a HTMLCanvas element
+     * @param {Object} options Options object
+     * @param {Number} [options.multiplier=1] Multiplier to scale by
+     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
+     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
+     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
+     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
+     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
+     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
+     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
+     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
      */
-    drawClipPathOnCache: function(ctx) {
-      var path = this.clipPath;
-      ctx.save();
-      // DEBUG: uncomment this line, comment the following
-      // ctx.globalAlpha = 0.4
-      if (path.inverted) {
-        ctx.globalCompositeOperation = 'destination-out';
+    toCanvasElement: function(options) {
+      options || (options = { });
+
+      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
+          originalGroup = this.group,
+          originalShadow = this.shadow, abs = Math.abs,
+          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
+      delete this.group;
+      if (options.withoutTransform) {
+        utils.resetObjectTransform(this);
       }
-      else {
-        ctx.globalCompositeOperation = 'destination-in';
+      if (options.withoutShadow) {
+        this.shadow = null;
       }
-      //ctx.scale(1 / 2, 1 / 2);
-      if (path.absolutePositioned) {
-        var m = fabric.util.invertTransform(this.calcTransformMatrix());
-        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
+
+      var el = fabric.util.createCanvasElement(),
+          // skip canvas zoom and calculate with setCoords now.
+          boundingRect = this.getBoundingRect(true, true),
+          shadow = this.shadow, scaling,
+          shadowOffset = { x: 0, y: 0 }, shadowBlur,
+          width, height;
+
+      if (shadow) {
+        shadowBlur = shadow.blur;
+        if (shadow.nonScaling) {
+          scaling = { scaleX: 1, scaleY: 1 };
+        }
+        else {
+          scaling = this.getObjectScaling();
+        }
+        // consider non scaling shadow.
+        shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
+        shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
       }
-      path.transform(ctx);
-      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
-      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
-      ctx.restore();
+      width = boundingRect.width + shadowOffset.x;
+      height = boundingRect.height + shadowOffset.y;
+      // if the current width/height is not an integer
+      // we need to make it so.
+      el.width = Math.ceil(width);
+      el.height = Math.ceil(height);
+      var canvas = new fabric.StaticCanvas(el, {
+        enableRetinaScaling: false,
+        renderOnAddRemove: false,
+        skipOffscreen: false,
+      });
+      if (options.format === 'jpeg') {
+        canvas.backgroundColor = '#fff';
+      }
+      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');
+
+      var originalCanvas = this.canvas;
+      canvas.add(this);
+      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
+      this.shadow = originalShadow;
+      this.set('canvas', originalCanvas);
+      if (originalGroup) {
+        this.group = originalGroup;
+      }
+      this.set(origParams).setCoords();
+      // canvas.dispose will call image.dispose that will nullify the elements
+      // since this canvas is a simple element for the process, we remove references
+      // to objects in this way in order to avoid object trashing.
+      canvas._objects = [];
+      canvas.dispose();
+      canvas = null;
+
+      return canvasEl;
     },
 
     /**
-     * Execute the drawing operation for an object on a specified context
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Converts an object into a data-url-like string
+     * @param {Object} options Options object
+     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
+     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
+     * @param {Number} [options.multiplier=1] Multiplier to scale by
+     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
+     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
+     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
+     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
+     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
+     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
+     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
+     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
      */
-    drawObject: function(ctx, forClipping) {
-      var originalFill = this.fill, originalStroke = this.stroke;
-      if (forClipping) {
-        this.fill = 'black';
-        this.stroke = '';
-        this._setClippingProperties(ctx);
-      }
-      else {
-        this._renderBackground(ctx);
-      }
-      this._render(ctx);
-      this._drawClipPath(ctx);
-      this.fill = originalFill;
-      this.stroke = originalStroke;
-    },
-
-    _drawClipPath: function(ctx) {
-      var path = this.clipPath;
-      if (!path) { return; }
-      // needed to setup a couple of variables
-      // path canvas gets overridden with this one.
-      // TODO find a better solution?
-      path.canvas = this.canvas;
-      path.shouldCache();
-      path._transformDone = true;
-      path.renderCache({ forClipping: true });
-      this.drawClipPathOnCache(ctx);
+    toDataURL: function(options) {
+      options || (options = { });
+      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
     },
 
     /**
-     * Paint the cached copy of the object on the target context.
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Returns true if specified type is identical to the type of an instance
+     * @param {String} type Type to check against
+     * @return {Boolean}
      */
-    drawCacheOnCanvas: function(ctx) {
-      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
-      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
+    isType: function(type) {
+      return this.type === type;
     },
 
     /**
-     * Check if cache is dirty
-     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
-     * on parent canvas.
+     * Returns complexity of an instance
+     * @return {Number} complexity of this instance (is 1 unless subclassed)
      */
-    isCacheDirty: function(skipCanvas) {
-      if (this.isNotVisible()) {
-        return false;
-      }
-      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
-        // in this case the context is already cleared.
-        return true;
-      }
-      else {
-        if (this.dirty ||
-          (this.clipPath && this.clipPath.absolutePositioned) ||
-          (this.statefullCache && this.hasStateChanged('cacheProperties'))
-        ) {
-          if (this._cacheCanvas && !skipCanvas) {
-            var width = this.cacheWidth / this.zoomX;
-            var height = this.cacheHeight / this.zoomY;
-            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
-          }
-          return true;
-        }
-      }
-      return false;
+    complexity: function() {
+      return 1;
     },
 
     /**
-     * Draws a background for the object big as its untransformed dimensions
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Returns a JSON representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} JSON
      */
-    _renderBackground: function(ctx) {
-      if (!this.backgroundColor) {
-        return;
-      }
-      var dim = this._getNonTransformedDimensions();
-      ctx.fillStyle = this.backgroundColor;
-
-      ctx.fillRect(
-        -dim.x / 2,
-        -dim.y / 2,
-        dim.x,
-        dim.y
-      );
-      // if there is background color no other shadows
-      // should be casted
-      this._removeShadow(ctx);
+    toJSON: function(propertiesToInclude) {
+      // delegate, not alias
+      return this.toObject(propertiesToInclude);
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Sets "angle" of an instance with centered rotation
+     * @param {Number} angle Angle value (in degrees)
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _setOpacity: function(ctx) {
-      if (this.group && !this.group._transformDone) {
-        ctx.globalAlpha = this.getObjectOpacity();
-      }
-      else {
-        ctx.globalAlpha *= this.opacity;
-      }
-    },
+    rotate: function(angle) {
+      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
 
-    _setStrokeStyles: function(ctx, decl) {
-      var stroke = decl.stroke;
-      if (stroke) {
-        ctx.lineWidth = decl.strokeWidth;
-        ctx.lineCap = decl.strokeLineCap;
-        ctx.lineDashOffset = decl.strokeDashOffset;
-        ctx.lineJoin = decl.strokeLineJoin;
-        ctx.miterLimit = decl.strokeMiterLimit;
-        if (stroke.toLive) {
-          if (stroke.gradientUnits === 'percentage' || stroke.gradientTransform || stroke.patternTransform) {
-            // need to transform gradient in a pattern.
-            // this is a slow process. If you are hitting this codepath, and the object
-            // is not using caching, you should consider switching it on.
-            // we need a canvas as big as the current object caching canvas.
-            this._applyPatternForTransformedGradient(ctx, stroke);
-          }
-          else {
-            // is a simple gradient or pattern
-            ctx.strokeStyle = stroke.toLive(ctx, this);
-            this._applyPatternGradientTransform(ctx, stroke);
-          }
-        }
-        else {
-          // is a color
-          ctx.strokeStyle = decl.stroke;
-        }
+      if (shouldCenterOrigin) {
+        this._setOriginToCenter();
       }
-    },
 
-    _setFillStyles: function(ctx, decl) {
-      var fill = decl.fill;
-      if (fill) {
-        if (fill.toLive) {
-          ctx.fillStyle = fill.toLive(ctx, this);
-          this._applyPatternGradientTransform(ctx, decl.fill);
-        }
-        else {
-          ctx.fillStyle = fill;
-        }
+      this.set('angle', angle);
+
+      if (shouldCenterOrigin) {
+        this._resetOrigin();
       }
-    },
 
-    _setClippingProperties: function(ctx) {
-      ctx.globalAlpha = 1;
-      ctx.strokeStyle = 'transparent';
-      ctx.fillStyle = '#000000';
+      return this;
     },
 
     /**
-     * @private
-     * Sets line dash
-     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
-     * @param {Array} dashArray array representing dashes
+     * Centers object horizontally on canvas to which it was added last.
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _setLineDash: function(ctx, dashArray) {
-      if (!dashArray || dashArray.length === 0) {
-        return;
-      }
-      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
-      if (1 & dashArray.length) {
-        dashArray.push.apply(dashArray, dashArray);
-      }
-      ctx.setLineDash(dashArray);
+    centerH: function () {
+      this.canvas && this.canvas.centerObjectH(this);
+      return this;
     },
 
     /**
-     * Renders controls and borders for the object
-     * @param {CanvasRenderingContext2D} ctx Context to render on
-     * @param {Object} [styleOverride] properties to override the object style
+     * Centers object horizontally on current viewport of canvas to which it was added last.
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _renderControls: function(ctx, styleOverride) {
-      var vpt = this.getViewportTransform(),
-          matrix = this.calcTransformMatrix(),
-          options, drawBorders, drawControls;
-      styleOverride = styleOverride || { };
-      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
-      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
-      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
-      options = fabric.util.qrDecompose(matrix);
-      ctx.save();
-      ctx.translate(options.translateX, options.translateY);
-      ctx.lineWidth = 1 * this.borderScaleFactor;
-      if (!this.group) {
-        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
-      }
-      ctx.rotate(degreesToRadians(options.angle));
-      if (styleOverride.forActiveSelection || this.group) {
-        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
-      }
-      else {
-        drawBorders && this.drawBorders(ctx, styleOverride);
-      }
-      drawControls && this.drawControls(ctx, styleOverride);
-      ctx.restore();
+    viewportCenterH: function () {
+      this.canvas && this.canvas.viewportCenterObjectH(this);
+      return this;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
-     */
-    _setShadow: function(ctx) {
-      if (!this.shadow) {
-        return;
-      }
-
-      var shadow = this.shadow, canvas = this.canvas, scaling,
-          multX = (canvas && canvas.viewportTransform[0]) || 1,
-          multY = (canvas && canvas.viewportTransform[3]) || 1;
-      if (shadow.nonScaling) {
-        scaling = { scaleX: 1, scaleY: 1 };
-      }
-      else {
-        scaling = this.getObjectScaling();
-      }
-      if (canvas && canvas._isRetinaScaling()) {
-        multX *= fabric.devicePixelRatio;
-        multY *= fabric.devicePixelRatio;
-      }
-      ctx.shadowColor = shadow.color;
-      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
-        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
-      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
-      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
+     * Centers object vertically on canvas to which it was added last.
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
+     */
+    centerV: function () {
+      this.canvas && this.canvas.centerObjectV(this);
+      return this;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Centers object vertically on current viewport of canvas to which it was added last.
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _removeShadow: function(ctx) {
-      if (!this.shadow) {
-        return;
-      }
-
-      ctx.shadowColor = '';
-      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
+    viewportCenterV: function () {
+      this.canvas && this.canvas.viewportCenterObjectV(this);
+      return this;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
-     * @param {Object} filler fabric.Pattern or fabric.Gradient
-     * @return {Object} offset.offsetX offset for text rendering
-     * @return {Object} offset.offsetY offset for text rendering
+     * Centers object vertically and horizontally on canvas to which is was added last
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _applyPatternGradientTransform: function(ctx, filler) {
-      if (!filler || !filler.toLive) {
-        return { offsetX: 0, offsetY: 0 };
-      }
-      var t = filler.gradientTransform || filler.patternTransform;
-      var offsetX = -this.width / 2 + filler.offsetX || 0,
-          offsetY = -this.height / 2 + filler.offsetY || 0;
+    center: function () {
+      this.canvas && this.canvas.centerObject(this);
+      return this;
+    },
 
-      if (filler.gradientUnits === 'percentage') {
-        ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
-      }
-      else {
-        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
-      }
-      if (t) {
-        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
-      }
-      return { offsetX: offsetX, offsetY: offsetY };
+    /**
+     * Centers object on current viewport of canvas to which it was added last.
+     * You might need to call `setCoords` on an object after centering, to update controls area.
+     * @return {fabric.Object} thisArg
+     * @chainable
+     */
+    viewportCenter: function () {
+      this.canvas && this.canvas.viewportCenterObject(this);
+      return this;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Returns coordinates of a pointer relative to an object
+     * @param {Event} e Event to operate upon
+     * @param {Object} [pointer] Pointer to operate upon (instead of event)
+     * @return {Object} Coordinates of a pointer (x, y)
      */
-    _renderPaintInOrder: function(ctx) {
-      if (this.paintFirst === 'stroke') {
-        this._renderStroke(ctx);
-        this._renderFill(ctx);
-      }
-      else {
-        this._renderFill(ctx);
-        this._renderStroke(ctx);
+    getLocalPointer: function(e, pointer) {
+      pointer = pointer || this.canvas.getPointer(e);
+      var pClicked = new fabric.Point(pointer.x, pointer.y),
+          objectLeftTop = this._getLeftTopCoords();
+      if (this.angle) {
+        pClicked = fabric.util.rotatePoint(
+          pClicked, objectLeftTop, degreesToRadians(-this.angle));
       }
+      return {
+        x: pClicked.x - objectLeftTop.x,
+        y: pClicked.y - objectLeftTop.y
+      };
     },
 
     /**
-     * @private
-     * function that actually render something on the context.
-     * empty here to allow Obects to work on tests to benchmark fabric functionalites
-     * not related to rendering
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Checks if object is decendant of target
+     * Should be used instead of @link {fabric.Collection.contains} for performance reasons
+     * @param {fabric.Object|fabric.StaticCanvas} target 
+     * @returns {boolean}
      */
-    _render: function(/* ctx */) {
-
+    isDescendantOf: function (target) {
+      var parent = this.group || this.parent || this.canvas;
+      while (parent) {
+        if (target === parent) {
+          return true;
+        }
+        else if (parent instanceof fabric.StaticCanvas) {
+          //  happens after all parents were traversed through without a match
+          return false;
+        }
+        parent = parent.group || parent.parent || parent.canvas;
+      }
+      return false;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Sets canvas globalCompositeOperation for specific object
+     * custom composition operation for the particular object can be specified using globalCompositeOperation property
+     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
      */
-    _renderFill: function(ctx) {
-      if (!this.fill) {
-        return;
+    _setupCompositeOperation: function (ctx) {
+      if (this.globalCompositeOperation) {
+        ctx.globalCompositeOperation = this.globalCompositeOperation;
       }
+    }
+  });
 
-      ctx.save();
-      this._setFillStyles(ctx, this);
-      if (this.fillRule === 'evenodd') {
-        ctx.fill('evenodd');
+  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);
+
+  extend(fabric.Object.prototype, fabric.Observable);
+
+  /**
+   * Defines the number of fraction digits to use when serializing object values.
+   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
+   * @static
+   * @memberOf fabric.Object
+   * @constant
+   * @type Number
+   */
+  fabric.Object.NUM_FRACTION_DIGITS = 2;
+
+  fabric.Object._fromObject = function(className, object, callback, extraParam) {
+    var klass = fabric[className];
+    object = clone(object, true);
+    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
+      if (typeof patterns[0] !== 'undefined') {
+        object.fill = patterns[0];
       }
-      else {
-        ctx.fill();
+      if (typeof patterns[1] !== 'undefined') {
+        object.stroke = patterns[1];
       }
-      ctx.restore();
-    },
+      fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
+        object.clipPath = enlivedProps[0];
+        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
+        callback && callback(instance);
+      });
+    });
+  };
+
+  /**
+   * Unique id used internally when creating SVG elements
+   * @static
+   * @memberOf fabric.Object
+   * @type Number
+   */
+  fabric.Object.__uid = 0;
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+(function() {
+
+  var degreesToRadians = fabric.util.degreesToRadians,
+      originXOffset = {
+        left: -0.5,
+        center: 0,
+        right: 0.5
+      },
+      originYOffset = {
+        top: -0.5,
+        center: 0,
+        bottom: 0.5
+      };
+
+  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
+     * @param {fabric.Point} point The point which corresponds to the originX and originY params
+     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
+     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {fabric.Point}
      */
-    _renderStroke: function(ctx) {
-      if (!this.stroke || this.strokeWidth === 0) {
-        return;
-      }
+    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
+      var x = point.x,
+          y = point.y,
+          offsetX, offsetY, dim;
 
-      if (this.shadow && !this.shadow.affectStroke) {
-        this._removeShadow(ctx);
+      if (typeof fromOriginX === 'string') {
+        fromOriginX = originXOffset[fromOriginX];
+      }
+      else {
+        fromOriginX -= 0.5;
       }
 
-      ctx.save();
-      if (this.strokeUniform && this.group) {
-        var scaling = this.getObjectScaling();
-        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
+      if (typeof toOriginX === 'string') {
+        toOriginX = originXOffset[toOriginX];
       }
-      else if (this.strokeUniform) {
-        ctx.scale(1 / this.scaleX, 1 / this.scaleY);
+      else {
+        toOriginX -= 0.5;
       }
-      this._setLineDash(ctx, this.strokeDashArray);
-      this._setStrokeStyles(ctx, this);
-      ctx.stroke();
-      ctx.restore();
-    },
 
-    /**
-     * This function try to patch the missing gradientTransform on canvas gradients.
-     * transforming a context to transform the gradient, is going to transform the stroke too.
-     * we want to transform the gradient but not the stroke operation, so we create
-     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
-     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
-     * is limited.
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
-     * @param {fabric.Gradient} filler a fabric gradient instance
-     */
-    _applyPatternForTransformedGradient: function(ctx, filler) {
-      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
-          pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
-          width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
-      pCanvas.width = width;
-      pCanvas.height = height;
-      pCtx = pCanvas.getContext('2d');
-      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
-      pCtx.lineTo(0, height); pCtx.closePath();
-      pCtx.translate(width / 2, height / 2);
-      pCtx.scale(
-        dims.zoomX / this.scaleX / retinaScaling,
-        dims.zoomY / this.scaleY / retinaScaling
-      );
-      this._applyPatternGradientTransform(pCtx, filler);
-      pCtx.fillStyle = filler.toLive(ctx);
-      pCtx.fill();
-      ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
-      ctx.scale(
-        retinaScaling * this.scaleX / dims.zoomX,
-        retinaScaling * this.scaleY / dims.zoomY
-      );
-      ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
+      offsetX = toOriginX - fromOriginX;
+
+      if (typeof fromOriginY === 'string') {
+        fromOriginY = originYOffset[fromOriginY];
+      }
+      else {
+        fromOriginY -= 0.5;
+      }
+
+      if (typeof toOriginY === 'string') {
+        toOriginY = originYOffset[toOriginY];
+      }
+      else {
+        toOriginY -= 0.5;
+      }
+
+      offsetY = toOriginY - fromOriginY;
+
+      if (offsetX || offsetY) {
+        dim = this._getTransformedDimensions();
+        x = point.x + offsetX * dim.x;
+        y = point.y + offsetY * dim.y;
+      }
+
+      return new fabric.Point(x, y);
     },
 
     /**
-     * This function is an helper for svg import. it returns the center of the object in the svg
-     * untransformed coordinates
-     * @private
-     * @return {Object} center point from element coordinates
+     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
+     * @param {fabric.Point} point The point which corresponds to the originX and originY params
+     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {fabric.Point}
      */
-    _findCenterFromElement: function() {
-      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
+    translateToCenterPoint: function(point, originX, originY) {
+      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
+      if (this.angle) {
+        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
+      }
+      return p;
     },
 
     /**
-     * This function is an helper for svg import. it decompose the transformMatrix
-     * and assign properties to object.
-     * untransformed coordinates
-     * @private
-     * @chainable
+     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
+     * @param {fabric.Point} center The point which corresponds to center of the object
+     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {fabric.Point}
      */
-    _assignTransformMatrixProps: function() {
-      if (this.transformMatrix) {
-        var options = fabric.util.qrDecompose(this.transformMatrix);
-        this.flipX = false;
-        this.flipY = false;
-        this.set('scaleX', options.scaleX);
-        this.set('scaleY', options.scaleY);
-        this.angle = options.angle;
-        this.skewX = options.skewX;
-        this.skewY = 0;
+    translateToOriginPoint: function(center, originX, originY) {
+      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
+      if (this.angle) {
+        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
       }
+      return p;
     },
 
     /**
-     * This function is an helper for svg import. it removes the transform matrix
-     * and set to object properties that fabricjs can handle
-     * @private
-     * @param {Object} preserveAspectRatioOptions
-     * @return {thisArg}
+     * Returns the real center coordinates of the object
+     * @return {fabric.Point}
      */
-    _removeTransformMatrix: function(preserveAspectRatioOptions) {
-      var center = this._findCenterFromElement();
-      if (this.transformMatrix) {
-        this._assignTransformMatrixProps();
-        center = fabric.util.transformPoint(center, this.transformMatrix);
-      }
-      this.transformMatrix = null;
-      if (preserveAspectRatioOptions) {
-        this.scaleX *= preserveAspectRatioOptions.scaleX;
-        this.scaleY *= preserveAspectRatioOptions.scaleY;
-        this.cropX = preserveAspectRatioOptions.cropX;
-        this.cropY = preserveAspectRatioOptions.cropY;
-        center.x += preserveAspectRatioOptions.offsetLeft;
-        center.y += preserveAspectRatioOptions.offsetTop;
-        this.width = preserveAspectRatioOptions.width;
-        this.height = preserveAspectRatioOptions.height;
-      }
-      this.setPositionByOrigin(center, 'center', 'center');
+    getCenterPoint: function() {
+      var leftTop = new fabric.Point(this.left, this.top);
+      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
     },
 
     /**
-     * Clones an instance, using a callback method will work for every object.
-     * @param {Function} callback Callback is invoked with a clone as a first argument
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * Returns the coordinates of the object based on center coordinates
+     * @param {fabric.Point} point The point which corresponds to the originX and originY params
+     * @return {fabric.Point}
      */
-    clone: function(callback, propertiesToInclude) {
-      var objectForm = this.toObject(propertiesToInclude);
-      if (this.constructor.fromObject) {
-        this.constructor.fromObject(objectForm, callback);
-      }
-      else {
-        fabric.Object._fromObject('Object', objectForm, callback);
-      }
-    },
+    // getOriginPoint: function(center) {
+    //   return this.translateToOriginPoint(center, this.originX, this.originY);
+    // },
 
     /**
-     * Creates an instance of fabric.Image out of an object
-     * makes use of toCanvasElement.
-     * Once this method was based on toDataUrl and loadImage, so it also had a quality
-     * and format option. toCanvasElement is faster and produce no loss of quality.
-     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
-     * toCanvasElement and then toBlob from the obtained canvas is also a good option.
-     * This method is sync now, but still support the callback because we did not want to break.
-     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
-     * @param {Function} callback callback, invoked with an instance as a first argument
-     * @param {Object} [options] for clone as image, passed to toDataURL
-     * @param {Number} [options.multiplier=1] Multiplier to scale by
-     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
-     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
-     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
-     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
-     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
-     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
-     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
-     * @return {fabric.Object} thisArg
+     * Returns the coordinates of the object as if it has a different origin
+     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {fabric.Point}
      */
-    cloneAsImage: function(callback, options) {
-      var canvasEl = this.toCanvasElement(options);
-      if (callback) {
-        callback(new fabric.Image(canvasEl));
-      }
-      return this;
+    getPointByOrigin: function(originX, originY) {
+      var center = this.getCenterPoint();
+      return this.translateToOriginPoint(center, originX, originY);
     },
 
     /**
-     * Converts an object into a HTMLCanvas element
-     * @param {Object} options Options object
-     * @param {Number} [options.multiplier=1] Multiplier to scale by
-     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
-     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
-     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
-     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
-     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
-     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
-     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
-     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
+     * Returns the point in local coordinates
+     * @param {fabric.Point} point The point relative to the global coordinate system
+     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {fabric.Point}
      */
-    toCanvasElement: function(options) {
-      options || (options = { });
+    toLocalPoint: function(point, originX, originY) {
+      var center = this.getCenterPoint(),
+          p, p2;
 
-      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
-          originalGroup = this.group,
-          originalShadow = this.shadow, abs = Math.abs,
-          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
-      delete this.group;
-      if (options.withoutTransform) {
-        utils.resetObjectTransform(this);
+      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
+        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
       }
-      if (options.withoutShadow) {
-        this.shadow = null;
+      else {
+        p = new fabric.Point(this.left, this.top);
       }
 
-      var el = fabric.util.createCanvasElement(),
-          // skip canvas zoom and calculate with setCoords now.
-          boundingRect = this.getBoundingRect(true, true),
-          shadow = this.shadow, scaling,
-          shadowOffset = { x: 0, y: 0 }, shadowBlur,
-          width, height;
-
-      if (shadow) {
-        shadowBlur = shadow.blur;
-        if (shadow.nonScaling) {
-          scaling = { scaleX: 1, scaleY: 1 };
-        }
-        else {
-          scaling = this.getObjectScaling();
-        }
-        // consider non scaling shadow.
-        shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
-        shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
-      }
-      width = boundingRect.width + shadowOffset.x;
-      height = boundingRect.height + shadowOffset.y;
-      // if the current width/height is not an integer
-      // we need to make it so.
-      el.width = Math.ceil(width);
-      el.height = Math.ceil(height);
-      var canvas = new fabric.StaticCanvas(el, {
-        enableRetinaScaling: false,
-        renderOnAddRemove: false,
-        skipOffscreen: false,
-      });
-      if (options.format === 'jpeg') {
-        canvas.backgroundColor = '#fff';
+      p2 = new fabric.Point(point.x, point.y);
+      if (this.angle) {
+        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
       }
-      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');
+      return p2.subtractEquals(p);
+    },
 
-      var originalCanvas = this.canvas;
-      canvas.add(this);
-      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
-      this.shadow = originalShadow;
-      this.set('canvas', originalCanvas);
-      if (originalGroup) {
-        this.group = originalGroup;
-      }
-      this.set(origParams).setCoords();
-      // canvas.dispose will call image.dispose that will nullify the elements
-      // since this canvas is a simple element for the process, we remove references
-      // to objects in this way in order to avoid object trashing.
-      canvas._objects = [];
-      canvas.dispose();
-      canvas = null;
+    /**
+     * Returns the point in global coordinates
+     * @param {fabric.Point} The point relative to the local coordinate system
+     * @return {fabric.Point}
+     */
+    // toGlobalPoint: function(point) {
+    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
+    // },
+
+    /**
+     * Sets the position of the object taking into consideration the object's origin
+     * @param {fabric.Point} pos The new position of the object
+     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
+     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
+     * @return {void}
+     */
+    setPositionByOrigin: function(pos, originX, originY) {
+      var center = this.translateToCenterPoint(pos, originX, originY),
+          position = this.translateToOriginPoint(center, this.originX, this.originY);
+      this.set('left', position.x);
+      this.set('top', position.y);
+    },
+
+    /**
+     * @param {String} to One of 'left', 'center', 'right'
+     */
+    adjustPosition: function(to) {
+      var angle = degreesToRadians(this.angle),
+          hypotFull = this.getScaledWidth(),
+          xFull = fabric.util.cos(angle) * hypotFull,
+          yFull = fabric.util.sin(angle) * hypotFull,
+          offsetFrom, offsetTo;
 
-      return canvasEl;
+      //TODO: this function does not consider mixed situation like top, center.
+      if (typeof this.originX === 'string') {
+        offsetFrom = originXOffset[this.originX];
+      }
+      else {
+        offsetFrom = this.originX - 0.5;
+      }
+      if (typeof to === 'string') {
+        offsetTo = originXOffset[to];
+      }
+      else {
+        offsetTo = to - 0.5;
+      }
+      this.left += xFull * (offsetTo - offsetFrom);
+      this.top += yFull * (offsetTo - offsetFrom);
+      this.setCoords();
+      this.originX = to;
     },
 
     /**
-     * Converts an object into a data-url-like string
-     * @param {Object} options Options object
-     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
-     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
-     * @param {Number} [options.multiplier=1] Multiplier to scale by
-     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
-     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
-     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
-     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
-     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
-     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
-     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
-     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
+     * Sets the origin/position of the object to it's center point
+     * @private
+     * @return {void}
      */
-    toDataURL: function(options) {
-      options || (options = { });
-      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
+    _setOriginToCenter: function() {
+      this._originalOriginX = this.originX;
+      this._originalOriginY = this.originY;
+
+      var center = this.getCenterPoint();
+
+      this.originX = 'center';
+      this.originY = 'center';
+
+      this.left = center.x;
+      this.top = center.y;
     },
 
     /**
-     * Returns true if specified type is identical to the type of an instance
-     * @param {String} type Type to check against
-     * @return {Boolean}
+     * Resets the origin/position of the object to it's original origin
+     * @private
+     * @return {void}
      */
-    isType: function(type) {
-      return this.type === type;
+    _resetOrigin: function() {
+      var originPoint = this.translateToOriginPoint(
+        this.getCenterPoint(),
+        this._originalOriginX,
+        this._originalOriginY);
+
+      this.originX = this._originalOriginX;
+      this.originY = this._originalOriginY;
+
+      this.left = originPoint.x;
+      this.top = originPoint.y;
+
+      this._originalOriginX = null;
+      this._originalOriginY = null;
     },
 
     /**
-     * Returns complexity of an instance
-     * @return {Number} complexity of this instance (is 1 unless subclassed)
+     * @private
      */
-    complexity: function() {
-      return 1;
+    _getLeftTopCoords: function() {
+      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
     },
+  });
+
+})();
+
+
+(function() {
+
+  function arrayFromCoords(coords) {
+    return [
+      new fabric.Point(coords.tl.x, coords.tl.y),
+      new fabric.Point(coords.tr.x, coords.tr.y),
+      new fabric.Point(coords.br.x, coords.br.y),
+      new fabric.Point(coords.bl.x, coords.bl.y)
+    ];
+  }
+
+  var util = fabric.util,
+      degreesToRadians = util.degreesToRadians,
+      multiplyMatrices = util.multiplyTransformMatrices,
+      transformPoint = util.transformPoint;
+
+  util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
 
     /**
-     * Returns a JSON representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} JSON
+     * Describe object's corner position in canvas element coordinates.
+     * properties are depending on control keys and padding the main controls.
+     * each property is an object with x, y and corner.
+     * The `corner` property contains in a similar manner the 4 points of the
+     * interactive area of the corner.
+     * The coordinates depends from the controls positionHandler and are used
+     * to draw and locate controls
+     * @memberOf fabric.Object.prototype
      */
-    toJSON: function(propertiesToInclude) {
-      // delegate, not alias
-      return this.toObject(propertiesToInclude);
-    },
+    oCoords: null,
 
     /**
-     * Sets "angle" of an instance with centered rotation
-     * @param {Number} angle Angle value (in degrees)
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Describe object's corner position in canvas object absolute coordinates
+     * properties are tl,tr,bl,br and describe the four main corner.
+     * each property is an object with x, y, instance of Fabric.Point.
+     * The coordinates depends from this properties: width, height, scaleX, scaleY
+     * skewX, skewY, angle, strokeWidth, top, left.
+     * Those coordinates are useful to understand where an object is. They get updated
+     * with oCoords but they do not need to be updated when zoom or panning change.
+     * The coordinates get updated with @method setCoords.
+     * You can calculate them without updating with @method calcACoords();
+     * @memberOf fabric.Object.prototype
      */
-    rotate: function(angle) {
-      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
+    aCoords: null,
 
-      if (shouldCenterOrigin) {
-        this._setOriginToCenter();
-      }
+    /**
+     * Describe object's corner position in canvas element coordinates.
+     * includes padding. Used of object detection.
+     * set and refreshed with setCoords and calcCoords.
+     * @memberOf fabric.Object.prototype
+     */
+    lineCoords: null,
 
-      this.set('angle', angle);
+    /**
+     * storage for object transform matrix
+     */
+    ownMatrixCache: null,
 
-      if (shouldCenterOrigin) {
-        this._resetOrigin();
+    /**
+     * storage for object full transform matrix
+     */
+    matrixCache: null,
+
+    /**
+     * custom controls interface
+     * controls are added by default_controls.js
+     */
+    controls: { },
+
+    /**
+     * return correct set of coordinates for intersection
+     * this will return either aCoords or lineCoords.
+     * @param {Boolean} absolute will return aCoords if true or lineCoords
+     * @return {Object} {tl, tr, br, bl} points
+     */
+    _getCoords: function(absolute, calculate) {
+      if (calculate) {
+        return (absolute ? this.calcACoords() : this.calcLineCoords());
+      }
+      if (!this.aCoords || !this.lineCoords) {
+        this.setCoords(true);
       }
+      return (absolute ? this.aCoords : this.lineCoords);
+    },
 
-      return this;
+    /**
+     * return correct set of coordinates for intersection
+     * this will return either aCoords or lineCoords.
+     * The coords are returned in an array.
+     * @return {Array} [tl, tr, br, bl] of points
+     */
+    getCoords: function(absolute, calculate) {
+      return arrayFromCoords(this._getCoords(absolute, calculate));
     },
 
     /**
-     * Centers object horizontally on canvas to which it was added last.
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if object intersects with an area formed by 2 points
+     * @param {Object} pointTL top-left point of area
+     * @param {Object} pointBR bottom-right point of area
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if object intersects with an area formed by 2 points
      */
-    centerH: function () {
-      this.canvas && this.canvas.centerObjectH(this);
-      return this;
+    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
+      var coords = this.getCoords(absolute, calculate),
+          intersection = fabric.Intersection.intersectPolygonRectangle(
+            coords,
+            pointTL,
+            pointBR
+          );
+      return intersection.status === 'Intersection';
     },
 
     /**
-     * Centers object horizontally on current viewport of canvas to which it was added last.
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if object intersects with another object
+     * @param {Object} other Object to test
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if object intersects with another object
      */
-    viewportCenterH: function () {
-      this.canvas && this.canvas.viewportCenterObjectH(this);
-      return this;
+    intersectsWithObject: function(other, absolute, calculate) {
+      var intersection = fabric.Intersection.intersectPolygonPolygon(
+        this.getCoords(absolute, calculate),
+        other.getCoords(absolute, calculate)
+      );
+
+      return intersection.status === 'Intersection'
+        || other.isContainedWithinObject(this, absolute, calculate)
+        || this.isContainedWithinObject(other, absolute, calculate);
     },
 
     /**
-     * Centers object vertically on canvas to which it was added last.
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if object is fully contained within area of another object
+     * @param {Object} other Object to test
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if object is fully contained within area of another object
+     */
+    isContainedWithinObject: function(other, absolute, calculate) {
+      var points = this.getCoords(absolute, calculate),
+          otherCoords = absolute ? other.aCoords : other.lineCoords,
+          i = 0, lines = other._getImageLines(otherCoords);
+      for (; i < 4; i++) {
+        if (!other.containsPoint(points[i], lines)) {
+          return false;
+        }
+      }
+      return true;
+    },
+
+    /**
+     * Checks if object is fully contained within area formed by 2 points
+     * @param {Object} pointTL top-left point of area
+     * @param {Object} pointBR bottom-right point of area
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if object is fully contained within area formed by 2 points
      */
-    centerV: function () {
-      this.canvas && this.canvas.centerObjectV(this);
-      return this;
+    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
+      var boundingRect = this.getBoundingRect(absolute, calculate);
+
+      return (
+        boundingRect.left >= pointTL.x &&
+        boundingRect.left + boundingRect.width <= pointBR.x &&
+        boundingRect.top >= pointTL.y &&
+        boundingRect.top + boundingRect.height <= pointBR.y
+      );
     },
 
     /**
-     * Centers object vertically on current viewport of canvas to which it was added last.
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if point is inside the object
+     * @param {fabric.Point} point Point to check against
+     * @param {Object} [lines] object returned from @method _getImageLines
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if point is inside the object
      */
-    viewportCenterV: function () {
-      this.canvas && this.canvas.viewportCenterObjectV(this);
-      return this;
+    containsPoint: function(point, lines, absolute, calculate) {
+      var coords = this._getCoords(absolute, calculate),
+          lines = lines || this._getImageLines(coords),
+          xPoints = this._findCrossPoints(point, lines);
+      // if xPoints is odd then point is inside the object
+      return (xPoints !== 0 && xPoints % 2 === 1);
     },
 
     /**
-     * Centers object vertically and horizontally on canvas to which is was added last
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if object is contained within the canvas with current viewportTransform
+     * the check is done stopping at first point that appears on screen
+     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
+     * @return {Boolean} true if object is fully or partially contained within canvas
      */
-    center: function () {
-      this.canvas && this.canvas.centerObject(this);
-      return this;
+    isOnScreen: function(calculate) {
+      if (!this.canvas) {
+        return false;
+      }
+      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
+      var points = this.getCoords(true, calculate);
+      // if some point is on screen, the object is on screen.
+      if (points.some(function(point) {
+        return point.x <= pointBR.x && point.x >= pointTL.x &&
+        point.y <= pointBR.y && point.y >= pointTL.y;
+      })) {
+        return true;
+      }
+      // no points on screen, check intersection with absolute coordinates
+      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
+        return true;
+      }
+      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
     },
 
     /**
-     * Centers object on current viewport of canvas to which it was added last.
-     * You might need to call `setCoords` on an object after centering, to update controls area.
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Checks if the object contains the midpoint between canvas extremities
+     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
+     * @private
+     * @param {Fabric.Point} pointTL Top Left point
+     * @param {Fabric.Point} pointBR Top Right point
+     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if the object contains the point
      */
-    viewportCenter: function () {
-      this.canvas && this.canvas.viewportCenterObject(this);
-      return this;
+    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
+      // worst case scenario the object is so big that contains the screen
+      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
+      if (this.containsPoint(centerPoint, null, true, calculate)) {
+        return true;
+      }
+      return false;
     },
 
     /**
-     * Returns coordinates of a pointer relative to an object
-     * @param {Event} e Event to operate upon
-     * @param {Object} [pointer] Pointer to operate upon (instead of event)
-     * @return {Object} Coordinates of a pointer (x, y)
+     * Checks if object is partially contained within the canvas with current viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
+     * @return {Boolean} true if object is partially contained within canvas
      */
-    getLocalPointer: function(e, pointer) {
-      pointer = pointer || this.canvas.getPointer(e);
-      var pClicked = new fabric.Point(pointer.x, pointer.y),
-          objectLeftTop = this._getLeftTopCoords();
-      if (this.angle) {
-        pClicked = fabric.util.rotatePoint(
-          pClicked, objectLeftTop, degreesToRadians(-this.angle));
+    isPartiallyOnScreen: function(calculate) {
+      if (!this.canvas) {
+        return false;
       }
-      return {
-        x: pClicked.x - objectLeftTop.x,
-        y: pClicked.y - objectLeftTop.y
-      };
+      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
+      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
+        return true;
+      }
+      var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
+        return (point.x >= pointBR.x || point.x <= pointTL.x) &&
+        (point.y >= pointBR.y || point.y <= pointTL.y);
+      });
+      return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
     },
 
     /**
-     * Sets canvas globalCompositeOperation for specific object
-     * custom composition operation for the particular object can be specified using globalCompositeOperation property
-     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
+     * Method that returns an object with the object edges in it, given the coordinates of the corners
+     * @private
+     * @param {Object} oCoords Coordinates of the object corners
      */
-    _setupCompositeOperation: function (ctx) {
-      if (this.globalCompositeOperation) {
-        ctx.globalCompositeOperation = this.globalCompositeOperation;
-      }
-    }
-  });
-
-  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);
+    _getImageLines: function(oCoords) {
 
-  extend(fabric.Object.prototype, fabric.Observable);
+      var lines = {
+        topline: {
+          o: oCoords.tl,
+          d: oCoords.tr
+        },
+        rightline: {
+          o: oCoords.tr,
+          d: oCoords.br
+        },
+        bottomline: {
+          o: oCoords.br,
+          d: oCoords.bl
+        },
+        leftline: {
+          o: oCoords.bl,
+          d: oCoords.tl
+        }
+      };
 
-  /**
-   * Defines the number of fraction digits to use when serializing object values.
-   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
-   * @static
-   * @memberOf fabric.Object
-   * @constant
-   * @type Number
-   */
-  fabric.Object.NUM_FRACTION_DIGITS = 2;
+      // // debugging
+      // if (this.canvas.contextTop) {
+      //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
+      //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
+      //
+      //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
+      //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
+      //
+      //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
+      //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
+      //
+      //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
+      //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
+      // }
 
-  fabric.Object._fromObject = function(className, object, callback, extraParam) {
-    var klass = fabric[className];
-    object = clone(object, true);
-    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
-      if (typeof patterns[0] !== 'undefined') {
-        object.fill = patterns[0];
-      }
-      if (typeof patterns[1] !== 'undefined') {
-        object.stroke = patterns[1];
-      }
-      fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
-        object.clipPath = enlivedProps[0];
-        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
-        callback && callback(instance);
-      });
-    });
-  };
+      return lines;
+    },
 
-  /**
-   * Unique id used internally when creating SVG elements
-   * @static
-   * @memberOf fabric.Object
-   * @type Number
-   */
-  fabric.Object.__uid = 0;
-})(typeof exports !== 'undefined' ? exports : this);
+    /**
+     * Helper method to determine how many cross points are between the 4 object edges
+     * and the horizontal line determined by a point on canvas
+     * @private
+     * @param {fabric.Point} point Point to check
+     * @param {Object} lines Coordinates of the object being evaluated
+     */
+    // remove yi, not used but left code here just in case.
+    _findCrossPoints: function(point, lines) {
+      var b1, b2, a1, a2, xi, // yi,
+          xcount = 0,
+          iLine;
 
+      for (var lineKey in lines) {
+        iLine = lines[lineKey];
+        // optimisation 1: line below point. no cross
+        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
+          continue;
+        }
+        // optimisation 2: line above point. no cross
+        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
+          continue;
+        }
+        // optimisation 3: vertical line case
+        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
+          xi = iLine.o.x;
+          // yi = point.y;
+        }
+        // calculate the intersection point
+        else {
+          b1 = 0;
+          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
+          a1 = point.y - b1 * point.x;
+          a2 = iLine.o.y - b2 * iLine.o.x;
 
-(function() {
+          xi = -(a1 - a2) / (b1 - b2);
+          // yi = a1 + b1 * xi;
+        }
+        // dont count xi < point.x cases
+        if (xi >= point.x) {
+          xcount += 1;
+        }
+        // optimisation 4: specific for square images
+        if (xcount === 2) {
+          break;
+        }
+      }
+      return xcount;
+    },
 
-  var degreesToRadians = fabric.util.degreesToRadians,
-      originXOffset = {
-        left: -0.5,
-        center: 0,
-        right: 0.5
-      },
-      originYOffset = {
-        top: -0.5,
-        center: 0,
-        bottom: 0.5
-      };
+    /**
+     * Returns coordinates of object's bounding rectangle (left, top, width, height)
+     * the box is intended as aligned to axis of canvas.
+     * @param {Boolean} [absolute] use coordinates without viewportTransform
+     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
+     * @return {Object} Object with left, top, width, height properties
+     */
+    getBoundingRect: function(absolute, calculate) {
+      var coords = this.getCoords(absolute, calculate);
+      return util.makeBoundingBoxFromPoints(coords);
+    },
 
-  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
+    /**
+     * Returns width of an object's bounding box counting transformations
+     * before 2.0 it was named getWidth();
+     * @return {Number} width value
+     */
+    getScaledWidth: function() {
+      return this._getTransformedDimensions().x;
+    },
 
     /**
-     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
-     * @param {fabric.Point} point The point which corresponds to the originX and originY params
-     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
-     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {fabric.Point}
+     * Returns height of an object bounding box counting transformations
+     * before 2.0 it was named getHeight();
+     * @return {Number} height value
      */
-    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
-      var x = point.x,
-          y = point.y,
-          offsetX, offsetY, dim;
+    getScaledHeight: function() {
+      return this._getTransformedDimensions().y;
+    },
 
-      if (typeof fromOriginX === 'string') {
-        fromOriginX = originXOffset[fromOriginX];
+    /**
+     * Makes sure the scale is valid and modifies it if necessary
+     * @private
+     * @param {Number} value
+     * @return {Number}
+     */
+    _constrainScale: function(value) {
+      if (Math.abs(value) < this.minScaleLimit) {
+        if (value < 0) {
+          return -this.minScaleLimit;
+        }
+        else {
+          return this.minScaleLimit;
+        }
       }
-      else {
-        fromOriginX -= 0.5;
+      else if (value === 0) {
+        return 0.0001;
       }
+      return value;
+    },
 
-      if (typeof toOriginX === 'string') {
-        toOriginX = originXOffset[toOriginX];
-      }
-      else {
-        toOriginX -= 0.5;
-      }
+    /**
+     * Scales an object (equally by x and y)
+     * @param {Number} value Scale factor
+     * @return {fabric.Object} thisArg
+     * @chainable
+     */
+    scale: function(value) {
+      this._set('scaleX', value);
+      this._set('scaleY', value);
+      return this.setCoords();
+    },
 
-      offsetX = toOriginX - fromOriginX;
+    /**
+     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
+     * @param {Number} value New width value
+     * @param {Boolean} absolute ignore viewport
+     * @return {fabric.Object} thisArg
+     * @chainable
+     */
+    scaleToWidth: function(value, absolute) {
+      // adjust to bounding rect factor so that rotated shapes would fit as well
+      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
+      return this.scale(value / this.width / boundingRectFactor);
+    },
 
-      if (typeof fromOriginY === 'string') {
-        fromOriginY = originYOffset[fromOriginY];
-      }
-      else {
-        fromOriginY -= 0.5;
-      }
+    /**
+     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
+     * @param {Number} value New height value
+     * @param {Boolean} absolute ignore viewport
+     * @return {fabric.Object} thisArg
+     * @chainable
+     */
+    scaleToHeight: function(value, absolute) {
+      // adjust to bounding rect factor so that rotated shapes would fit as well
+      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
+      return this.scale(value / this.height / boundingRectFactor);
+    },
 
-      if (typeof toOriginY === 'string') {
-        toOriginY = originYOffset[toOriginY];
-      }
-      else {
-        toOriginY -= 0.5;
+    /**
+     * Calculates and returns the .coords of an object.
+     * unused by the library, only for the end dev.
+     * @return {Object} Object with tl, tr, br, bl ....
+     * @chainable
+     * @deprecated
+     */
+    calcCoords: function(absolute) {
+      // this is a compatibility function to avoid removing calcCoords now.
+      if (absolute) {
+        return this.calcACoords();
       }
+      return this.calcOCoords();
+    },
 
-      offsetY = toOriginY - fromOriginY;
+    calcLineCoords: function() {
+      var vpt = this.getViewportTransform(),
+          padding = this.padding, angle = degreesToRadians(this.angle),
+          cos = util.cos(angle), sin = util.sin(angle),
+          cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
+          cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();
 
-      if (offsetX || offsetY) {
-        dim = this._getTransformedDimensions();
-        x = point.x + offsetX * dim.x;
-        y = point.y + offsetY * dim.y;
+      var lineCoords = {
+        tl: transformPoint(aCoords.tl, vpt),
+        tr: transformPoint(aCoords.tr, vpt),
+        bl: transformPoint(aCoords.bl, vpt),
+        br: transformPoint(aCoords.br, vpt),
+      };
+
+      if (padding) {
+        lineCoords.tl.x -= cosPMinusSinP;
+        lineCoords.tl.y -= cosPSinP;
+        lineCoords.tr.x += cosPSinP;
+        lineCoords.tr.y -= cosPMinusSinP;
+        lineCoords.bl.x -= cosPSinP;
+        lineCoords.bl.y += cosPMinusSinP;
+        lineCoords.br.x += cosPMinusSinP;
+        lineCoords.br.y += cosPSinP;
       }
 
-      return new fabric.Point(x, y);
+      return lineCoords;
     },
 
-    /**
-     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
-     * @param {fabric.Point} point The point which corresponds to the originX and originY params
-     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {fabric.Point}
-     */
-    translateToCenterPoint: function(point, originX, originY) {
-      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
-      if (this.angle) {
-        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
-      }
-      return p;
+    calcOCoords: function() {
+      var rotateMatrix = this._calcRotateMatrix(),
+          translateMatrix = this._calcTranslateMatrix(),
+          vpt = this.getViewportTransform(),
+          startMatrix = multiplyMatrices(vpt, translateMatrix),
+          finalMatrix = multiplyMatrices(startMatrix, rotateMatrix),
+          finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]),
+          dim = this._calculateCurrentDimensions(),
+          coords = {};
+      this.forEachControl(function(control, key, fabricObject) {
+        coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
+      });
+
+      // debug code
+      // var canvas = this.canvas;
+      // setTimeout(function() {
+      //   canvas.contextTop.clearRect(0, 0, 700, 700);
+      //   canvas.contextTop.fillStyle = 'green';
+      //   Object.keys(coords).forEach(function(key) {
+      //     var control = coords[key];
+      //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);
+      //   });
+      // }, 50);
+      return coords;
     },
 
-    /**
-     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
-     * @param {fabric.Point} center The point which corresponds to center of the object
-     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {fabric.Point}
-     */
-    translateToOriginPoint: function(center, originX, originY) {
-      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
-      if (this.angle) {
-        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
-      }
-      return p;
+    calcACoords: function() {
+      var rotateMatrix = this._calcRotateMatrix(),
+          translateMatrix = this._calcTranslateMatrix(),
+          finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
+          dim = this._getTransformedDimensions(),
+          w = dim.x / 2, h = dim.y / 2;
+      return {
+        // corners
+        tl: transformPoint({ x: -w, y: -h }, finalMatrix),
+        tr: transformPoint({ x: w, y: -h }, finalMatrix),
+        bl: transformPoint({ x: -w, y: h }, finalMatrix),
+        br: transformPoint({ x: w, y: h }, finalMatrix)
+      };
     },
 
     /**
-     * Returns the real center coordinates of the object
-     * @return {fabric.Point}
+     * Sets corner and controls position coordinates based on current angle, width and height, left and top.
+     * oCoords are used to find the corners
+     * aCoords are used to quickly find an object on the canvas
+     * lineCoords are used to quickly find object during pointer events.
+     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
+     * @param {Boolean} [skipCorners] skip calculation of oCoords.
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    getCenterPoint: function() {
-      var leftTop = new fabric.Point(this.left, this.top);
-      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
+    setCoords: function(skipCorners) {
+      this.aCoords = this.calcACoords();
+      // in case we are in a group, for how the inner group target check works,
+      // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.
+      this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
+      if (skipCorners) {
+        return this;
+      }
+      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
+      this.oCoords = this.calcOCoords();
+      this._setCornerCoords && this._setCornerCoords();
+      return this;
     },
 
     /**
-     * Returns the coordinates of the object based on center coordinates
-     * @param {fabric.Point} point The point which corresponds to the originX and originY params
-     * @return {fabric.Point}
+     * calculate rotation matrix of an object
+     * @return {Array} rotation matrix for the object
      */
-    // getOriginPoint: function(center) {
-    //   return this.translateToOriginPoint(center, this.originX, this.originY);
-    // },
-
-    /**
-     * Returns the coordinates of the object as if it has a different origin
-     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {fabric.Point}
+    _calcRotateMatrix: function() {
+      return util.calcRotateMatrix(this);
+    },
+
+    /**
+     * calculate the translation matrix for an object transform
+     * @return {Array} rotation matrix for the object
      */
-    getPointByOrigin: function(originX, originY) {
+    _calcTranslateMatrix: function() {
       var center = this.getCenterPoint();
-      return this.translateToOriginPoint(center, originX, originY);
+      return [1, 0, 0, 1, center.x, center.y];
+    },
+
+    transformMatrixKey: function(skipGroup) {
+      var sep = '_', prefix = '';
+      if (!skipGroup && this.group) {
+        prefix = this.group.transformMatrixKey(skipGroup) + sep;
+      };
+      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
+        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
+        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
     },
 
     /**
-     * Returns the point in local coordinates
-     * @param {fabric.Point} point The point relative to the global coordinate system
-     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {fabric.Point}
+     * calculate transform matrix that represents the current transformations from the
+     * object's properties.
+     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
+     * There are some situation in which this is useful to avoid the fake rotation.
+     * @return {Array} transform matrix for the object
      */
-    toLocalPoint: function(point, originX, originY) {
-      var center = this.getCenterPoint(),
-          p, p2;
-
-      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
-        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
+    calcTransformMatrix: function(skipGroup) {
+      var matrix = this.calcOwnMatrix();
+      if (skipGroup || !this.group) {
+        return matrix;
       }
-      else {
-        p = new fabric.Point(this.left, this.top);
+      var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
+      if (cache.key === key) {
+        return cache.value;
       }
-
-      p2 = new fabric.Point(point.x, point.y);
-      if (this.angle) {
-        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
+      if (this.group) {
+        matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);
       }
-      return p2.subtractEquals(p);
+      cache.key = key;
+      cache.value = matrix;
+      return matrix;
     },
 
     /**
-     * Returns the point in global coordinates
-     * @param {fabric.Point} The point relative to the local coordinate system
-     * @return {fabric.Point}
+     * calculate transform matrix that represents the current transformations from the
+     * object's properties, this matrix does not include the group transformation
+     * @return {Array} transform matrix for the object
      */
-    // toGlobalPoint: function(point) {
-    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
-    // },
+    calcOwnMatrix: function() {
+      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
+      if (cache.key === key) {
+        return cache.value;
+      }
+      var tMatrix = this._calcTranslateMatrix(),
+          options = {
+            angle: this.angle,
+            translateX: tMatrix[4],
+            translateY: tMatrix[5],
+            scaleX: this.scaleX,
+            scaleY: this.scaleY,
+            skewX: this.skewX,
+            skewY: this.skewY,
+            flipX: this.flipX,
+            flipY: this.flipY,
+          };
+      cache.key = key;
+      cache.value = util.composeMatrix(options);
+      return cache.value;
+    },
 
-    /**
-     * Sets the position of the object taking into consideration the object's origin
-     * @param {fabric.Point} pos The new position of the object
-     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
-     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
-     * @return {void}
+    /*
+     * Calculate object dimensions from its properties
+     * @private
+     * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix
+     * not including or including flipX, flipY to emulate the flipping boolean
+     * @return {Object} .x width dimension
+     * @return {Object} .y height dimension
      */
-    setPositionByOrigin: function(pos, originX, originY) {
-      var center = this.translateToCenterPoint(pos, originX, originY),
-          position = this.translateToOriginPoint(center, this.originX, this.originY);
-      this.set('left', position.x);
-      this.set('top', position.y);
+    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
+      return util.calcDimensionsMatrix({
+        skewX: skewX,
+        skewY: skewY,
+        scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
+        scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
+      });
     },
 
-    /**
-     * @param {String} to One of 'left', 'center', 'right'
+    /*
+     * Calculate object dimensions from its properties
+     * @private
+     * @return {Object} .x width dimension
+     * @return {Object} .y height dimension
      */
-    adjustPosition: function(to) {
-      var angle = degreesToRadians(this.angle),
-          hypotFull = this.getScaledWidth(),
-          xFull = fabric.util.cos(angle) * hypotFull,
-          yFull = fabric.util.sin(angle) * hypotFull,
-          offsetFrom, offsetTo;
+    _getNonTransformedDimensions: function() {
+      var strokeWidth = this.strokeWidth,
+          w = this.width + strokeWidth,
+          h = this.height + strokeWidth;
+      return { x: w, y: h };
+    },
 
-      //TODO: this function does not consider mixed situation like top, center.
-      if (typeof this.originX === 'string') {
-        offsetFrom = originXOffset[this.originX];
+    /*
+     * Calculate object bounding box dimensions from its properties scale, skew.
+     * @param {Number} skewX, a value to override current skewX
+     * @param {Number} skewY, a value to override current skewY
+     * @private
+     * @return {Object} .x width dimension
+     * @return {Object} .y height dimension
+     */
+    _getTransformedDimensions: function(skewX, skewY) {
+      if (typeof skewX === 'undefined') {
+        skewX = this.skewX;
       }
-      else {
-        offsetFrom = this.originX - 0.5;
+      if (typeof skewY === 'undefined') {
+        skewY = this.skewY;
       }
-      if (typeof to === 'string') {
-        offsetTo = originXOffset[to];
+      var dimensions, dimX, dimY,
+          noSkew = skewX === 0 && skewY === 0;
+
+      if (this.strokeUniform) {
+        dimX = this.width;
+        dimY = this.height;
       }
       else {
-        offsetTo = to - 0.5;
+        dimensions = this._getNonTransformedDimensions();
+        dimX = dimensions.x;
+        dimY = dimensions.y;
       }
-      this.left += xFull * (offsetTo - offsetFrom);
-      this.top += yFull * (offsetTo - offsetFrom);
-      this.setCoords();
-      this.originX = to;
+      if (noSkew) {
+        return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
+      }
+      var bbox = util.sizeAfterTransform(dimX, dimY, {
+        scaleX: this.scaleX,
+        scaleY: this.scaleY,
+        skewX: skewX,
+        skewY: skewY,
+      });
+      return this._finalizeDimensions(bbox.x, bbox.y);
     },
 
-    /**
-     * Sets the origin/position of the object to it's center point
+    /*
+     * Calculate object bounding box dimensions from its properties scale, skew.
+     * @param Number width width of the bbox
+     * @param Number height height of the bbox
      * @private
-     * @return {void}
+     * @return {Object} .x finalized width dimension
+     * @return {Object} .y finalized height dimension
      */
-    _setOriginToCenter: function() {
-      this._originalOriginX = this.originX;
-      this._originalOriginY = this.originY;
-
-      var center = this.getCenterPoint();
-
-      this.originX = 'center';
-      this.originY = 'center';
-
-      this.left = center.x;
-      this.top = center.y;
+    _finalizeDimensions: function(width, height) {
+      return this.strokeUniform ?
+        { x: width + this.strokeWidth, y: height + this.strokeWidth }
+        :
+        { x: width, y: height };
     },
 
-    /**
-     * Resets the origin/position of the object to it's original origin
-     * @private
-     * @return {void}
+    /*
+     * Calculate object dimensions for controls box, including padding and canvas zoom.
+     * and active selection
+     * private
      */
-    _resetOrigin: function() {
-      var originPoint = this.translateToOriginPoint(
-        this.getCenterPoint(),
-        this._originalOriginX,
-        this._originalOriginY);
-
-      this.originX = this._originalOriginX;
-      this.originY = this._originalOriginY;
+    _calculateCurrentDimensions: function()  {
+      var vpt = this.getViewportTransform(),
+          dim = this._getTransformedDimensions(),
+          p = transformPoint(dim, vpt, true);
+      return p.scalarAdd(2 * this.padding);
+    },
+  });
+})();
 
-      this.left = originPoint.x;
-      this.top = originPoint.y;
 
-      this._originalOriginX = null;
-      this._originalOriginY = null;
-    },
+fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
 
-    /**
-     * @private
-     */
-    _getLeftTopCoords: function() {
-      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
-    },
-  });
+  /**
+   * Moves an object to the bottom of the stack of drawn objects
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
+  sendToBack: function () {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.sendToBack.call(stack, this);
+    return this;
+  },
 
-})();
+  /**
+   * Moves an object to the top of the stack of drawn objects
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
+  bringToFront: function() {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.bringToFront.call(stack, this);
+    return this;
+  },
 
+  /**
+   * Moves an object down in stack of drawn objects
+   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
+  sendBackwards: function(intersecting) {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.sendBackwards.call(stack, this, intersecting);
+    return this;
+  },
 
-(function() {
+  /**
+   * Moves an object up in stack of drawn objects
+   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
+  bringForward: function (intersecting) {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.bringForward.call(stack, this, intersecting);
+    return this;
+  },
 
-  function arrayFromCoords(coords) {
-    return [
-      new fabric.Point(coords.tl.x, coords.tl.y),
-      new fabric.Point(coords.tr.x, coords.tr.y),
-      new fabric.Point(coords.br.x, coords.br.y),
-      new fabric.Point(coords.bl.x, coords.bl.y)
-    ];
+  /**
+   * Moves an object to specified level in stack of drawn objects
+   * @param {Number} index New position of object
+   * @return {fabric.Object} thisArg
+   * @chainable
+   */
+  moveTo: function(index) {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.moveTo.call(stack, this, index);
+    return this;
   }
+});
 
-  var util = fabric.util,
-      degreesToRadians = util.degreesToRadians,
-      multiplyMatrices = util.multiplyTransformMatrices,
-      transformPoint = util.transformPoint;
 
-  util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
+/* _TO_SVG_START_ */
+(function() {
+  function getSvgColorString(prop, value) {
+    if (!value) {
+      return prop + ': none; ';
+    }
+    else if (value.toLive) {
+      return prop + ': url(#SVGID_' + value.id + '); ';
+    }
+    else {
+      var color = new fabric.Color(value),
+          str = prop + ': ' + color.toRgb() + '; ',
+          opacity = color.getAlpha();
+      if (opacity !== 1) {
+        //change the color in rgb + opacity
+        str += prop + '-opacity: ' + opacity.toString() + '; ';
+      }
+      return str;
+    }
+  }
 
-    /**
-     * Describe object's corner position in canvas element coordinates.
-     * properties are depending on control keys and padding the main controls.
-     * each property is an object with x, y and corner.
-     * The `corner` property contains in a similar manner the 4 points of the
-     * interactive area of the corner.
-     * The coordinates depends from the controls positionHandler and are used
-     * to draw and locate controls
-     * @memberOf fabric.Object.prototype
-     */
-    oCoords: null,
+  var toFixed = fabric.util.toFixed;
 
+  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
     /**
-     * Describe object's corner position in canvas object absolute coordinates
-     * properties are tl,tr,bl,br and describe the four main corner.
-     * each property is an object with x, y, instance of Fabric.Point.
-     * The coordinates depends from this properties: width, height, scaleX, scaleY
-     * skewX, skewY, angle, strokeWidth, top, left.
-     * Those coordinates are useful to understand where an object is. They get updated
-     * with oCoords but they do not need to be updated when zoom or panning change.
-     * The coordinates get updated with @method setCoords.
-     * You can calculate them without updating with @method calcACoords();
-     * @memberOf fabric.Object.prototype
+     * Returns styles-string for svg-export
+     * @param {Boolean} skipShadow a boolean to skip shadow filter output
+     * @return {String}
      */
-    aCoords: null,
+    getSvgStyles: function(skipShadow) {
 
-    /**
-     * Describe object's corner position in canvas element coordinates.
-     * includes padding. Used of object detection.
-     * set and refreshed with setCoords and calcCoords.
-     * @memberOf fabric.Object.prototype
-     */
-    lineCoords: null,
+      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
+          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
+          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
+          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
+          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
+          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
+          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
+          opacity = this.parent ? this.getObjectOpacity() : typeof this.opacity !== 'undefined' ? this.opacity : '1',
+          visibility = this.visible ? '' : ' visibility: hidden;',
+          filter = skipShadow ? '' : this.getSvgFilter(),
+          fill = getSvgColorString('fill', this.fill),
+          stroke = getSvgColorString('stroke', this.stroke);
 
-    /**
-     * storage for object transform matrix
-     */
-    ownMatrixCache: null,
+      return [
+        stroke,
+        'stroke-width: ', strokeWidth, '; ',
+        'stroke-dasharray: ', strokeDashArray, '; ',
+        'stroke-linecap: ', strokeLineCap, '; ',
+        'stroke-dashoffset: ', strokeDashOffset, '; ',
+        'stroke-linejoin: ', strokeLineJoin, '; ',
+        'stroke-miterlimit: ', strokeMiterLimit, '; ',
+        fill,
+        'fill-rule: ', fillRule, '; ',
+        'opacity: ', opacity, ';',
+        filter,
+        visibility
+      ].join('');
+    },
 
     /**
-     * storage for object full transform matrix
+     * Returns styles-string for svg-export
+     * @param {Object} style the object from which to retrieve style properties
+     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
+     * @return {String}
      */
-    matrixCache: null,
+    getSvgSpanStyles: function(style, useWhiteSpace) {
+      var term = '; ';
+      var fontFamily = style.fontFamily ?
+        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
+          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
+      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
+          fontFamily = fontFamily,
+          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
+          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
+          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
+          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
+          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
+          textDecoration = this.getSvgTextDecoration(style),
+          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
+      if (textDecoration) {
+        textDecoration = 'text-decoration: ' + textDecoration + term;
+      }
 
-    /**
-     * custom controls interface
-     * controls are added by default_controls.js
-     */
-    controls: { },
+      return [
+        stroke,
+        strokeWidth,
+        fontFamily,
+        fontSize,
+        fontStyle,
+        fontWeight,
+        textDecoration,
+        fill,
+        deltaY,
+        useWhiteSpace ? 'white-space: pre; ' : ''
+      ].join('');
+    },
 
     /**
-     * return correct set of coordinates for intersection
-     * this will return either aCoords or lineCoords.
-     * @param {Boolean} absolute will return aCoords if true or lineCoords
-     * @return {Object} {tl, tr, br, bl} points
+     * Returns text-decoration property for svg-export
+     * @param {Object} style the object from which to retrieve style properties
+     * @return {String}
      */
-    _getCoords: function(absolute, calculate) {
-      if (calculate) {
-        return (absolute ? this.calcACoords() : this.calcLineCoords());
-      }
-      if (!this.aCoords || !this.lineCoords) {
-        this.setCoords(true);
-      }
-      return (absolute ? this.aCoords : this.lineCoords);
+    getSvgTextDecoration: function(style) {
+      return ['overline', 'underline', 'line-through'].filter(function(decoration) {
+        return style[decoration.replace('-', '')];
+      }).join(' ');
     },
 
     /**
-     * return correct set of coordinates for intersection
-     * this will return either aCoords or lineCoords.
-     * The coords are returned in an array.
-     * @return {Array} [tl, tr, br, bl] of points
+     * Returns filter for svg shadow
+     * @return {String}
      */
-    getCoords: function(absolute, calculate) {
-      return arrayFromCoords(this._getCoords(absolute, calculate));
+    getSvgFilter: function() {
+      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
     },
 
     /**
-     * Checks if object intersects with an area formed by 2 points
-     * @param {Object} pointTL top-left point of area
-     * @param {Object} pointBR bottom-right point of area
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if object intersects with an area formed by 2 points
+     * Returns id attribute for svg output
+     * @return {String}
      */
-    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
-      var coords = this.getCoords(absolute, calculate),
-          intersection = fabric.Intersection.intersectPolygonRectangle(
-            coords,
-            pointTL,
-            pointBR
-          );
-      return intersection.status === 'Intersection';
+    getSvgCommons: function() {
+      return [
+        this.id ? 'id="' + this.id + '" ' : '',
+        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
+      ].join('');
     },
 
     /**
-     * Checks if object intersects with another object
-     * @param {Object} other Object to test
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if object intersects with another object
+     * Returns transform-string for svg-export
+     * @param {Boolean} use the full transform or the single object one.
+     * @return {String}
      */
-    intersectsWithObject: function(other, absolute, calculate) {
-      var intersection = fabric.Intersection.intersectPolygonPolygon(
-        this.getCoords(absolute, calculate),
-        other.getCoords(absolute, calculate)
-      );
-
-      return intersection.status === 'Intersection'
-        || other.isContainedWithinObject(this, absolute, calculate)
-        || this.isContainedWithinObject(other, absolute, calculate);
+    getSvgTransform: function(full, additionalTransform) {
+      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
+          svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
+      return svgTransform +
+        (additionalTransform || '') + '" ';
     },
 
-    /**
-     * Checks if object is fully contained within area of another object
-     * @param {Object} other Object to test
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if object is fully contained within area of another object
-     */
-    isContainedWithinObject: function(other, absolute, calculate) {
-      var points = this.getCoords(absolute, calculate),
-          otherCoords = absolute ? other.aCoords : other.lineCoords,
-          i = 0, lines = other._getImageLines(otherCoords);
-      for (; i < 4; i++) {
-        if (!other.containsPoint(points[i], lines)) {
-          return false;
-        }
+    _setSVGBg: function(textBgRects) {
+      if (this.backgroundColor) {
+        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
+        textBgRects.push(
+          '\t\t<rect ',
+          this._getFillAttributes(this.backgroundColor),
+          ' x="',
+          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
+          '" y="',
+          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
+          '" width="',
+          toFixed(this.width, NUM_FRACTION_DIGITS),
+          '" height="',
+          toFixed(this.height, NUM_FRACTION_DIGITS),
+          '"></rect>\n');
       }
-      return true;
     },
 
     /**
-     * Checks if object is fully contained within area formed by 2 points
-     * @param {Object} pointTL top-left point of area
-     * @param {Object} pointBR bottom-right point of area
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if object is fully contained within area formed by 2 points
+     * Returns svg representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
      */
-    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
-      var boundingRect = this.getBoundingRect(absolute, calculate);
-
-      return (
-        boundingRect.left >= pointTL.x &&
-        boundingRect.left + boundingRect.width <= pointBR.x &&
-        boundingRect.top >= pointTL.y &&
-        boundingRect.top + boundingRect.height <= pointBR.y
-      );
+    toSVG: function(reviver) {
+      return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
     },
 
     /**
-     * Checks if point is inside the object
-     * @param {fabric.Point} point Point to check against
-     * @param {Object} [lines] object returned from @method _getImageLines
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if point is inside the object
+     * Returns svg clipPath representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
      */
-    containsPoint: function(point, lines, absolute, calculate) {
-      var coords = this._getCoords(absolute, calculate),
-          lines = lines || this._getImageLines(coords),
-          xPoints = this._findCrossPoints(point, lines);
-      // if xPoints is odd then point is inside the object
-      return (xPoints !== 0 && xPoints % 2 === 1);
+    toClipPathSVG: function(reviver) {
+      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
     },
 
     /**
-     * Checks if object is contained within the canvas with current viewportTransform
-     * the check is done stopping at first point that appears on screen
-     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
-     * @return {Boolean} true if object is fully or partially contained within canvas
+     * @private
      */
-    isOnScreen: function(calculate) {
-      if (!this.canvas) {
-        return false;
-      }
-      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
-      var points = this.getCoords(true, calculate);
-      // if some point is on screen, the object is on screen.
-      if (points.some(function(point) {
-        return point.x <= pointBR.x && point.x >= pointTL.x &&
-        point.y <= pointBR.y && point.y >= pointTL.y;
-      })) {
-        return true;
-      }
-      // no points on screen, check intersection with absolute coordinates
-      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
-        return true;
-      }
-      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
+    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
+      options = options || {};
+      var reviver = options.reviver,
+          additionalTransform = options.additionalTransform || '',
+          commonPieces = [
+            this.getSvgTransform(true, additionalTransform),
+            this.getSvgCommons(),
+          ].join(''),
+          // insert commons in the markup, style and svgCommons
+          index = objectMarkup.indexOf('COMMON_PARTS');
+      objectMarkup[index] = commonPieces;
+      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
     },
 
     /**
-     * Checks if the object contains the midpoint between canvas extremities
-     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
      * @private
-     * @param {Fabric.Point} pointTL Top Left point
-     * @param {Fabric.Point} pointBR Top Right point
-     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if the object contains the point
      */
-    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
-      // worst case scenario the object is so big that contains the screen
-      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
-      if (this.containsPoint(centerPoint, null, true, calculate)) {
-        return true;
+    _createBaseSVGMarkup: function(objectMarkup, options) {
+      options = options || {};
+      var noStyle = options.noStyle,
+          reviver = options.reviver,
+          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
+          shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
+          clipPath = this.clipPath,
+          vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
+          absoluteClipPath = clipPath && clipPath.absolutePositioned,
+          stroke = this.stroke, fill = this.fill, shadow = this.shadow,
+          commonPieces, markup = [], clipPathMarkup,
+          // insert commons in the markup, style and svgCommons
+          index = objectMarkup.indexOf('COMMON_PARTS'),
+          additionalTransform = options.additionalTransform;
+      if (clipPath) {
+        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
+        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
+          clipPath.toClipPathSVG(reviver) +
+          '</clipPath>\n';
       }
-      return false;
-    },
-
-    /**
-     * Checks if object is partially contained within the canvas with current viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
-     * @return {Boolean} true if object is partially contained within canvas
-     */
-    isPartiallyOnScreen: function(calculate) {
-      if (!this.canvas) {
-        return false;
+      if (absoluteClipPath) {
+        markup.push(
+          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
+        );
       }
-      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
-      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
-        return true;
+      markup.push(
+        '<g ',
+        this.getSvgTransform(false),
+        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
+        ' >\n'
+      );
+      commonPieces = [
+        styleInfo,
+        vectorEffect,
+        noStyle ? '' : this.addPaintOrder(), ' ',
+        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
+      ].join('');
+      objectMarkup[index] = commonPieces;
+      if (fill && fill.toLive) {
+        markup.push(fill.toSVG(this));
       }
-      var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
-        return (point.x >= pointBR.x || point.x <= pointTL.x) &&
-        (point.y >= pointBR.y || point.y <= pointTL.y);
-      });
-      return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
+      if (stroke && stroke.toLive) {
+        markup.push(stroke.toSVG(this));
+      }
+      if (shadow) {
+        markup.push(shadow.toSVG(this));
+      }
+      if (clipPath) {
+        markup.push(clipPathMarkup);
+      }
+      markup.push(objectMarkup.join(''));
+      markup.push('</g>\n');
+      absoluteClipPath && markup.push('</g>\n');
+      return reviver ? reviver(markup.join('')) : markup.join('');
     },
 
-    /**
-     * Method that returns an object with the object edges in it, given the coordinates of the corners
-     * @private
-     * @param {Object} oCoords Coordinates of the object corners
-     */
-    _getImageLines: function(oCoords) {
+    addPaintOrder: function() {
+      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
+    }
+  });
+})();
+/* _TO_SVG_END_ */
 
-      var lines = {
-        topline: {
-          o: oCoords.tl,
-          d: oCoords.tr
-        },
-        rightline: {
-          o: oCoords.tr,
-          d: oCoords.br
-        },
-        bottomline: {
-          o: oCoords.br,
-          d: oCoords.bl
-        },
-        leftline: {
-          o: oCoords.bl,
-          d: oCoords.tl
-        }
-      };
 
-      // // debugging
-      // if (this.canvas.contextTop) {
-      //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
-      //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
-      //
-      //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
-      //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
-      //
-      //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
-      //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
-      //
-      //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
-      //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
-      // }
+(function() {
 
-      return lines;
-    },
+  var extend = fabric.util.object.extend,
+      originalSet = 'stateProperties';
 
-    /**
-     * Helper method to determine how many cross points are between the 4 object edges
-     * and the horizontal line determined by a point on canvas
-     * @private
-     * @param {fabric.Point} point Point to check
-     * @param {Object} lines Coordinates of the object being evaluated
-     */
-    // remove yi, not used but left code here just in case.
-    _findCrossPoints: function(point, lines) {
-      var b1, b2, a1, a2, xi, // yi,
-          xcount = 0,
-          iLine;
+  /*
+    Depends on `stateProperties`
+  */
+  function saveProps(origin, destination, props) {
+    var tmpObj = { }, deep = true;
+    props.forEach(function(prop) {
+      tmpObj[prop] = origin[prop];
+    });
 
-      for (var lineKey in lines) {
-        iLine = lines[lineKey];
-        // optimisation 1: line below point. no cross
-        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
-          continue;
-        }
-        // optimisation 2: line above point. no cross
-        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
-          continue;
-        }
-        // optimisation 3: vertical line case
-        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
-          xi = iLine.o.x;
-          // yi = point.y;
-        }
-        // calculate the intersection point
-        else {
-          b1 = 0;
-          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
-          a1 = point.y - b1 * point.x;
-          a2 = iLine.o.y - b2 * iLine.o.x;
+    extend(origin[destination], tmpObj, deep);
+  }
 
-          xi = -(a1 - a2) / (b1 - b2);
-          // yi = a1 + b1 * xi;
+  function _isEqual(origValue, currentValue, firstPass) {
+    if (origValue === currentValue) {
+      // if the objects are identical, return
+      return true;
+    }
+    else if (Array.isArray(origValue)) {
+      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
+        return false;
+      }
+      for (var i = 0, len = origValue.length; i < len; i++) {
+        if (!_isEqual(origValue[i], currentValue[i])) {
+          return false;
         }
-        // dont count xi < point.x cases
-        if (xi >= point.x) {
-          xcount += 1;
+      }
+      return true;
+    }
+    else if (origValue && typeof origValue === 'object') {
+      var keys = Object.keys(origValue), key;
+      if (!currentValue ||
+          typeof currentValue !== 'object' ||
+          (!firstPass && keys.length !== Object.keys(currentValue).length)
+      ) {
+        return false;
+      }
+      for (var i = 0, len = keys.length; i < len; i++) {
+        key = keys[i];
+        // since clipPath is in the statefull cache list and the clipPath objects
+        // would be iterated as an object, this would lead to possible infinite recursion
+        // we do not want to compare those.
+        if (key === 'canvas' || key === 'group') {
+          continue;
         }
-        // optimisation 4: specific for square images
-        if (xcount === 2) {
-          break;
+        if (!_isEqual(origValue[key], currentValue[key])) {
+          return false;
         }
       }
-      return xcount;
-    },
+      return true;
+    }
+  }
 
-    /**
-     * Returns coordinates of object's bounding rectangle (left, top, width, height)
-     * the box is intended as aligned to axis of canvas.
-     * @param {Boolean} [absolute] use coordinates without viewportTransform
-     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
-     * @return {Object} Object with left, top, width, height properties
-     */
-    getBoundingRect: function(absolute, calculate) {
-      var coords = this.getCoords(absolute, calculate);
-      return util.makeBoundingBoxFromPoints(coords);
-    },
 
-    /**
-     * Returns width of an object's bounding box counting transformations
-     * before 2.0 it was named getWidth();
-     * @return {Number} width value
-     */
-    getScaledWidth: function() {
-      return this._getTransformedDimensions().x;
-    },
+  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
 
     /**
-     * Returns height of an object bounding box counting transformations
-     * before 2.0 it was named getHeight();
-     * @return {Number} height value
+     * Returns true if object state (one of its state properties) was changed
+     * @param {String} [propertySet] optional name for the set of property we want to save
+     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
      */
-    getScaledHeight: function() {
-      return this._getTransformedDimensions().y;
+    hasStateChanged: function(propertySet) {
+      propertySet = propertySet || originalSet;
+      var dashedPropertySet = '_' + propertySet;
+      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
+        return true;
+      }
+      return !_isEqual(this[dashedPropertySet], this, true);
     },
 
     /**
-     * Makes sure the scale is valid and modifies it if necessary
-     * @private
-     * @param {Number} value
-     * @return {Number}
+     * Saves state of an object
+     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
+     * @return {fabric.Object} thisArg
      */
-    _constrainScale: function(value) {
-      if (Math.abs(value) < this.minScaleLimit) {
-        if (value < 0) {
-          return -this.minScaleLimit;
-        }
-        else {
-          return this.minScaleLimit;
-        }
+    saveState: function(options) {
+      var propertySet = options && options.propertySet || originalSet,
+          destination = '_' + propertySet;
+      if (!this[destination]) {
+        return this.setupState(options);
       }
-      else if (value === 0) {
-        return 0.0001;
+      saveProps(this, destination, this[propertySet]);
+      if (options && options.stateProperties) {
+        saveProps(this, destination, options.stateProperties);
       }
-      return value;
+      return this;
     },
 
     /**
-     * Scales an object (equally by x and y)
-     * @param {Number} value Scale factor
+     * Setups state of an object
+     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
      * @return {fabric.Object} thisArg
-     * @chainable
      */
-    scale: function(value) {
-      this._set('scaleX', value);
-      this._set('scaleY', value);
-      return this.setCoords();
-    },
+    setupState: function(options) {
+      options = options || { };
+      var propertySet = options.propertySet || originalSet;
+      options.propertySet = propertySet;
+      this['_' + propertySet] = { };
+      this.saveState(options);
+      return this;
+    }
+  });
+})();
 
-    /**
-     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
-     * @param {Number} value New width value
-     * @param {Boolean} absolute ignore viewport
-     * @return {fabric.Object} thisArg
-     * @chainable
-     */
-    scaleToWidth: function(value, absolute) {
-      // adjust to bounding rect factor so that rotated shapes would fit as well
-      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
-      return this.scale(value / this.width / boundingRectFactor);
-    },
 
-    /**
-     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
-     * @param {Number} value New height value
-     * @param {Boolean} absolute ignore viewport
-     * @return {fabric.Object} thisArg
-     * @chainable
-     */
-    scaleToHeight: function(value, absolute) {
-      // adjust to bounding rect factor so that rotated shapes would fit as well
-      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
-      return this.scale(value / this.height / boundingRectFactor);
-    },
+(function() {
+
+  var degreesToRadians = fabric.util.degreesToRadians;
 
+  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
     /**
-     * Calculates and returns the .coords of an object.
-     * unused by the library, only for the end dev.
-     * @return {Object} Object with tl, tr, br, bl ....
-     * @chainable
-     * @deprecated
+     * Determines which corner has been clicked
+     * @private
+     * @param {Object} pointer The pointer indicating the mouse position
+     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
      */
-    calcCoords: function(absolute) {
-      // this is a compatibility function to avoid removing calcCoords now.
-      if (absolute) {
-        return this.calcACoords();
+    _findTargetCorner: function(pointer, forTouch) {
+      // objects in group, anykind, are not self modificable,
+      // must not return an hovered corner.
+      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
+        return false;
       }
-      return this.calcOCoords();
-    },
 
-    calcLineCoords: function() {
-      var vpt = this.getViewportTransform(),
-          padding = this.padding, angle = degreesToRadians(this.angle),
-          cos = util.cos(angle), sin = util.sin(angle),
-          cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
-          cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();
+      var ex = pointer.x,
+          ey = pointer.y,
+          xPoints,
+          lines, keys = Object.keys(this.oCoords),
+          j = keys.length - 1, i;
+      this.__corner = 0;
 
-      var lineCoords = {
-        tl: transformPoint(aCoords.tl, vpt),
-        tr: transformPoint(aCoords.tr, vpt),
-        bl: transformPoint(aCoords.bl, vpt),
-        br: transformPoint(aCoords.br, vpt),
-      };
+      // cycle in reverse order so we pick first the one on top
+      for (; j >= 0; j--) {
+        i = keys[j];
+        if (!this.isControlVisible(i)) {
+          continue;
+        }
 
-      if (padding) {
-        lineCoords.tl.x -= cosPMinusSinP;
-        lineCoords.tl.y -= cosPSinP;
-        lineCoords.tr.x += cosPSinP;
-        lineCoords.tr.y -= cosPMinusSinP;
-        lineCoords.bl.x -= cosPSinP;
-        lineCoords.bl.y += cosPMinusSinP;
-        lineCoords.br.x += cosPMinusSinP;
-        lineCoords.br.y += cosPSinP;
-      }
+        lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
+        // // debugging
+        //
+        // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
+        // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
+        //
+        // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
+        // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
+        //
+        // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
+        // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
+        //
+        // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
+        // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
 
-      return lineCoords;
+        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
+        if (xPoints !== 0 && xPoints % 2 === 1) {
+          this.__corner = i;
+          return i;
+        }
+      }
+      return false;
     },
 
-    calcOCoords: function() {
-      var rotateMatrix = this._calcRotateMatrix(),
-          translateMatrix = this._calcTranslateMatrix(),
-          vpt = this.getViewportTransform(),
-          startMatrix = multiplyMatrices(vpt, translateMatrix),
-          finalMatrix = multiplyMatrices(startMatrix, rotateMatrix),
-          finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]),
-          dim = this._calculateCurrentDimensions(),
-          coords = {};
-      this.forEachControl(function(control, key, fabricObject) {
-        coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
-      });
-
-      // debug code
-      // var canvas = this.canvas;
-      // setTimeout(function() {
-      //   canvas.contextTop.clearRect(0, 0, 700, 700);
-      //   canvas.contextTop.fillStyle = 'green';
-      //   Object.keys(coords).forEach(function(key) {
-      //     var control = coords[key];
-      //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);
-      //   });
-      // }, 50);
-      return coords;
+    /**
+     * Calls a function for each control. The function gets called,
+     * with the control, the object that is calling the iterator and the control's key
+     * @param {Function} fn function to iterate over the controls over
+     */
+    forEachControl: function(fn) {
+      for (var i in this.controls) {
+        fn(this.controls[i], i, this);
+      };
     },
 
-    calcACoords: function() {
-      var rotateMatrix = this._calcRotateMatrix(),
-          translateMatrix = this._calcTranslateMatrix(),
-          finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
-          dim = this._getTransformedDimensions(),
-          w = dim.x / 2, h = dim.y / 2;
-      return {
-        // corners
-        tl: transformPoint({ x: -w, y: -h }, finalMatrix),
-        tr: transformPoint({ x: w, y: -h }, finalMatrix),
-        bl: transformPoint({ x: -w, y: h }, finalMatrix),
-        br: transformPoint({ x: w, y: h }, finalMatrix)
-      };
+    /**
+     * Sets the coordinates of the draggable boxes in the corners of
+     * the image used to scale/rotate it.
+     * note: if we would switch to ROUND corner area, all of this would disappear.
+     * everything would resolve to a single point and a pythagorean theorem for the distance
+     * @private
+     */
+    _setCornerCoords: function() {
+      var coords = this.oCoords;
+
+      for (var control in coords) {
+        var controlObject = this.controls[control];
+        coords[control].corner = controlObject.calcCornerCoords(
+          this.angle, this.cornerSize, coords[control].x, coords[control].y, false);
+        coords[control].touchCorner = controlObject.calcCornerCoords(
+          this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);
+      }
     },
 
     /**
-     * Sets corner and controls position coordinates based on current angle, width and height, left and top.
-     * oCoords are used to find the corners
-     * aCoords are used to quickly find an object on the canvas
-     * lineCoords are used to quickly find object during pointer events.
-     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
-     * @param {Boolean} [skipCorners] skip calculation of oCoords.
+     * Draws a colored layer behind the object, inside its selection borders.
+     * Requires public options: padding, selectionBackgroundColor
+     * this function is called when the context is transformed
+     * has checks to be skipped when the object is on a staticCanvas
+     * @param {CanvasRenderingContext2D} ctx Context to draw on
      * @return {fabric.Object} thisArg
      * @chainable
      */
-    setCoords: function(skipCorners) {
-      this.aCoords = this.calcACoords();
-      // in case we are in a group, for how the inner group target check works,
-      // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.
-      this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
-      if (skipCorners) {
+    drawSelectionBackground: function(ctx) {
+      if (!this.selectionBackgroundColor ||
+        (this.canvas && !this.canvas.interactive) ||
+        (this.canvas && this.canvas._activeObject !== this)
+      ) {
         return this;
       }
-      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
-      this.oCoords = this.calcOCoords();
-      this._setCornerCoords && this._setCornerCoords();
+      ctx.save();
+      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
+          vpt = this.canvas.viewportTransform;
+      ctx.translate(center.x, center.y);
+      ctx.scale(1 / vpt[0], 1 / vpt[3]);
+      ctx.rotate(degreesToRadians(this.angle));
+      ctx.fillStyle = this.selectionBackgroundColor;
+      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
+      ctx.restore();
       return this;
     },
 
     /**
-     * calculate rotation matrix of an object
-     * @return {Array} rotation matrix for the object
+     * Draws borders of an object's bounding box.
+     * Requires public properties: width, height
+     * Requires public options: padding, borderColor
+     * @param {CanvasRenderingContext2D} ctx Context to draw on
+     * @param {Object} styleOverride object to override the object style
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _calcRotateMatrix: function() {
-      return util.calcRotateMatrix(this);
+    drawBorders: function(ctx, styleOverride) {
+      styleOverride = styleOverride || {};
+      var wh = this._calculateCurrentDimensions(),
+          strokeWidth = this.borderScaleFactor,
+          width = wh.x + strokeWidth,
+          height = wh.y + strokeWidth,
+          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
+            styleOverride.hasControls : this.hasControls,
+          shouldStroke = false;
+
+      ctx.save();
+      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
+      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
+
+      ctx.strokeRect(
+        -width / 2,
+        -height / 2,
+        width,
+        height
+      );
+
+      if (hasControls) {
+        ctx.beginPath();
+        this.forEachControl(function(control, key, fabricObject) {
+          // in this moment, the ctx is centered on the object.
+          // width and height of the above function are the size of the bbox.
+          if (control.withConnection && control.getVisibility(fabricObject, key)) {
+            // reset movement for each control
+            shouldStroke = true;
+            ctx.moveTo(control.x * width, control.y * height);
+            ctx.lineTo(
+              control.x * width + control.offsetX,
+              control.y * height + control.offsetY
+            );
+          }
+        });
+        if (shouldStroke) {
+          ctx.stroke();
+        }
+      }
+      ctx.restore();
+      return this;
     },
 
     /**
-     * calculate the translation matrix for an object transform
-     * @return {Array} rotation matrix for the object
+     * Draws borders of an object's bounding box when it is inside a group.
+     * Requires public properties: width, height
+     * Requires public options: padding, borderColor
+     * @param {CanvasRenderingContext2D} ctx Context to draw on
+     * @param {object} options object representing current object parameters
+     * @param {Object} styleOverride object to override the object style
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _calcTranslateMatrix: function() {
-      var center = this.getCenterPoint();
-      return [1, 0, 0, 1, center.x, center.y];
-    },
+    drawBordersInGroup: function(ctx, options, styleOverride) {
+      styleOverride = styleOverride || {};
+      var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options),
+          strokeWidth = this.strokeWidth,
+          strokeUniform = this.strokeUniform,
+          borderScaleFactor = this.borderScaleFactor,
+          width =
+            bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
+          height =
+            bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
+      ctx.save();
+      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
+      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
+      ctx.strokeRect(
+        -width / 2,
+        -height / 2,
+        width,
+        height
+      );
 
-    transformMatrixKey: function(skipGroup) {
-      var sep = '_', prefix = '';
-      if (!skipGroup && this.group) {
-        prefix = this.group.transformMatrixKey(skipGroup) + sep;
-      };
-      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
-        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
-        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
+      ctx.restore();
+      return this;
     },
 
     /**
-     * calculate transform matrix that represents the current transformations from the
-     * object's properties.
-     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
-     * There are some situation in which this is useful to avoid the fake rotation.
-     * @return {Array} transform matrix for the object
+     * Draws corners of an object's bounding box.
+     * Requires public properties: width, height
+     * Requires public options: cornerSize, padding
+     * @param {CanvasRenderingContext2D} ctx Context to draw on
+     * @param {Object} styleOverride object to override the object style
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    calcTransformMatrix: function(skipGroup) {
-      var matrix = this.calcOwnMatrix();
-      if (skipGroup || !this.group) {
-        return matrix;
-      }
-      var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
-      if (cache.key === key) {
-        return cache.value;
+    drawControls: function(ctx, styleOverride) {
+      styleOverride = styleOverride || {};
+      ctx.save();
+      var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;
+      ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);
+      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
+      if (!this.transparentCorners) {
+        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
       }
+      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);
+      this.setCoords();
       if (this.group) {
-        matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);
+        // fabricJS does not really support drawing controls inside groups,
+        // this piece of code here helps having at least the control in places.
+        // If an application needs to show some objects as selected because of some UI state
+        // can still call Object._renderControls() on any object they desire, independently of groups.
+        // using no padding, circular controls and hiding the rotating cursor is higly suggested,
+        matrix = this.group.calcTransformMatrix();
       }
-      cache.key = key;
-      cache.value = matrix;
-      return matrix;
-    },
+      this.forEachControl(function(control, key, fabricObject) {
+        p = fabricObject.oCoords[key];
+        if (control.getVisibility(fabricObject, key)) {
+          if (matrix) {
+            p = fabric.util.transformPoint(p, matrix);
+          }
+          control.render(ctx, p.x, p.y, styleOverride, fabricObject);
+        }
+      });
+      ctx.restore();
 
-    /**
-     * calculate transform matrix that represents the current transformations from the
-     * object's properties, this matrix does not include the group transformation
-     * @return {Array} transform matrix for the object
-     */
-    calcOwnMatrix: function() {
-      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
-      if (cache.key === key) {
-        return cache.value;
-      }
-      var tMatrix = this._calcTranslateMatrix(),
-          options = {
-            angle: this.angle,
-            translateX: tMatrix[4],
-            translateY: tMatrix[5],
-            scaleX: this.scaleX,
-            scaleY: this.scaleY,
-            skewX: this.skewX,
-            skewY: this.skewY,
-            flipX: this.flipX,
-            flipY: this.flipY,
-          };
-      cache.key = key;
-      cache.value = util.composeMatrix(options);
-      return cache.value;
+      return this;
     },
 
-    /*
-     * Calculate object dimensions from its properties
-     * @private
-     * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix
-     * not including or including flipX, flipY to emulate the flipping boolean
-     * @return {Object} .x width dimension
-     * @return {Object} .y height dimension
-     */
-    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
-      return util.calcDimensionsMatrix({
-        skewX: skewX,
-        skewY: skewY,
-        scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
-        scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
-      });
+    /**
+     * Returns true if the specified control is visible, false otherwise.
+     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
+     * @returns {Boolean} true if the specified control is visible, false otherwise
+     */
+    isControlVisible: function(controlKey) {
+      return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
     },
 
-    /*
-     * Calculate object dimensions from its properties
-     * @private
-     * @return {Object} .x width dimension
-     * @return {Object} .y height dimension
+    /**
+     * Sets the visibility of the specified control.
+     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
+     * @param {Boolean} visible true to set the specified control visible, false otherwise
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _getNonTransformedDimensions: function() {
-      var strokeWidth = this.strokeWidth,
-          w = this.width + strokeWidth,
-          h = this.height + strokeWidth;
-      return { x: w, y: h };
+    setControlVisible: function(controlKey, visible) {
+      if (!this._controlsVisibility) {
+        this._controlsVisibility = {};
+      }
+      this._controlsVisibility[controlKey] = visible;
+      return this;
     },
 
-    /*
-     * Calculate object bounding box dimensions from its properties scale, skew.
-     * @param {Number} skewX, a value to override current skewX
-     * @param {Number} skewY, a value to override current skewY
-     * @private
-     * @return {Object} .x width dimension
-     * @return {Object} .y height dimension
+    /**
+     * Sets the visibility state of object controls.
+     * @param {Object} [options] Options object
+     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
+     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
+     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
+     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
+     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
+     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
+     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
+     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
+     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
+     * @return {fabric.Object} thisArg
+     * @chainable
      */
-    _getTransformedDimensions: function(skewX, skewY) {
-      if (typeof skewX === 'undefined') {
-        skewX = this.skewX;
-      }
-      if (typeof skewY === 'undefined') {
-        skewY = this.skewY;
-      }
-      var dimensions, dimX, dimY,
-          noSkew = skewX === 0 && skewY === 0;
+    setControlsVisibility: function(options) {
+      options || (options = { });
 
-      if (this.strokeUniform) {
-        dimX = this.width;
-        dimY = this.height;
-      }
-      else {
-        dimensions = this._getNonTransformedDimensions();
-        dimX = dimensions.x;
-        dimY = dimensions.y;
-      }
-      if (noSkew) {
-        return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
+      for (var p in options) {
+        this.setControlVisible(p, options[p]);
       }
-      var bbox = util.sizeAfterTransform(dimX, dimY, {
-        scaleX: this.scaleX,
-        scaleY: this.scaleY,
-        skewX: skewX,
-        skewY: skewY,
-      });
-      return this._finalizeDimensions(bbox.x, bbox.y);
+      return this;
     },
 
-    /*
-     * Calculate object bounding box dimensions from its properties scale, skew.
-     * @param Number width width of the bbox
-     * @param Number height height of the bbox
-     * @private
-     * @return {Object} .x finalized width dimension
-     * @return {Object} .y finalized height dimension
+
+    /**
+     * This callback function is called every time _discardActiveObject or _setActiveObject
+     * try to to deselect this object. If the function returns true, the process is cancelled
+     * @param {Object} [options] options sent from the upper functions
+     * @param {Event} [options.e] event if the process is generated by an event
+     * @param {fabric.Object} [options.object] the object that is about to be selected if the process finishes
      */
-    _finalizeDimensions: function(width, height) {
-      return this.strokeUniform ?
-        { x: width + this.strokeWidth, y: height + this.strokeWidth }
-        :
-        { x: width, y: height };
+    onDeselect: function() {
+      // implemented by sub-classes, as needed.
     },
 
-    /*
-     * Calculate object dimensions for controls box, including padding and canvas zoom.
-     * and active selection
-     * private
+
+    /**
+     * This callback function is called every time _discardActiveObject or _setActiveObject
+     * try to to select this object. If the function returns true, the process is cancelled
+     * @param {Object} [options] options sent from the upper functions
+     * @param {Event} [options.e] event if the process is generated by an event
+     * @param {fabric.Object} [options.object] the object that was deselected
+     * @param {fabric.Object} [options.subTaregts] instance sub targets for current action
+     * @param {fabric.Object[]} [options.activeSubTargets] sub targets related to `options.object` (children, self, siblings, parent) to help manage selection
+     * @returns {boolean | fabric.Object | undefined} `true` to cancel selection, an object to select instead of this one, `false` for default behavior
      */
-    _calculateCurrentDimensions: function()  {
-      var vpt = this.getViewportTransform(),
-          dim = this._getTransformedDimensions(),
-          p = transformPoint(dim, vpt, true);
-      return p.scalarAdd(2 * this.padding);
-    },
+    onSelect: function (options) {
+      // implemented by sub-classes, as needed.
+      if (options.activeSubTargets) {
+        return options.activeSubTargets[0];
+      }
+    }
   });
 })();
 
 
-fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
+fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
 
   /**
-   * Moves an object to the bottom of the stack of drawn objects
+   * Animation duration (in ms) for fx* methods
+   * @type Number
+   * @default
+   */
+  FX_DURATION: 500,
+
+  /**
+   * Centers object horizontally with animation.
+   * @param {fabric.Object} object Object to center
+   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
+   * @param {Function} [callbacks.onComplete] Invoked on completion
+   * @param {Function} [callbacks.onChange] Invoked on every step of animation
+   * @return {fabric.Canvas} thisArg
+   * @chainable
+   */
+  fxCenterObjectH: function (object, callbacks) {
+    callbacks = callbacks || { };
+
+    var empty = function() { },
+        onComplete = callbacks.onComplete || empty,
+        onChange = callbacks.onChange || empty,
+        _this = this;
+
+    fabric.util.animate({
+      startValue: object.left,
+      endValue: this.getCenter().left,
+      duration: this.FX_DURATION,
+      onChange: function(value) {
+        object.set('left', value);
+        _this.requestRenderAll();
+        onChange();
+      },
+      onComplete: function() {
+        object.setCoords();
+        onComplete();
+      }
+    });
+
+    return this;
+  },
+
+  /**
+   * Centers object vertically with animation.
+   * @param {fabric.Object} object Object to center
+   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
+   * @param {Function} [callbacks.onComplete] Invoked on completion
+   * @param {Function} [callbacks.onChange] Invoked on every step of animation
+   * @return {fabric.Canvas} thisArg
+   * @chainable
+   */
+  fxCenterObjectV: function (object, callbacks) {
+    callbacks = callbacks || { };
+
+    var empty = function() { },
+        onComplete = callbacks.onComplete || empty,
+        onChange = callbacks.onChange || empty,
+        _this = this;
+
+    fabric.util.animate({
+      startValue: object.top,
+      endValue: this.getCenter().top,
+      duration: this.FX_DURATION,
+      onChange: function(value) {
+        object.set('top', value);
+        _this.requestRenderAll();
+        onChange();
+      },
+      onComplete: function() {
+        object.setCoords();
+        onComplete();
+      }
+    });
+
+    return this;
+  },
+
+  /**
+   * Same as `fabric.Canvas#remove` but animated
+   * @param {fabric.Object} object Object to remove
+   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
+   * @param {Function} [callbacks.onComplete] Invoked on completion
+   * @param {Function} [callbacks.onChange] Invoked on every step of animation
+   * @return {fabric.Canvas} thisArg
+   * @chainable
+   */
+  fxRemove: function (object, callbacks) {
+    callbacks = callbacks || { };
+
+    var empty = function() { },
+        onComplete = callbacks.onComplete || empty,
+        onChange = callbacks.onChange || empty,
+        _this = this;
+
+    fabric.util.animate({
+      startValue: object.opacity,
+      endValue: 0,
+      duration: this.FX_DURATION,
+      onChange: function(value) {
+        object.set('opacity', value);
+        _this.requestRenderAll();
+        onChange();
+      },
+      onComplete: function () {
+        _this.remove(object);
+        onComplete();
+      }
+    });
+
+    return this;
+  }
+});
+
+fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
+  /**
+   * Animates object's properties
+   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
+   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
    * @return {fabric.Object} thisArg
+   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
    * @chainable
+   *
+   * As object — multiple properties
+   *
+   * object.animate({ left: ..., top: ... });
+   * object.animate({ left: ..., top: ... }, { duration: ... });
+   *
+   * As string — one property
+   *
+   * object.animate('left', ...);
+   * object.animate('left', { duration: ... });
+   *
    */
-  sendToBack: function() {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
+  animate: function() {
+    if (arguments[0] && typeof arguments[0] === 'object') {
+      var propsToAnimate = [], prop, skipCallbacks;
+      for (prop in arguments[0]) {
+        propsToAnimate.push(prop);
+      }
+      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
+        prop = propsToAnimate[i];
+        skipCallbacks = i !== len - 1;
+        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
+      }
     }
-    else if (this.canvas) {
-      this.canvas.sendToBack(this);
+    else {
+      this._animate.apply(this, arguments);
     }
     return this;
   },
 
   /**
-   * Moves an object to the top of the stack of drawn objects
-   * @return {fabric.Object} thisArg
-   * @chainable
+   * @private
+   * @param {String} property Property to animate
+   * @param {String} to Value to animate to
+   * @param {Object} [options] Options object
+   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
    */
-  bringToFront: function() {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
+  _animate: function(property, to, options, skipCallbacks) {
+    var _this = this, propPair;
+
+    to = to.toString();
+
+    if (!options) {
+      options = { };
     }
-    else if (this.canvas) {
-      this.canvas.bringToFront(this);
+    else {
+      options = fabric.util.object.clone(options);
     }
-    return this;
-  },
 
-  /**
-   * Moves an object down in stack of drawn objects
-   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
-   * @return {fabric.Object} thisArg
-   * @chainable
-   */
-  sendBackwards: function(intersecting) {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
-    }
-    else if (this.canvas) {
-      this.canvas.sendBackwards(this, intersecting);
+    if (~property.indexOf('.')) {
+      propPair = property.split('.');
     }
-    return this;
-  },
 
-  /**
-   * Moves an object up in stack of drawn objects
-   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
-   * @return {fabric.Object} thisArg
-   * @chainable
-   */
-  bringForward: function(intersecting) {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
+    var propIsColor =
+      _this.colorProperties.indexOf(property) > -1 ||
+      (propPair && _this.colorProperties.indexOf(propPair[1]) > -1);
+
+    var currentValue = propPair
+      ? this.get(propPair[0])[propPair[1]]
+      : this.get(property);
+
+    if (!('from' in options)) {
+      options.from = currentValue;
     }
-    else if (this.canvas) {
-      this.canvas.bringForward(this, intersecting);
+
+    if (!propIsColor) {
+      if (~to.indexOf('=')) {
+        to = currentValue + parseFloat(to.replace('=', ''));
+      }
+      else {
+        to = parseFloat(to);
+      }
     }
-    return this;
-  },
 
-  /**
-   * Moves an object to specified level in stack of drawn objects
-   * @param {Number} index New position of object
-   * @return {fabric.Object} thisArg
-   * @chainable
-   */
-  moveTo: function(index) {
-    if (this.group && this.group.type !== 'activeSelection') {
-      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
+    var _options = {
+      startValue: options.from,
+      endValue: to,
+      byValue: options.by,
+      easing: options.easing,
+      duration: options.duration,
+      abort: options.abort && function(value, valueProgress, timeProgress) {
+        return options.abort.call(_this, value, valueProgress, timeProgress);
+      },
+      onChange: function (value, valueProgress, timeProgress) {
+        if (propPair) {
+          _this[propPair[0]][propPair[1]] = value;
+        }
+        else {
+          _this.set(property, value);
+        }
+        if (skipCallbacks) {
+          return;
+        }
+        options.onChange && options.onChange(value, valueProgress, timeProgress);
+      },
+      onComplete: function (value, valueProgress, timeProgress) {
+        if (skipCallbacks) {
+          return;
+        }
+
+        _this.setCoords();
+        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
+      }
+    };
+
+    if (propIsColor) {
+      return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
     }
-    else if (this.canvas) {
-      this.canvas.moveTo(this, index);
+    else {
+      return fabric.util.animate(_options);
     }
-    return this;
   }
 });
 
 
-/* _TO_SVG_START_ */
-(function() {
-  function getSvgColorString(prop, value) {
-    if (!value) {
-      return prop + ': none; ';
-    }
-    else if (value.toLive) {
-      return prop + ': url(#SVGID_' + value.id + '); ';
-    }
-    else {
-      var color = new fabric.Color(value),
-          str = prop + ': ' + color.toRgb() + '; ',
-          opacity = color.getAlpha();
-      if (opacity !== 1) {
-        //change the color in rgb + opacity
-        str += prop + '-opacity: ' + opacity.toString() + '; ';
-      }
-      return str;
-    }
+(function(global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = { }),
+      extend = fabric.util.object.extend,
+      clone = fabric.util.object.clone,
+      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 };
+
+  if (fabric.Line) {
+    fabric.warn('fabric.Line is already defined');
+    return;
   }
 
-  var toFixed = fabric.util.toFixed;
+  /**
+   * Line class
+   * @class fabric.Line
+   * @extends fabric.Object
+   * @see {@link fabric.Line#initialize} for constructor definition
+   */
+  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {
 
-  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
     /**
-     * Returns styles-string for svg-export
-     * @param {Boolean} skipShadow a boolean to skip shadow filter output
-     * @return {String}
+     * Type of an object
+     * @type String
+     * @default
      */
-    getSvgStyles: function(skipShadow) {
+    type: 'line',
 
-      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
-          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
-          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
-          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
-          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
-          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
-          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
-          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
-          visibility = this.visible ? '' : ' visibility: hidden;',
-          filter = skipShadow ? '' : this.getSvgFilter(),
-          fill = getSvgColorString('fill', this.fill),
-          stroke = getSvgColorString('stroke', this.stroke);
+    /**
+     * x value or first line edge
+     * @type Number
+     * @default
+     */
+    x1: 0,
 
-      return [
-        stroke,
-        'stroke-width: ', strokeWidth, '; ',
-        'stroke-dasharray: ', strokeDashArray, '; ',
-        'stroke-linecap: ', strokeLineCap, '; ',
-        'stroke-dashoffset: ', strokeDashOffset, '; ',
-        'stroke-linejoin: ', strokeLineJoin, '; ',
-        'stroke-miterlimit: ', strokeMiterLimit, '; ',
-        fill,
-        'fill-rule: ', fillRule, '; ',
-        'opacity: ', opacity, ';',
-        filter,
-        visibility
-      ].join('');
-    },
+    /**
+     * y value or first line edge
+     * @type Number
+     * @default
+     */
+    y1: 0,
 
     /**
-     * Returns styles-string for svg-export
-     * @param {Object} style the object from which to retrieve style properties
-     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
-     * @return {String}
+     * x value or second line edge
+     * @type Number
+     * @default
      */
-    getSvgSpanStyles: function(style, useWhiteSpace) {
-      var term = '; ';
-      var fontFamily = style.fontFamily ?
-        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
-          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
-      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
-          fontFamily = fontFamily,
-          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
-          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
-          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
-          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
-          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
-          textDecoration = this.getSvgTextDecoration(style),
-          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
-      if (textDecoration) {
-        textDecoration = 'text-decoration: ' + textDecoration + term;
+    x2: 0,
+
+    /**
+     * y value or second line edge
+     * @type Number
+     * @default
+     */
+    y2: 0,
+
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),
+
+    /**
+     * Constructor
+     * @param {Array} [points] Array of points
+     * @param {Object} [options] Options object
+     * @return {fabric.Line} thisArg
+     */
+    initialize: function(points, options) {
+      if (!points) {
+        points = [0, 0, 0, 0];
       }
 
-      return [
-        stroke,
-        strokeWidth,
-        fontFamily,
-        fontSize,
-        fontStyle,
-        fontWeight,
-        textDecoration,
-        fill,
-        deltaY,
-        useWhiteSpace ? 'white-space: pre; ' : ''
-      ].join('');
+      this.callSuper('initialize', options);
+
+      this.set('x1', points[0]);
+      this.set('y1', points[1]);
+      this.set('x2', points[2]);
+      this.set('y2', points[3]);
+
+      this._setWidthHeight(options);
     },
 
     /**
-     * Returns text-decoration property for svg-export
-     * @param {Object} style the object from which to retrieve style properties
-     * @return {String}
+     * @private
+     * @param {Object} [options] Options
      */
-    getSvgTextDecoration: function(style) {
-      return ['overline', 'underline', 'line-through'].filter(function(decoration) {
-        return style[decoration.replace('-', '')];
-      }).join(' ');
+    _setWidthHeight: function(options) {
+      options || (options = { });
+
+      this.width = Math.abs(this.x2 - this.x1);
+      this.height = Math.abs(this.y2 - this.y1);
+
+      this.left = 'left' in options
+        ? options.left
+        : this._getLeftToOriginX();
+
+      this.top = 'top' in options
+        ? options.top
+        : this._getTopToOriginY();
     },
 
     /**
-     * Returns filter for svg shadow
-     * @return {String}
+     * @private
+     * @param {String} key
+     * @param {*} value
      */
-    getSvgFilter: function() {
-      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
+    _set: function(key, value) {
+      this.callSuper('_set', key, value);
+      if (typeof coordProps[key] !== 'undefined') {
+        this._setWidthHeight();
+      }
+      return this;
     },
 
     /**
-     * Returns id attribute for svg output
-     * @return {String}
+     * @private
+     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
      */
-    getSvgCommons: function() {
-      return [
-        this.id ? 'id="' + this.id + '" ' : '',
-        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
-      ].join('');
-    },
+    _getLeftToOriginX: makeEdgeToOriginGetter(
+      { // property names
+        origin: 'originX',
+        axis1: 'x1',
+        axis2: 'x2',
+        dimension: 'width'
+      },
+      { // possible values of origin
+        nearest: 'left',
+        center: 'center',
+        farthest: 'right'
+      }
+    ),
 
     /**
-     * Returns transform-string for svg-export
-     * @param {Boolean} use the full transform or the single object one.
-     * @return {String}
+     * @private
+     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
      */
-    getSvgTransform: function(full, additionalTransform) {
-      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
-          svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
-      return svgTransform +
-        (additionalTransform || '') + '" ';
-    },
-
-    _setSVGBg: function(textBgRects) {
-      if (this.backgroundColor) {
-        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
-        textBgRects.push(
-          '\t\t<rect ',
-          this._getFillAttributes(this.backgroundColor),
-          ' x="',
-          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
-          '" y="',
-          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
-          '" width="',
-          toFixed(this.width, NUM_FRACTION_DIGITS),
-          '" height="',
-          toFixed(this.height, NUM_FRACTION_DIGITS),
-          '"></rect>\n');
+    _getTopToOriginY: makeEdgeToOriginGetter(
+      { // property names
+        origin: 'originY',
+        axis1: 'y1',
+        axis2: 'y2',
+        dimension: 'height'
+      },
+      { // possible values of origin
+        nearest: 'top',
+        center: 'center',
+        farthest: 'bottom'
       }
-    },
+    ),
 
     /**
-     * Returns svg representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    toSVG: function(reviver) {
-      return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
+    _render: function(ctx) {
+      ctx.beginPath();
+
+
+      var p = this.calcLinePoints();
+      ctx.moveTo(p.x1, p.y1);
+      ctx.lineTo(p.x2, p.y2);
+
+      ctx.lineWidth = this.strokeWidth;
+
+      // TODO: test this
+      // make sure setting "fill" changes color of a line
+      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
+      var origStrokeStyle = ctx.strokeStyle;
+      ctx.strokeStyle = this.stroke || ctx.fillStyle;
+      this.stroke && this._renderStroke(ctx);
+      ctx.strokeStyle = origStrokeStyle;
     },
 
     /**
-     * Returns svg clipPath representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * This function is an helper for svg import. it returns the center of the object in the svg
+     * untransformed coordinates
+     * @private
+     * @return {Object} center point from element coordinates
      */
-    toClipPathSVG: function(reviver) {
-      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
+    _findCenterFromElement: function() {
+      return {
+        x: (this.x1 + this.x2) / 2,
+        y: (this.y1 + this.y2) / 2,
+      };
     },
 
     /**
+     * Returns object representation of an instance
+     * @method toObject
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
+     */
+    toObject: function(propertiesToInclude) {
+      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
+    },
+
+    /*
+     * Calculate object dimensions from its properties
      * @private
      */
-    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
-      options = options || {};
-      var reviver = options.reviver,
-          additionalTransform = options.additionalTransform || '',
-          commonPieces = [
-            this.getSvgTransform(true, additionalTransform),
-            this.getSvgCommons(),
-          ].join(''),
-          // insert commons in the markup, style and svgCommons
-          index = objectMarkup.indexOf('COMMON_PARTS');
-      objectMarkup[index] = commonPieces;
-      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
+    _getNonTransformedDimensions: function() {
+      var dim = this.callSuper('_getNonTransformedDimensions');
+      if (this.strokeLineCap === 'butt') {
+        if (this.width === 0) {
+          dim.y -= this.strokeWidth;
+        }
+        if (this.height === 0) {
+          dim.x -= this.strokeWidth;
+        }
+      }
+      return dim;
     },
 
     /**
+     * Recalculates line points given width and height
      * @private
      */
-    _createBaseSVGMarkup: function(objectMarkup, options) {
-      options = options || {};
-      var noStyle = options.noStyle,
-          reviver = options.reviver,
-          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
-          shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
-          clipPath = this.clipPath,
-          vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
-          absoluteClipPath = clipPath && clipPath.absolutePositioned,
-          stroke = this.stroke, fill = this.fill, shadow = this.shadow,
-          commonPieces, markup = [], clipPathMarkup,
-          // insert commons in the markup, style and svgCommons
-          index = objectMarkup.indexOf('COMMON_PARTS'),
-          additionalTransform = options.additionalTransform;
-      if (clipPath) {
-        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
-        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
-          clipPath.toClipPathSVG(reviver) +
-          '</clipPath>\n';
-      }
-      if (absoluteClipPath) {
-        markup.push(
-          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
-        );
-      }
-      markup.push(
-        '<g ',
-        this.getSvgTransform(false),
-        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
-        ' >\n'
-      );
-      commonPieces = [
-        styleInfo,
-        vectorEffect,
-        noStyle ? '' : this.addPaintOrder(), ' ',
-        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
-      ].join('');
-      objectMarkup[index] = commonPieces;
-      if (fill && fill.toLive) {
-        markup.push(fill.toSVG(this));
-      }
-      if (stroke && stroke.toLive) {
-        markup.push(stroke.toSVG(this));
-      }
-      if (shadow) {
-        markup.push(shadow.toSVG(this));
-      }
-      if (clipPath) {
-        markup.push(clipPathMarkup);
-      }
-      markup.push(objectMarkup.join(''));
-      markup.push('</g>\n');
-      absoluteClipPath && markup.push('</g>\n');
-      return reviver ? reviver(markup.join('')) : markup.join('');
+    calcLinePoints: function() {
+      var xMult = this.x1 <= this.x2 ? -1 : 1,
+          yMult = this.y1 <= this.y2 ? -1 : 1,
+          x1 = (xMult * this.width * 0.5),
+          y1 = (yMult * this.height * 0.5),
+          x2 = (xMult * this.width * -0.5),
+          y2 = (yMult * this.height * -0.5);
+
+      return {
+        x1: x1,
+        x2: x2,
+        y1: y1,
+        y2: y2
+      };
+    },
+
+    /* _TO_SVG_START_ */
+    /**
+     * Returns svg representation of an instance
+     * @return {Array} an array of strings with the specific svg representation
+     * of the instance
+     */
+    _toSVG: function() {
+      var p = this.calcLinePoints();
+      return [
+        '<line ', 'COMMON_PARTS',
+        'x1="', p.x1,
+        '" y1="', p.y1,
+        '" x2="', p.x2,
+        '" y2="', p.y2,
+        '" />\n'
+      ];
     },
-
-    addPaintOrder: function() {
-      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
-    }
+    /* _TO_SVG_END_ */
   });
-})();
-/* _TO_SVG_END_ */
-
 
-(function() {
+  /* _FROM_SVG_START_ */
+  /**
+   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
+   * @static
+   * @memberOf fabric.Line
+   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
+   */
+  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
 
-  var extend = fabric.util.object.extend,
-      originalSet = 'stateProperties';
+  /**
+   * Returns fabric.Line instance from an SVG element
+   * @static
+   * @memberOf fabric.Line
+   * @param {SVGElement} element Element to parse
+   * @param {Object} [options] Options object
+   * @param {Function} [callback] callback function invoked after parsing
+   */
+  fabric.Line.fromElement = function(element, callback, options) {
+    options = options || { };
+    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
+        points = [
+          parsedAttributes.x1 || 0,
+          parsedAttributes.y1 || 0,
+          parsedAttributes.x2 || 0,
+          parsedAttributes.y2 || 0
+        ];
+    callback(new fabric.Line(points, extend(parsedAttributes, options)));
+  };
+  /* _FROM_SVG_END_ */
 
-  /*
-    Depends on `stateProperties`
-  */
-  function saveProps(origin, destination, props) {
-    var tmpObj = { }, deep = true;
-    props.forEach(function(prop) {
-      tmpObj[prop] = origin[prop];
-    });
+  /**
+   * Returns fabric.Line instance from an object representation
+   * @static
+   * @memberOf fabric.Line
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   */
+  fabric.Line.fromObject = function(object, callback) {
+    function _callback(instance) {
+      delete instance.points;
+      callback && callback(instance);
+    };
+    var options = clone(object, true);
+    options.points = [object.x1, object.y1, object.x2, object.y2];
+    fabric.Object._fromObject('Line', options, _callback, 'points');
+  };
 
-    extend(origin[destination], tmpObj, deep);
-  }
+  /**
+   * Produces a function that calculates distance from canvas edge to Line origin.
+   */
+  function makeEdgeToOriginGetter(propertyNames, originValues) {
+    var origin = propertyNames.origin,
+        axis1 = propertyNames.axis1,
+        axis2 = propertyNames.axis2,
+        dimension = propertyNames.dimension,
+        nearest = originValues.nearest,
+        center = originValues.center,
+        farthest = originValues.farthest;
 
-  function _isEqual(origValue, currentValue, firstPass) {
-    if (origValue === currentValue) {
-      // if the objects are identical, return
-      return true;
-    }
-    else if (Array.isArray(origValue)) {
-      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
-        return false;
-      }
-      for (var i = 0, len = origValue.length; i < len; i++) {
-        if (!_isEqual(origValue[i], currentValue[i])) {
-          return false;
-        }
-      }
-      return true;
-    }
-    else if (origValue && typeof origValue === 'object') {
-      var keys = Object.keys(origValue), key;
-      if (!currentValue ||
-          typeof currentValue !== 'object' ||
-          (!firstPass && keys.length !== Object.keys(currentValue).length)
-      ) {
-        return false;
-      }
-      for (var i = 0, len = keys.length; i < len; i++) {
-        key = keys[i];
-        // since clipPath is in the statefull cache list and the clipPath objects
-        // would be iterated as an object, this would lead to possible infinite recursion
-        // we do not want to compare those.
-        if (key === 'canvas' || key === 'group') {
-          continue;
-        }
-        if (!_isEqual(origValue[key], currentValue[key])) {
-          return false;
-        }
+    return function() {
+      switch (this.get(origin)) {
+        case nearest:
+          return Math.min(this.get(axis1), this.get(axis2));
+        case center:
+          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
+        case farthest:
+          return Math.max(this.get(axis1), this.get(axis2));
       }
-      return true;
-    }
+    };
+
   }
 
+})(typeof exports !== 'undefined' ? exports : this);
+
 
-  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
+(function(global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = { }),
+      pi = Math.PI;
+
+  if (fabric.Circle) {
+    fabric.warn('fabric.Circle is already defined.');
+    return;
+  }
+
+  /**
+   * Circle class
+   * @class fabric.Circle
+   * @extends fabric.Object
+   * @see {@link fabric.Circle#initialize} for constructor definition
+   */
+  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {
 
     /**
-     * Returns true if object state (one of its state properties) was changed
-     * @param {String} [propertySet] optional name for the set of property we want to save
-     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
+     * Type of an object
+     * @type String
+     * @default
      */
-    hasStateChanged: function(propertySet) {
-      propertySet = propertySet || originalSet;
-      var dashedPropertySet = '_' + propertySet;
-      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
-        return true;
-      }
-      return !_isEqual(this[dashedPropertySet], this, true);
-    },
+    type: 'circle',
 
     /**
-     * Saves state of an object
-     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
-     * @return {fabric.Object} thisArg
+     * Radius of this circle
+     * @type Number
+     * @default
      */
-    saveState: function(options) {
-      var propertySet = options && options.propertySet || originalSet,
-          destination = '_' + propertySet;
-      if (!this[destination]) {
-        return this.setupState(options);
-      }
-      saveProps(this, destination, this[propertySet]);
-      if (options && options.stateProperties) {
-        saveProps(this, destination, options.stateProperties);
-      }
-      return this;
-    },
+    radius: 0,
 
     /**
-     * Setups state of an object
-     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
-     * @return {fabric.Object} thisArg
+     * Start angle of the circle, moving clockwise
+     * deprecated type, this should be in degree, this was an oversight.
+     * probably will change to degrees in next major version
+     * @type Number
+     * @default 0
      */
-    setupState: function(options) {
-      options = options || { };
-      var propertySet = options.propertySet || originalSet;
-      options.propertySet = propertySet;
-      this['_' + propertySet] = { };
-      this.saveState(options);
-      return this;
-    }
-  });
-})();
-
+    startAngle: 0,
 
-(function() {
+    /**
+     * End angle of the circle
+     * deprecated type, this should be in degree, this was an oversight.
+     * probably will change to degrees in next major version
+     * @type Number
+     * @default 2Pi
+     */
+    endAngle: pi * 2,
 
-  var degreesToRadians = fabric.util.degreesToRadians;
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),
 
-  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
     /**
-     * Determines which corner has been clicked
      * @private
-     * @param {Object} pointer The pointer indicating the mouse position
-     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
+     * @param {String} key
+     * @param {*} value
+     * @return {fabric.Circle} thisArg
      */
-    _findTargetCorner: function(pointer, forTouch) {
-      // objects in group, anykind, are not self modificable,
-      // must not return an hovered corner.
-      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
-        return false;
-      }
-
-      var ex = pointer.x,
-          ey = pointer.y,
-          xPoints,
-          lines, keys = Object.keys(this.oCoords),
-          j = keys.length - 1, i;
-      this.__corner = 0;
-
-      // cycle in reverse order so we pick first the one on top
-      for (; j >= 0; j--) {
-        i = keys[j];
-        if (!this.isControlVisible(i)) {
-          continue;
-        }
-
-        lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
-        // // debugging
-        //
-        // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
-        // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
-        //
-        // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
-        // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
-        //
-        // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
-        // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
-        //
-        // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
-        // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
+    _set: function(key, value) {
+      this.callSuper('_set', key, value);
 
-        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
-        if (xPoints !== 0 && xPoints % 2 === 1) {
-          this.__corner = i;
-          return i;
-        }
+      if (key === 'radius') {
+        this.setRadius(value);
       }
-      return false;
+
+      return this;
     },
 
     /**
-     * Calls a function for each control. The function gets called,
-     * with the control, the object that is calling the iterator and the control's key
-     * @param {Function} fn function to iterate over the controls over
+     * Returns object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
      */
-    forEachControl: function(fn) {
-      for (var i in this.controls) {
-        fn(this.controls[i], i, this);
-      };
+    toObject: function(propertiesToInclude) {
+      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
     },
 
+    /* _TO_SVG_START_ */
+
     /**
-     * Sets the coordinates of the draggable boxes in the corners of
-     * the image used to scale/rotate it.
-     * note: if we would switch to ROUND corner area, all of this would disappear.
-     * everything would resolve to a single point and a pythagorean theorem for the distance
-     * @private
+     * Returns svg representation of an instance
+     * @return {Array} an array of strings with the specific svg representation
+     * of the instance
      */
-    _setCornerCoords: function() {
-      var coords = this.oCoords;
+    _toSVG: function() {
+      var svgString, x = 0, y = 0,
+          angle = (this.endAngle - this.startAngle) % ( 2 * pi);
 
-      for (var control in coords) {
-        var controlObject = this.controls[control];
-        coords[control].corner = controlObject.calcCornerCoords(
-          this.angle, this.cornerSize, coords[control].x, coords[control].y, false);
-        coords[control].touchCorner = controlObject.calcCornerCoords(
-          this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);
+      if (angle === 0) {
+        svgString = [
+          '<circle ', 'COMMON_PARTS',
+          'cx="' + x + '" cy="' + y + '" ',
+          'r="', this.radius,
+          '" />\n'
+        ];
+      }
+      else {
+        var startX = fabric.util.cos(this.startAngle) * this.radius,
+            startY = fabric.util.sin(this.startAngle) * this.radius,
+            endX = fabric.util.cos(this.endAngle) * this.radius,
+            endY = fabric.util.sin(this.endAngle) * this.radius,
+            largeFlag = angle > pi ? '1' : '0';
+        svgString = [
+          '<path d="M ' + startX + ' ' + startY,
+          ' A ' + this.radius + ' ' + this.radius,
+          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
+          '" ', 'COMMON_PARTS', ' />\n'
+        ];
       }
+      return svgString;
     },
+    /* _TO_SVG_END_ */
 
     /**
-     * Draws a colored layer behind the object, inside its selection borders.
-     * Requires public options: padding, selectionBackgroundColor
-     * this function is called when the context is transformed
-     * has checks to be skipped when the object is on a staticCanvas
-     * @param {CanvasRenderingContext2D} ctx Context to draw on
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * @private
+     * @param {CanvasRenderingContext2D} ctx context to render on
      */
-    drawSelectionBackground: function(ctx) {
-      if (!this.selectionBackgroundColor ||
-        (this.canvas && !this.canvas.interactive) ||
-        (this.canvas && this.canvas._activeObject !== this)
-      ) {
-        return this;
-      }
-      ctx.save();
-      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
-          vpt = this.canvas.viewportTransform;
-      ctx.translate(center.x, center.y);
-      ctx.scale(1 / vpt[0], 1 / vpt[3]);
-      ctx.rotate(degreesToRadians(this.angle));
-      ctx.fillStyle = this.selectionBackgroundColor;
-      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
-      ctx.restore();
-      return this;
+    _render: function(ctx) {
+      ctx.beginPath();
+      ctx.arc(
+        0,
+        0,
+        this.radius,
+        this.startAngle,
+        this.endAngle, false);
+      this._renderPaintInOrder(ctx);
     },
 
     /**
-     * Draws borders of an object's bounding box.
-     * Requires public properties: width, height
-     * Requires public options: padding, borderColor
-     * @param {CanvasRenderingContext2D} ctx Context to draw on
-     * @param {Object} styleOverride object to override the object style
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Returns horizontal radius of an object (according to how an object is scaled)
+     * @return {Number}
      */
-    drawBorders: function(ctx, styleOverride) {
-      styleOverride = styleOverride || {};
-      var wh = this._calculateCurrentDimensions(),
-          strokeWidth = this.borderScaleFactor,
-          width = wh.x + strokeWidth,
-          height = wh.y + strokeWidth,
-          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
-            styleOverride.hasControls : this.hasControls,
-          shouldStroke = false;
-
-      ctx.save();
-      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
-      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
-
-      ctx.strokeRect(
-        -width / 2,
-        -height / 2,
-        width,
-        height
-      );
+    getRadiusX: function() {
+      return this.get('radius') * this.get('scaleX');
+    },
 
-      if (hasControls) {
-        ctx.beginPath();
-        this.forEachControl(function(control, key, fabricObject) {
-          // in this moment, the ctx is centered on the object.
-          // width and height of the above function are the size of the bbox.
-          if (control.withConnection && control.getVisibility(fabricObject, key)) {
-            // reset movement for each control
-            shouldStroke = true;
-            ctx.moveTo(control.x * width, control.y * height);
-            ctx.lineTo(
-              control.x * width + control.offsetX,
-              control.y * height + control.offsetY
-            );
-          }
-        });
-        if (shouldStroke) {
-          ctx.stroke();
-        }
-      }
-      ctx.restore();
-      return this;
+    /**
+     * Returns vertical radius of an object (according to how an object is scaled)
+     * @return {Number}
+     */
+    getRadiusY: function() {
+      return this.get('radius') * this.get('scaleY');
     },
 
     /**
-     * Draws borders of an object's bounding box when it is inside a group.
-     * Requires public properties: width, height
-     * Requires public options: padding, borderColor
-     * @param {CanvasRenderingContext2D} ctx Context to draw on
-     * @param {object} options object representing current object parameters
-     * @param {Object} styleOverride object to override the object style
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Sets radius of an object (and updates width accordingly)
+     * @return {fabric.Circle} thisArg
      */
-    drawBordersInGroup: function(ctx, options, styleOverride) {
-      styleOverride = styleOverride || {};
-      var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options),
-          strokeWidth = this.strokeWidth,
-          strokeUniform = this.strokeUniform,
-          borderScaleFactor = this.borderScaleFactor,
-          width =
-            bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
-          height =
-            bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
-      ctx.save();
-      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
-      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
-      ctx.strokeRect(
-        -width / 2,
-        -height / 2,
-        width,
-        height
-      );
+    setRadius: function(value) {
+      this.radius = value;
+      return this.set('width', value * 2).set('height', value * 2);
+    },
+  });
+
+  /* _FROM_SVG_START_ */
+  /**
+   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
+   * @static
+   * @memberOf fabric.Circle
+   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
+   */
+  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
+
+  /**
+   * Returns {@link fabric.Circle} instance from an SVG element
+   * @static
+   * @memberOf fabric.Circle
+   * @param {SVGElement} element Element to parse
+   * @param {Function} [callback] Options callback invoked after parsing is finished
+   * @param {Object} [options] Options object
+   * @throws {Error} If value of `r` attribute is missing or invalid
+   */
+  fabric.Circle.fromElement = function(element, callback) {
+    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
+
+    if (!isValidRadius(parsedAttributes)) {
+      throw new Error('value of `r` attribute is required and can not be negative');
+    }
+
+    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
+    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
+    callback(new fabric.Circle(parsedAttributes));
+  };
+
+  /**
+   * @private
+   */
+  function isValidRadius(attributes) {
+    return (('radius' in attributes) && (attributes.radius >= 0));
+  }
+  /* _FROM_SVG_END_ */
+
+  /**
+   * Returns {@link fabric.Circle} instance from an object representation
+   * @static
+   * @memberOf fabric.Circle
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   * @return {void}
+   */
+  fabric.Circle.fromObject = function(object, callback) {
+    fabric.Object._fromObject('Circle', object, callback);
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+(function(global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = { });
+
+  if (fabric.Triangle) {
+    fabric.warn('fabric.Triangle is already defined');
+    return;
+  }
 
-      ctx.restore();
-      return this;
-    },
+  /**
+   * Triangle class
+   * @class fabric.Triangle
+   * @extends fabric.Object
+   * @return {fabric.Triangle} thisArg
+   * @see {@link fabric.Triangle#initialize} for constructor definition
+   */
+  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {
 
     /**
-     * Draws corners of an object's bounding box.
-     * Requires public properties: width, height
-     * Requires public options: cornerSize, padding
-     * @param {CanvasRenderingContext2D} ctx Context to draw on
-     * @param {Object} styleOverride object to override the object style
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Type of an object
+     * @type String
+     * @default
      */
-    drawControls: function(ctx, styleOverride) {
-      styleOverride = styleOverride || {};
-      ctx.save();
-      var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;
-      ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);
-      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
-      if (!this.transparentCorners) {
-        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
-      }
-      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);
-      this.setCoords();
-      if (this.group) {
-        // fabricJS does not really support drawing controls inside groups,
-        // this piece of code here helps having at least the control in places.
-        // If an application needs to show some objects as selected because of some UI state
-        // can still call Object._renderControls() on any object they desire, independently of groups.
-        // using no padding, circular controls and hiding the rotating cursor is higly suggested,
-        matrix = this.group.calcTransformMatrix();
-      }
-      this.forEachControl(function(control, key, fabricObject) {
-        p = fabricObject.oCoords[key];
-        if (control.getVisibility(fabricObject, key)) {
-          if (matrix) {
-            p = fabric.util.transformPoint(p, matrix);
-          }
-          control.render(ctx, p.x, p.y, styleOverride, fabricObject);
-        }
-      });
-      ctx.restore();
-
-      return this;
-    },
+    type: 'triangle',
 
     /**
-     * Returns true if the specified control is visible, false otherwise.
-     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
-     * @returns {Boolean} true if the specified control is visible, false otherwise
+     * Width is set to 100 to compensate the old initialize code that was setting it to 100
+     * @type Number
+     * @default
      */
-    isControlVisible: function(controlKey) {
-      return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
-    },
+    width: 100,
 
     /**
-     * Sets the visibility of the specified control.
-     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
-     * @param {Boolean} visible true to set the specified control visible, false otherwise
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * Height is set to 100 to compensate the old initialize code that was setting it to 100
+     * @type Number
+     * @default
      */
-    setControlVisible: function(controlKey, visible) {
-      if (!this._controlsVisibility) {
-        this._controlsVisibility = {};
-      }
-      this._controlsVisibility[controlKey] = visible;
-      return this;
-    },
+    height: 100,
 
     /**
-     * Sets the visibility state of object controls.
-     * @param {Object} [options] Options object
-     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
-     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
-     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
-     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
-     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
-     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
-     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
-     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
-     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
-     * @return {fabric.Object} thisArg
-     * @chainable
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    setControlsVisibility: function(options) {
-      options || (options = { });
-
-      for (var p in options) {
-        this.setControlVisible(p, options[p]);
-      }
-      return this;
-    },
+    _render: function(ctx) {
+      var widthBy2 = this.width / 2,
+          heightBy2 = this.height / 2;
 
+      ctx.beginPath();
+      ctx.moveTo(-widthBy2, heightBy2);
+      ctx.lineTo(0, -heightBy2);
+      ctx.lineTo(widthBy2, heightBy2);
+      ctx.closePath();
 
-    /**
-     * This callback function is called every time _discardActiveObject or _setActiveObject
-     * try to to deselect this object. If the function returns true, the process is cancelled
-     * @param {Object} [options] options sent from the upper functions
-     * @param {Event} [options.e] event if the process is generated by an event
-     */
-    onDeselect: function() {
-      // implemented by sub-classes, as needed.
+      this._renderPaintInOrder(ctx);
     },
 
-
+    /* _TO_SVG_START_ */
     /**
-     * This callback function is called every time _discardActiveObject or _setActiveObject
-     * try to to select this object. If the function returns true, the process is cancelled
-     * @param {Object} [options] options sent from the upper functions
-     * @param {Event} [options.e] event if the process is generated by an event
+     * Returns svg representation of an instance
+     * @return {Array} an array of strings with the specific svg representation
+     * of the instance
      */
-    onSelect: function() {
-      // implemented by sub-classes, as needed.
-    }
+    _toSVG: function() {
+      var widthBy2 = this.width / 2,
+          heightBy2 = this.height / 2,
+          points = [
+            -widthBy2 + ' ' + heightBy2,
+            '0 ' + -heightBy2,
+            widthBy2 + ' ' + heightBy2
+          ].join(',');
+      return [
+        '<polygon ', 'COMMON_PARTS',
+        'points="', points,
+        '" />'
+      ];
+    },
+    /* _TO_SVG_END_ */
   });
-})();
-
-
-fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
 
   /**
-   * Animation duration (in ms) for fx* methods
-   * @type Number
-   * @default
+   * Returns {@link fabric.Triangle} instance from an object representation
+   * @static
+   * @memberOf fabric.Triangle
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
    */
-  FX_DURATION: 500,
+  fabric.Triangle.fromObject = function(object, callback) {
+    return fabric.Object._fromObject('Triangle', object, callback);
+  };
 
-  /**
-   * Centers object horizontally with animation.
-   * @param {fabric.Object} object Object to center
-   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
-   * @param {Function} [callbacks.onComplete] Invoked on completion
-   * @param {Function} [callbacks.onChange] Invoked on every step of animation
-   * @return {fabric.Canvas} thisArg
-   * @chainable
-   */
-  fxCenterObjectH: function (object, callbacks) {
-    callbacks = callbacks || { };
+})(typeof exports !== 'undefined' ? exports : this);
 
-    var empty = function() { },
-        onComplete = callbacks.onComplete || empty,
-        onChange = callbacks.onChange || empty,
-        _this = this;
 
-    fabric.util.animate({
-      startValue: object.left,
-      endValue: this.getCenter().left,
-      duration: this.FX_DURATION,
-      onChange: function(value) {
-        object.set('left', value);
-        _this.requestRenderAll();
-        onChange();
-      },
-      onComplete: function() {
-        object.setCoords();
-        onComplete();
-      }
-    });
+(function(global) {
 
-    return this;
-  },
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = { }),
+      piBy2   = Math.PI * 2;
+
+  if (fabric.Ellipse) {
+    fabric.warn('fabric.Ellipse is already defined.');
+    return;
+  }
 
   /**
-   * Centers object vertically with animation.
-   * @param {fabric.Object} object Object to center
-   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
-   * @param {Function} [callbacks.onComplete] Invoked on completion
-   * @param {Function} [callbacks.onChange] Invoked on every step of animation
-   * @return {fabric.Canvas} thisArg
-   * @chainable
+   * Ellipse class
+   * @class fabric.Ellipse
+   * @extends fabric.Object
+   * @return {fabric.Ellipse} thisArg
+   * @see {@link fabric.Ellipse#initialize} for constructor definition
    */
-  fxCenterObjectV: function (object, callbacks) {
-    callbacks = callbacks || { };
+  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {
 
-    var empty = function() { },
-        onComplete = callbacks.onComplete || empty,
-        onChange = callbacks.onChange || empty,
-        _this = this;
+    /**
+     * Type of an object
+     * @type String
+     * @default
+     */
+    type: 'ellipse',
 
-    fabric.util.animate({
-      startValue: object.top,
-      endValue: this.getCenter().top,
-      duration: this.FX_DURATION,
-      onChange: function(value) {
-        object.set('top', value);
-        _this.requestRenderAll();
-        onChange();
-      },
-      onComplete: function() {
-        object.setCoords();
-        onComplete();
-      }
-    });
+    /**
+     * Horizontal radius
+     * @type Number
+     * @default
+     */
+    rx:   0,
+
+    /**
+     * Vertical radius
+     * @type Number
+     * @default
+     */
+    ry:   0,
 
-    return this;
-  },
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),
 
-  /**
-   * Same as `fabric.Canvas#remove` but animated
-   * @param {fabric.Object} object Object to remove
-   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
-   * @param {Function} [callbacks.onComplete] Invoked on completion
-   * @param {Function} [callbacks.onChange] Invoked on every step of animation
-   * @return {fabric.Canvas} thisArg
-   * @chainable
-   */
-  fxRemove: function (object, callbacks) {
-    callbacks = callbacks || { };
+    /**
+     * Constructor
+     * @param {Object} [options] Options object
+     * @return {fabric.Ellipse} thisArg
+     */
+    initialize: function(options) {
+      this.callSuper('initialize', options);
+      this.set('rx', options && options.rx || 0);
+      this.set('ry', options && options.ry || 0);
+    },
 
-    var empty = function() { },
-        onComplete = callbacks.onComplete || empty,
-        onChange = callbacks.onChange || empty,
-        _this = this;
+    /**
+     * @private
+     * @param {String} key
+     * @param {*} value
+     * @return {fabric.Ellipse} thisArg
+     */
+    _set: function(key, value) {
+      this.callSuper('_set', key, value);
+      switch (key) {
 
-    fabric.util.animate({
-      startValue: object.opacity,
-      endValue: 0,
-      duration: this.FX_DURATION,
-      onChange: function(value) {
-        object.set('opacity', value);
-        _this.requestRenderAll();
-        onChange();
-      },
-      onComplete: function () {
-        _this.remove(object);
-        onComplete();
-      }
-    });
+        case 'rx':
+          this.rx = value;
+          this.set('width', value * 2);
+          break;
 
-    return this;
-  }
-});
+        case 'ry':
+          this.ry = value;
+          this.set('height', value * 2);
+          break;
 
-fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
-  /**
-   * Animates object's properties
-   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
-   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
-   * @return {fabric.Object} thisArg
-   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
-   * @chainable
-   *
-   * As object — multiple properties
-   *
-   * object.animate({ left: ..., top: ... });
-   * object.animate({ left: ..., top: ... }, { duration: ... });
-   *
-   * As string — one property
-   *
-   * object.animate('left', ...);
-   * object.animate('left', { duration: ... });
-   *
-   */
-  animate: function() {
-    if (arguments[0] && typeof arguments[0] === 'object') {
-      var propsToAnimate = [], prop, skipCallbacks;
-      for (prop in arguments[0]) {
-        propsToAnimate.push(prop);
-      }
-      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
-        prop = propsToAnimate[i];
-        skipCallbacks = i !== len - 1;
-        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
       }
-    }
-    else {
-      this._animate.apply(this, arguments);
-    }
-    return this;
-  },
+      return this;
+    },
 
-  /**
-   * @private
-   * @param {String} property Property to animate
-   * @param {String} to Value to animate to
-   * @param {Object} [options] Options object
-   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
-   */
-  _animate: function(property, to, options, skipCallbacks) {
-    var _this = this, propPair;
+    /**
+     * Returns horizontal radius of an object (according to how an object is scaled)
+     * @return {Number}
+     */
+    getRx: function() {
+      return this.get('rx') * this.get('scaleX');
+    },
 
-    to = to.toString();
+    /**
+     * Returns Vertical radius of an object (according to how an object is scaled)
+     * @return {Number}
+     */
+    getRy: function() {
+      return this.get('ry') * this.get('scaleY');
+    },
 
-    if (!options) {
-      options = { };
-    }
-    else {
-      options = fabric.util.object.clone(options);
-    }
+    /**
+     * Returns object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
+     */
+    toObject: function(propertiesToInclude) {
+      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
+    },
 
-    if (~property.indexOf('.')) {
-      propPair = property.split('.');
-    }
+    /* _TO_SVG_START_ */
+    /**
+     * Returns svg representation of an instance
+     * @return {Array} an array of strings with the specific svg representation
+     * of the instance
+     */
+    _toSVG: function() {
+      return [
+        '<ellipse ', 'COMMON_PARTS',
+        'cx="0" cy="0" ',
+        'rx="', this.rx,
+        '" ry="', this.ry,
+        '" />\n'
+      ];
+    },
+    /* _TO_SVG_END_ */
 
-    var propIsColor =
-      _this.colorProperties.indexOf(property) > -1 ||
-      (propPair && _this.colorProperties.indexOf(propPair[1]) > -1);
+    /**
+     * @private
+     * @param {CanvasRenderingContext2D} ctx context to render on
+     */
+    _render: function(ctx) {
+      ctx.beginPath();
+      ctx.save();
+      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
+      ctx.arc(
+        0,
+        0,
+        this.rx,
+        0,
+        piBy2,
+        false);
+      ctx.restore();
+      this._renderPaintInOrder(ctx);
+    },
+  });
 
-    var currentValue = propPair
-      ? this.get(propPair[0])[propPair[1]]
-      : this.get(property);
+  /* _FROM_SVG_START_ */
+  /**
+   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
+   * @static
+   * @memberOf fabric.Ellipse
+   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
+   */
+  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
 
-    if (!('from' in options)) {
-      options.from = currentValue;
-    }
+  /**
+   * Returns {@link fabric.Ellipse} instance from an SVG element
+   * @static
+   * @memberOf fabric.Ellipse
+   * @param {SVGElement} element Element to parse
+   * @param {Function} [callback] Options callback invoked after parsing is finished
+   * @return {fabric.Ellipse}
+   */
+  fabric.Ellipse.fromElement = function(element, callback) {
 
-    if (!propIsColor) {
-      if (~to.indexOf('=')) {
-        to = currentValue + parseFloat(to.replace('=', ''));
-      }
-      else {
-        to = parseFloat(to);
-      }
-    }
+    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
 
-    var _options = {
-      startValue: options.from,
-      endValue: to,
-      byValue: options.by,
-      easing: options.easing,
-      duration: options.duration,
-      abort: options.abort && function(value, valueProgress, timeProgress) {
-        return options.abort.call(_this, value, valueProgress, timeProgress);
-      },
-      onChange: function (value, valueProgress, timeProgress) {
-        if (propPair) {
-          _this[propPair[0]][propPair[1]] = value;
-        }
-        else {
-          _this.set(property, value);
-        }
-        if (skipCallbacks) {
-          return;
-        }
-        options.onChange && options.onChange(value, valueProgress, timeProgress);
-      },
-      onComplete: function (value, valueProgress, timeProgress) {
-        if (skipCallbacks) {
-          return;
-        }
+    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
+    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
+    callback(new fabric.Ellipse(parsedAttributes));
+  };
+  /* _FROM_SVG_END_ */
 
-        _this.setCoords();
-        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
-      }
-    };
+  /**
+   * Returns {@link fabric.Ellipse} instance from an object representation
+   * @static
+   * @memberOf fabric.Ellipse
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   * @return {void}
+   */
+  fabric.Ellipse.fromObject = function(object, callback) {
+    fabric.Object._fromObject('Ellipse', object, callback);
+  };
 
-    if (propIsColor) {
-      return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
-    }
-    else {
-      return fabric.util.animate(_options);
-    }
-  }
-});
+})(typeof exports !== 'undefined' ? exports : this);
 
 
 (function(global) {
@@ -18044,230 +21548,121 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
   'use strict';
 
   var fabric = global.fabric || (global.fabric = { }),
-      extend = fabric.util.object.extend,
-      clone = fabric.util.object.clone,
-      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 };
+      extend = fabric.util.object.extend;
 
-  if (fabric.Line) {
-    fabric.warn('fabric.Line is already defined');
+  if (fabric.Rect) {
+    fabric.warn('fabric.Rect is already defined');
     return;
   }
 
   /**
-   * Line class
-   * @class fabric.Line
+   * Rectangle class
+   * @class fabric.Rect
    * @extends fabric.Object
-   * @see {@link fabric.Line#initialize} for constructor definition
+   * @return {fabric.Rect} thisArg
+   * @see {@link fabric.Rect#initialize} for constructor definition
    */
-  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {
-
-    /**
-     * Type of an object
-     * @type String
-     * @default
-     */
-    type: 'line',
+  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {
 
     /**
-     * x value or first line edge
-     * @type Number
-     * @default
+     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
+     * as well as for history (undo/redo) purposes
+     * @type Array
      */
-    x1: 0,
+    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),
 
     /**
-     * y value or first line edge
-     * @type Number
+     * Type of an object
+     * @type String
      * @default
      */
-    y1: 0,
+    type: 'rect',
 
     /**
-     * x value or second line edge
+     * Horizontal border radius
      * @type Number
      * @default
      */
-    x2: 0,
+    rx:   0,
 
     /**
-     * y value or second line edge
+     * Vertical border radius
      * @type Number
      * @default
      */
-    y2: 0,
+    ry:   0,
 
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),
 
     /**
      * Constructor
-     * @param {Array} [points] Array of points
      * @param {Object} [options] Options object
-     * @return {fabric.Line} thisArg
+     * @return {Object} thisArg
      */
-    initialize: function(points, options) {
-      if (!points) {
-        points = [0, 0, 0, 0];
-      }
-
+    initialize: function(options) {
       this.callSuper('initialize', options);
-
-      this.set('x1', points[0]);
-      this.set('y1', points[1]);
-      this.set('x2', points[2]);
-      this.set('y2', points[3]);
-
-      this._setWidthHeight(options);
-    },
-
-    /**
-     * @private
-     * @param {Object} [options] Options
-     */
-    _setWidthHeight: function(options) {
-      options || (options = { });
-
-      this.width = Math.abs(this.x2 - this.x1);
-      this.height = Math.abs(this.y2 - this.y1);
-
-      this.left = 'left' in options
-        ? options.left
-        : this._getLeftToOriginX();
-
-      this.top = 'top' in options
-        ? options.top
-        : this._getTopToOriginY();
-    },
-
-    /**
-     * @private
-     * @param {String} key
-     * @param {*} value
-     */
-    _set: function(key, value) {
-      this.callSuper('_set', key, value);
-      if (typeof coordProps[key] !== 'undefined') {
-        this._setWidthHeight();
-      }
-      return this;
+      this._initRxRy();
     },
 
     /**
+     * Initializes rx/ry attributes
      * @private
-     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
      */
-    _getLeftToOriginX: makeEdgeToOriginGetter(
-      { // property names
-        origin: 'originX',
-        axis1: 'x1',
-        axis2: 'x2',
-        dimension: 'width'
-      },
-      { // possible values of origin
-        nearest: 'left',
-        center: 'center',
-        farthest: 'right'
+    _initRxRy: function() {
+      if (this.rx && !this.ry) {
+        this.ry = this.rx;
       }
-    ),
-
-    /**
-     * @private
-     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
-     */
-    _getTopToOriginY: makeEdgeToOriginGetter(
-      { // property names
-        origin: 'originY',
-        axis1: 'y1',
-        axis2: 'y2',
-        dimension: 'height'
-      },
-      { // possible values of origin
-        nearest: 'top',
-        center: 'center',
-        farthest: 'bottom'
+      else if (this.ry && !this.rx) {
+        this.rx = this.ry;
       }
-    ),
+    },
 
     /**
      * @private
      * @param {CanvasRenderingContext2D} ctx Context to render on
      */
     _render: function(ctx) {
+
+      // 1x1 case (used in spray brush) optimization was removed because
+      // with caching and higher zoom level this makes more damage than help
+
+      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
+          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
+          w = this.width,
+          h = this.height,
+          x = -this.width / 2,
+          y = -this.height / 2,
+          isRounded = rx !== 0 || ry !== 0,
+          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
+          k = 1 - 0.5522847498;
       ctx.beginPath();
 
+      ctx.moveTo(x + rx, y);
+
+      ctx.lineTo(x + w - rx, y);
+      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
 
-      var p = this.calcLinePoints();
-      ctx.moveTo(p.x1, p.y1);
-      ctx.lineTo(p.x2, p.y2);
+      ctx.lineTo(x + w, y + h - ry);
+      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
 
-      ctx.lineWidth = this.strokeWidth;
+      ctx.lineTo(x + rx, y + h);
+      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
 
-      // TODO: test this
-      // make sure setting "fill" changes color of a line
-      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
-      var origStrokeStyle = ctx.strokeStyle;
-      ctx.strokeStyle = this.stroke || ctx.fillStyle;
-      this.stroke && this._renderStroke(ctx);
-      ctx.strokeStyle = origStrokeStyle;
-    },
+      ctx.lineTo(x, y + ry);
+      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
 
-    /**
-     * This function is an helper for svg import. it returns the center of the object in the svg
-     * untransformed coordinates
-     * @private
-     * @return {Object} center point from element coordinates
-     */
-    _findCenterFromElement: function() {
-      return {
-        x: (this.x1 + this.x2) / 2,
-        y: (this.y1 + this.y2) / 2,
-      };
+      ctx.closePath();
+
+      this._renderPaintInOrder(ctx);
     },
 
     /**
      * Returns object representation of an instance
-     * @method toObject
      * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
      * @return {Object} object representation of an instance
      */
     toObject: function(propertiesToInclude) {
-      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
-    },
-
-    /*
-     * Calculate object dimensions from its properties
-     * @private
-     */
-    _getNonTransformedDimensions: function() {
-      var dim = this.callSuper('_getNonTransformedDimensions');
-      if (this.strokeLineCap === 'butt') {
-        if (this.width === 0) {
-          dim.y -= this.strokeWidth;
-        }
-        if (this.height === 0) {
-          dim.x -= this.strokeWidth;
-        }
-      }
-      return dim;
-    },
-
-    /**
-     * Recalculates line points given width and height
-     * @private
-     */
-    calcLinePoints: function() {
-      var xMult = this.x1 <= this.x2 ? -1 : 1,
-          yMult = this.y1 <= this.y2 ? -1 : 1,
-          x1 = (xMult * this.width * 0.5),
-          y1 = (yMult * this.height * 0.5),
-          x2 = (xMult * this.width * -0.5),
-          y2 = (yMult * this.height * -0.5);
-
-      return {
-        x1: x1,
-        x2: x2,
-        y1: y1,
-        y2: y2
-      };
+      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
     },
 
     /* _TO_SVG_START_ */
@@ -18277,13 +21672,12 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
      * of the instance
      */
     _toSVG: function() {
-      var p = this.calcLinePoints();
+      var x = -this.width / 2, y = -this.height / 2;
       return [
-        '<line ', 'COMMON_PARTS',
-        'x1="', p.x1,
-        '" y1="', p.y1,
-        '" x2="', p.x2,
-        '" y2="', p.y2,
+        '<rect ', 'COMMON_PARTS',
+        'x="', x, '" y="', y,
+        '" rx="', this.rx, '" ry="', this.ry,
+        '" width="', this.width, '" height="', this.height,
         '" />\n'
       ];
     },
@@ -18292,76 +21686,49 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
 
   /* _FROM_SVG_START_ */
   /**
-   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
+   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
    * @static
-   * @memberOf fabric.Line
-   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
+   * @memberOf fabric.Rect
+   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
    */
-  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
+  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
 
   /**
-   * Returns fabric.Line instance from an SVG element
+   * Returns {@link fabric.Rect} instance from an SVG element
    * @static
-   * @memberOf fabric.Line
+   * @memberOf fabric.Rect
    * @param {SVGElement} element Element to parse
+   * @param {Function} callback callback function invoked after parsing
    * @param {Object} [options] Options object
-   * @param {Function} [callback] callback function invoked after parsing
    */
-  fabric.Line.fromElement = function(element, callback, options) {
+  fabric.Rect.fromElement = function(element, callback, options) {
+    if (!element) {
+      return callback(null);
+    }
     options = options || { };
-    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
-        points = [
-          parsedAttributes.x1 || 0,
-          parsedAttributes.y1 || 0,
-          parsedAttributes.x2 || 0,
-          parsedAttributes.y2 || 0
-        ];
-    callback(new fabric.Line(points, extend(parsedAttributes, options)));
+
+    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
+    parsedAttributes.left = parsedAttributes.left || 0;
+    parsedAttributes.top  = parsedAttributes.top  || 0;
+    parsedAttributes.height  = parsedAttributes.height || 0;
+    parsedAttributes.width  = parsedAttributes.width || 0;
+    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
+    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
+    callback(rect);
   };
   /* _FROM_SVG_END_ */
 
   /**
-   * Returns fabric.Line instance from an object representation
+   * Returns {@link fabric.Rect} instance from an object representation
    * @static
-   * @memberOf fabric.Line
+   * @memberOf fabric.Rect
    * @param {Object} object Object to create an instance from
-   * @param {function} [callback] invoked with new instance as first argument
+   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
    */
-  fabric.Line.fromObject = function(object, callback) {
-    function _callback(instance) {
-      delete instance.points;
-      callback && callback(instance);
-    };
-    var options = clone(object, true);
-    options.points = [object.x1, object.y1, object.x2, object.y2];
-    fabric.Object._fromObject('Line', options, _callback, 'points');
+  fabric.Rect.fromObject = function(object, callback) {
+    return fabric.Object._fromObject('Rect', object, callback);
   };
 
-  /**
-   * Produces a function that calculates distance from canvas edge to Line origin.
-   */
-  function makeEdgeToOriginGetter(propertyNames, originValues) {
-    var origin = propertyNames.origin,
-        axis1 = propertyNames.axis1,
-        axis2 = propertyNames.axis2,
-        dimension = propertyNames.dimension,
-        nearest = originValues.nearest,
-        center = originValues.center,
-        farthest = originValues.farthest;
-
-    return function() {
-      switch (this.get(origin)) {
-        case nearest:
-          return Math.min(this.get(axis1), this.get(axis2));
-        case center:
-          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
-        case farthest:
-          return Math.max(this.get(axis1), this.get(axis2));
-      }
-    };
-
-  }
-
 })(typeof exports !== 'undefined' ? exports : this);
 
 
@@ -18370,205 +21737,242 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
   'use strict';
 
   var fabric = global.fabric || (global.fabric = { }),
-      pi = Math.PI;
+      extend = fabric.util.object.extend,
+      min = fabric.util.array.min,
+      max = fabric.util.array.max,
+      toFixed = fabric.util.toFixed;
 
-  if (fabric.Circle) {
-    fabric.warn('fabric.Circle is already defined.');
+  if (fabric.Polyline) {
+    fabric.warn('fabric.Polyline is already defined');
     return;
   }
 
   /**
-   * Circle class
-   * @class fabric.Circle
+   * Polyline class
+   * @class fabric.Polyline
    * @extends fabric.Object
-   * @see {@link fabric.Circle#initialize} for constructor definition
+   * @see {@link fabric.Polyline#initialize} for constructor definition
    */
-  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {
+  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {
 
     /**
      * Type of an object
      * @type String
      * @default
      */
-    type: 'circle',
+    type: 'polyline',
 
     /**
-     * Radius of this circle
-     * @type Number
+     * Points array
+     * @type Array
      * @default
      */
-    radius: 0,
+    points: null,
 
-    /**
-     * Start angle of the circle, moving clockwise
-     * deprecated type, this should be in degree, this was an oversight.
-     * probably will change to degrees in next major version
-     * @type Number
-     * @default 0
-     */
-    startAngle: 0,
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),
 
     /**
-     * End angle of the circle
-     * deprecated type, this should be in degree, this was an oversight.
-     * probably will change to degrees in next major version
-     * @type Number
-     * @default 2Pi
+     * Constructor
+     * @param {Array} points Array of points (where each point is an object with x and y)
+     * @param {Object} [options] Options object
+     * @return {fabric.Polyline} thisArg
+     * @example
+     * var poly = new fabric.Polyline([
+     *     { x: 10, y: 10 },
+     *     { x: 50, y: 30 },
+     *     { x: 40, y: 70 },
+     *     { x: 60, y: 50 },
+     *     { x: 100, y: 150 },
+     *     { x: 40, y: 100 }
+     *   ], {
+     *   stroke: 'red',
+     *   left: 100,
+     *   top: 100
+     * });
      */
-    endAngle: pi * 2,
+    initialize: function(points, options) {
+      options = options || {};
+      this.points = points || [];
+      this.callSuper('initialize', options);
+      this._setPositionDimensions(options);
+    },
 
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),
+    _setPositionDimensions: function(options) {
+      var calcDim = this._calcDimensions(options), correctLeftTop;
+      this.width = calcDim.width;
+      this.height = calcDim.height;
+      if (!options.fromSVG) {
+        correctLeftTop = this.translateToGivenOrigin(
+          { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
+          'left',
+          'top',
+          this.originX,
+          this.originY
+        );
+      }
+      if (typeof options.left === 'undefined') {
+        this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
+      }
+      if (typeof options.top === 'undefined') {
+        this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
+      }
+      this.pathOffset = {
+        x: calcDim.left + this.width / 2,
+        y: calcDim.top + this.height / 2
+      };
+    },
 
     /**
+     * Calculate the polygon min and max point from points array,
+     * returning an object with left, top, width, height to measure the
+     * polygon size
+     * @return {Object} object.left X coordinate of the polygon leftmost point
+     * @return {Object} object.top Y coordinate of the polygon topmost point
+     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
+     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
      * @private
-     * @param {String} key
-     * @param {*} value
-     * @return {fabric.Circle} thisArg
      */
-    _set: function(key, value) {
-      this.callSuper('_set', key, value);
+    _calcDimensions: function() {
 
-      if (key === 'radius') {
-        this.setRadius(value);
-      }
+      var points = this.points,
+          minX = min(points, 'x') || 0,
+          minY = min(points, 'y') || 0,
+          maxX = max(points, 'x') || 0,
+          maxY = max(points, 'y') || 0,
+          width = (maxX - minX),
+          height = (maxY - minY);
 
-      return this;
+      return {
+        left: minX,
+        top: minY,
+        width: width,
+        height: height
+      };
     },
 
     /**
      * Returns object representation of an instance
      * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
+     * @return {Object} Object representation of an instance
      */
     toObject: function(propertiesToInclude) {
-      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
+      return extend(this.callSuper('toObject', propertiesToInclude), {
+        points: this.points.concat()
+      });
     },
 
     /* _TO_SVG_START_ */
-
     /**
      * Returns svg representation of an instance
      * @return {Array} an array of strings with the specific svg representation
      * of the instance
      */
     _toSVG: function() {
-      var svgString, x = 0, y = 0,
-          angle = (this.endAngle - this.startAngle) % ( 2 * pi);
+      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
+          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
 
-      if (angle === 0) {
-        svgString = [
-          '<circle ', 'COMMON_PARTS',
-          'cx="' + x + '" cy="' + y + '" ',
-          'r="', this.radius,
-          '" />\n'
-        ];
-      }
-      else {
-        var startX = fabric.util.cos(this.startAngle) * this.radius,
-            startY = fabric.util.sin(this.startAngle) * this.radius,
-            endX = fabric.util.cos(this.endAngle) * this.radius,
-            endY = fabric.util.sin(this.endAngle) * this.radius,
-            largeFlag = angle > pi ? '1' : '0';
-        svgString = [
-          '<path d="M ' + startX + ' ' + startY,
-          ' A ' + this.radius + ' ' + this.radius,
-          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
-          '" ', 'COMMON_PARTS', ' />\n'
-        ];
+      for (var i = 0, len = this.points.length; i < len; i++) {
+        points.push(
+          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
+          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
+        );
       }
-      return svgString;
+      return [
+        '<' + this.type + ' ', 'COMMON_PARTS',
+        'points="', points.join(''),
+        '" />\n'
+      ];
     },
     /* _TO_SVG_END_ */
 
+
     /**
      * @private
-     * @param {CanvasRenderingContext2D} ctx context to render on
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    _render: function(ctx) {
-      ctx.beginPath();
-      ctx.arc(
-        0,
-        0,
-        this.radius,
-        this.startAngle,
-        this.endAngle, false);
-      this._renderPaintInOrder(ctx);
-    },
+    commonRender: function(ctx) {
+      var point, len = this.points.length,
+          x = this.pathOffset.x,
+          y = this.pathOffset.y;
 
-    /**
-     * Returns horizontal radius of an object (according to how an object is scaled)
-     * @return {Number}
-     */
-    getRadiusX: function() {
-      return this.get('radius') * this.get('scaleX');
+      if (!len || isNaN(this.points[len - 1].y)) {
+        // do not draw if no points or odd points
+        // NaN comes from parseFloat of a empty string in parser
+        return false;
+      }
+      ctx.beginPath();
+      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
+      for (var i = 0; i < len; i++) {
+        point = this.points[i];
+        ctx.lineTo(point.x - x, point.y - y);
+      }
+      return true;
     },
 
     /**
-     * Returns vertical radius of an object (according to how an object is scaled)
-     * @return {Number}
+     * @private
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    getRadiusY: function() {
-      return this.get('radius') * this.get('scaleY');
+    _render: function(ctx) {
+      if (!this.commonRender(ctx)) {
+        return;
+      }
+      this._renderPaintInOrder(ctx);
     },
 
     /**
-     * Sets radius of an object (and updates width accordingly)
-     * @return {fabric.Circle} thisArg
+     * Returns complexity of an instance
+     * @return {Number} complexity of this instance
      */
-    setRadius: function(value) {
-      this.radius = value;
-      return this.set('width', value * 2).set('height', value * 2);
-    },
+    complexity: function() {
+      return this.get('points').length;
+    }
   });
 
   /* _FROM_SVG_START_ */
   /**
-   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
+   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
    * @static
-   * @memberOf fabric.Circle
-   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
+   * @memberOf fabric.Polyline
+   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
    */
-  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
+  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
 
   /**
-   * Returns {@link fabric.Circle} instance from an SVG element
+   * Returns fabric.Polyline instance from an SVG element
    * @static
-   * @memberOf fabric.Circle
-   * @param {SVGElement} element Element to parse
-   * @param {Function} [callback] Options callback invoked after parsing is finished
+   * @memberOf fabric.Polyline
+   * @param {SVGElement} element Element to parser
+   * @param {Function} callback callback function invoked after parsing
    * @param {Object} [options] Options object
-   * @throws {Error} If value of `r` attribute is missing or invalid
    */
-  fabric.Circle.fromElement = function(element, callback) {
-    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
-
-    if (!isValidRadius(parsedAttributes)) {
-      throw new Error('value of `r` attribute is required and can not be negative');
-    }
+  fabric.Polyline.fromElementGenerator = function(_class) {
+    return function(element, callback, options) {
+      if (!element) {
+        return callback(null);
+      }
+      options || (options = { });
 
-    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
-    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
-    callback(new fabric.Circle(parsedAttributes));
+      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
+          parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
+      parsedAttributes.fromSVG = true;
+      callback(new fabric[_class](points, extend(parsedAttributes, options)));
+    };
   };
 
-  /**
-   * @private
-   */
-  function isValidRadius(attributes) {
-    return (('radius' in attributes) && (attributes.radius >= 0));
-  }
+  fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');
+
   /* _FROM_SVG_END_ */
 
   /**
-   * Returns {@link fabric.Circle} instance from an object representation
+   * Returns fabric.Polyline instance from an object representation
    * @static
-   * @memberOf fabric.Circle
+   * @memberOf fabric.Polyline
    * @param {Object} object Object to create an instance from
-   * @param {function} [callback] invoked with new instance as first argument
-   * @return {void}
+   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
    */
-  fabric.Circle.fromObject = function(object, callback) {
-    fabric.Object._fromObject('Circle', object, callback);
+  fabric.Polyline.fromObject = function(object, callback) {
+    return fabric.Object._fromObject('Polyline', object, callback, 'points');
   };
 
 })(typeof exports !== 'undefined' ? exports : this);
@@ -18580,90 +21984,70 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
 
   var fabric = global.fabric || (global.fabric = { });
 
-  if (fabric.Triangle) {
-    fabric.warn('fabric.Triangle is already defined');
+  if (fabric.Polygon) {
+    fabric.warn('fabric.Polygon is already defined');
     return;
   }
 
   /**
-   * Triangle class
-   * @class fabric.Triangle
-   * @extends fabric.Object
-   * @return {fabric.Triangle} thisArg
-   * @see {@link fabric.Triangle#initialize} for constructor definition
+   * Polygon class
+   * @class fabric.Polygon
+   * @extends fabric.Polyline
+   * @see {@link fabric.Polygon#initialize} for constructor definition
    */
-  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {
+  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {
 
     /**
      * Type of an object
      * @type String
      * @default
      */
-    type: 'triangle',
-
-    /**
-     * Width is set to 100 to compensate the old initialize code that was setting it to 100
-     * @type Number
-     * @default
-     */
-    width: 100,
-
-    /**
-     * Height is set to 100 to compensate the old initialize code that was setting it to 100
-     * @type Number
-     * @default
-     */
-    height: 100,
+    type: 'polygon',
 
     /**
      * @private
      * @param {CanvasRenderingContext2D} ctx Context to render on
      */
     _render: function(ctx) {
-      var widthBy2 = this.width / 2,
-          heightBy2 = this.height / 2;
-
-      ctx.beginPath();
-      ctx.moveTo(-widthBy2, heightBy2);
-      ctx.lineTo(0, -heightBy2);
-      ctx.lineTo(widthBy2, heightBy2);
+      if (!this.commonRender(ctx)) {
+        return;
+      }
       ctx.closePath();
-
       this._renderPaintInOrder(ctx);
     },
 
-    /* _TO_SVG_START_ */
-    /**
-     * Returns svg representation of an instance
-     * @return {Array} an array of strings with the specific svg representation
-     * of the instance
-     */
-    _toSVG: function() {
-      var widthBy2 = this.width / 2,
-          heightBy2 = this.height / 2,
-          points = [
-            -widthBy2 + ' ' + heightBy2,
-            '0 ' + -heightBy2,
-            widthBy2 + ' ' + heightBy2
-          ].join(',');
-      return [
-        '<polygon ', 'COMMON_PARTS',
-        'points="', points,
-        '" />'
-      ];
-    },
-    /* _TO_SVG_END_ */
   });
 
+  /* _FROM_SVG_START_ */
   /**
-   * Returns {@link fabric.Triangle} instance from an object representation
+   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
    * @static
-   * @memberOf fabric.Triangle
+   * @memberOf fabric.Polygon
+   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
+   */
+  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
+
+  /**
+   * Returns {@link fabric.Polygon} instance from an SVG element
+   * @static
+   * @memberOf fabric.Polygon
+   * @param {SVGElement} element Element to parse
+   * @param {Function} callback callback function invoked after parsing
+   * @param {Object} [options] Options object
+   */
+  fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
+  /* _FROM_SVG_END_ */
+
+  /**
+   * Returns fabric.Polygon instance from an object representation
+   * @static
+   * @memberOf fabric.Polygon
    * @param {Object} object Object to create an instance from
-   * @param {function} [callback] invoked with new instance as first argument
+   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
+   * @return {void}
    */
-  fabric.Triangle.fromObject = function(object, callback) {
-    return fabric.Object._fromObject('Triangle', object, callback);
+  fabric.Polygon.fromObject = function(object, callback) {
+    fabric.Object._fromObject('Polygon', object, callback, 'points');
   };
 
 })(typeof exports !== 'undefined' ? exports : this);
@@ -18674,94 +22058,164 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
   'use strict';
 
   var fabric = global.fabric || (global.fabric = { }),
-      piBy2   = Math.PI * 2;
+      min = fabric.util.array.min,
+      max = fabric.util.array.max,
+      extend = fabric.util.object.extend,
+      clone = fabric.util.object.clone,
+      _toString = Object.prototype.toString,
+      toFixed = fabric.util.toFixed;
 
-  if (fabric.Ellipse) {
-    fabric.warn('fabric.Ellipse is already defined.');
+  if (fabric.Path) {
+    fabric.warn('fabric.Path is already defined');
     return;
   }
 
   /**
-   * Ellipse class
-   * @class fabric.Ellipse
+   * Path class
+   * @class fabric.Path
    * @extends fabric.Object
-   * @return {fabric.Ellipse} thisArg
-   * @see {@link fabric.Ellipse#initialize} for constructor definition
+   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
+   * @see {@link fabric.Path#initialize} for constructor definition
    */
-  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {
+  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {
 
     /**
      * Type of an object
      * @type String
      * @default
      */
-    type: 'ellipse',
+    type: 'path',
 
     /**
-     * Horizontal radius
-     * @type Number
+     * Array of path points
+     * @type Array
      * @default
      */
-    rx:   0,
+    path: null,
 
-    /**
-     * Vertical radius
-     * @type Number
-     * @default
-     */
-    ry:   0,
+    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),
 
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),
+    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),
 
     /**
      * Constructor
+     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
      * @param {Object} [options] Options object
-     * @return {fabric.Ellipse} thisArg
+     * @return {fabric.Path} thisArg
      */
-    initialize: function(options) {
+    initialize: function (path, options) {
+      options = clone(options || {});
+      delete options.path;
       this.callSuper('initialize', options);
-      this.set('rx', options && options.rx || 0);
-      this.set('ry', options && options.ry || 0);
+      this._setPath(path || [], options);
+    },
+
+    /**
+    * @private
+    * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
+    * @param {Object} [options] Options object
+    */
+    _setPath: function (path, options) {
+      var fromArray = _toString.call(path) === '[object Array]';
+
+      this.path = fabric.util.makePathSimpler(
+        fromArray ? path : fabric.util.parsePath(path)
+      );
+
+      fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});
     },
 
-    /**
-     * @private
-     * @param {String} key
-     * @param {*} value
-     * @return {fabric.Ellipse} thisArg
-     */
-    _set: function(key, value) {
-      this.callSuper('_set', key, value);
-      switch (key) {
+    /**
+     * @private
+     * @param {CanvasRenderingContext2D} ctx context to render path on
+     */
+    _renderPathCommands: function(ctx) {
+      var current, // current instruction
+          subpathStartX = 0,
+          subpathStartY = 0,
+          x = 0, // current x
+          y = 0, // current y
+          controlX = 0, // current control point x
+          controlY = 0, // current control point y
+          l = -this.pathOffset.x,
+          t = -this.pathOffset.y;
+
+      ctx.beginPath();
+
+      for (var i = 0, len = this.path.length; i < len; ++i) {
+
+        current = this.path[i];
+
+        switch (current[0]) { // first letter
+
+          case 'L': // lineto, absolute
+            x = current[1];
+            y = current[2];
+            ctx.lineTo(x + l, y + t);
+            break;
 
-        case 'rx':
-          this.rx = value;
-          this.set('width', value * 2);
-          break;
+          case 'M': // moveTo, absolute
+            x = current[1];
+            y = current[2];
+            subpathStartX = x;
+            subpathStartY = y;
+            ctx.moveTo(x + l, y + t);
+            break;
 
-        case 'ry':
-          this.ry = value;
-          this.set('height', value * 2);
-          break;
+          case 'C': // bezierCurveTo, absolute
+            x = current[5];
+            y = current[6];
+            controlX = current[3];
+            controlY = current[4];
+            ctx.bezierCurveTo(
+              current[1] + l,
+              current[2] + t,
+              controlX + l,
+              controlY + t,
+              x + l,
+              y + t
+            );
+            break;
+
+          case 'Q': // quadraticCurveTo, absolute
+            ctx.quadraticCurveTo(
+              current[1] + l,
+              current[2] + t,
+              current[3] + l,
+              current[4] + t
+            );
+            x = current[3];
+            y = current[4];
+            controlX = current[1];
+            controlY = current[2];
+            break;
 
+          case 'z':
+          case 'Z':
+            x = subpathStartX;
+            y = subpathStartY;
+            ctx.closePath();
+            break;
+        }
       }
-      return this;
     },
 
     /**
-     * Returns horizontal radius of an object (according to how an object is scaled)
-     * @return {Number}
+     * @private
+     * @param {CanvasRenderingContext2D} ctx context to render path on
      */
-    getRx: function() {
-      return this.get('rx') * this.get('scaleX');
+    _render: function(ctx) {
+      this._renderPathCommands(ctx);
+      this._renderPaintInOrder(ctx);
     },
 
     /**
-     * Returns Vertical radius of an object (according to how an object is scaled)
-     * @return {Number}
+     * Returns string representation of an instance
+     * @return {String} string representation of an instance
      */
-    getRy: function() {
-      return this.get('ry') * this.get('scaleY');
+    toString: function() {
+      return '#<fabric.Path (' + this.complexity() +
+        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
     },
 
     /**
@@ -18770,7 +22224,22 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
      * @return {Object} object representation of an instance
      */
     toObject: function(propertiesToInclude) {
-      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
+      return extend(this.callSuper('toObject', propertiesToInclude), {
+        path: this.path.map(function(item) { return item.slice(); }),
+      });
+    },
+
+    /**
+     * Returns dataless object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
+     */
+    toDatalessObject: function(propertiesToInclude) {
+      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
+      if (o.sourcePath) {
+        delete o.path;
+      }
+      return o;
     },
 
     /* _TO_SVG_START_ */
@@ -18780,75 +22249,188 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
      * of the instance
      */
     _toSVG: function() {
+      var path = fabric.util.joinPath(this.path);
       return [
-        '<ellipse ', 'COMMON_PARTS',
-        'cx="0" cy="0" ',
-        'rx="', this.rx,
-        '" ry="', this.ry,
-        '" />\n'
+        '<path ', 'COMMON_PARTS',
+        'd="', path,
+        '" stroke-linecap="round" ',
+        '/>\n'
       ];
     },
+
+    _getOffsetTransform: function() {
+      var digits = fabric.Object.NUM_FRACTION_DIGITS;
+      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
+          toFixed(-this.pathOffset.y, digits) + ')';
+    },
+
+    /**
+     * Returns svg clipPath representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
+     */
+    toClipPathSVG: function(reviver) {
+      var additionalTransform = this._getOffsetTransform();
+      return '\t' + this._createBaseClipPathSVGMarkup(
+        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
+      );
+    },
+
+    /**
+     * Returns svg representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
+     */
+    toSVG: function(reviver) {
+      var additionalTransform = this._getOffsetTransform();
+      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
+    },
     /* _TO_SVG_END_ */
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx context to render on
+     * Returns number representation of an instance complexity
+     * @return {Number} complexity of this instance
      */
-    _render: function(ctx) {
-      ctx.beginPath();
-      ctx.save();
-      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
-      ctx.arc(
-        0,
-        0,
-        this.rx,
-        0,
-        piBy2,
-        false);
-      ctx.restore();
-      this._renderPaintInOrder(ctx);
+    complexity: function() {
+      return this.path.length;
     },
+
+    /**
+     * @private
+     */
+    _calcDimensions: function() {
+
+      var aX = [],
+          aY = [],
+          current, // current instruction
+          subpathStartX = 0,
+          subpathStartY = 0,
+          x = 0, // current x
+          y = 0, // current y
+          bounds;
+
+      for (var i = 0, len = this.path.length; i < len; ++i) {
+
+        current = this.path[i];
+
+        switch (current[0]) { // first letter
+
+          case 'L': // lineto, absolute
+            x = current[1];
+            y = current[2];
+            bounds = [];
+            break;
+
+          case 'M': // moveTo, absolute
+            x = current[1];
+            y = current[2];
+            subpathStartX = x;
+            subpathStartY = y;
+            bounds = [];
+            break;
+
+          case 'C': // bezierCurveTo, absolute
+            bounds = fabric.util.getBoundsOfCurve(x, y,
+              current[1],
+              current[2],
+              current[3],
+              current[4],
+              current[5],
+              current[6]
+            );
+            x = current[5];
+            y = current[6];
+            break;
+
+          case 'Q': // quadraticCurveTo, absolute
+            bounds = fabric.util.getBoundsOfCurve(x, y,
+              current[1],
+              current[2],
+              current[1],
+              current[2],
+              current[3],
+              current[4]
+            );
+            x = current[3];
+            y = current[4];
+            break;
+
+          case 'z':
+          case 'Z':
+            x = subpathStartX;
+            y = subpathStartY;
+            break;
+        }
+        bounds.forEach(function (point) {
+          aX.push(point.x);
+          aY.push(point.y);
+        });
+        aX.push(x);
+        aY.push(y);
+      }
+
+      var minX = min(aX) || 0,
+          minY = min(aY) || 0,
+          maxX = max(aX) || 0,
+          maxY = max(aY) || 0,
+          deltaX = maxX - minX,
+          deltaY = maxY - minY;
+
+      return {
+        left: minX,
+        top: minY,
+        width: deltaX,
+        height: deltaY
+      };
+    }
   });
 
+  /**
+   * Creates an instance of fabric.Path from an object
+   * @static
+   * @memberOf fabric.Path
+   * @param {Object} object
+   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
+   */
+  fabric.Path.fromObject = function(object, callback) {
+    if (typeof object.sourcePath === 'string') {
+      var pathUrl = object.sourcePath;
+      fabric.loadSVGFromURL(pathUrl, function (elements) {
+        var path = elements[0];
+        path.setOptions(object);
+        callback && callback(path);
+      });
+    }
+    else {
+      fabric.Object._fromObject('Path', object, callback, 'path');
+    }
+  };
+
   /* _FROM_SVG_START_ */
   /**
-   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
+   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
    * @static
-   * @memberOf fabric.Ellipse
-   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
+   * @memberOf fabric.Path
+   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
    */
-  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
+  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
 
   /**
-   * Returns {@link fabric.Ellipse} instance from an SVG element
+   * Creates an instance of fabric.Path from an SVG <path> element
    * @static
-   * @memberOf fabric.Ellipse
-   * @param {SVGElement} element Element to parse
+   * @memberOf fabric.Path
+   * @param {SVGElement} element to parse
+   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
+   * @param {Object} [options] Options object
    * @param {Function} [callback] Options callback invoked after parsing is finished
-   * @return {fabric.Ellipse}
    */
-  fabric.Ellipse.fromElement = function(element, callback) {
-
-    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
-
-    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
-    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
-    callback(new fabric.Ellipse(parsedAttributes));
+  fabric.Path.fromElement = function(element, callback, options) {
+    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
+    parsedAttributes.fromSVG = true;
+    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
   };
   /* _FROM_SVG_END_ */
 
-  /**
-   * Returns {@link fabric.Ellipse} instance from an object representation
-   * @static
-   * @memberOf fabric.Ellipse
-   * @param {Object} object Object to create an instance from
-   * @param {function} [callback] invoked with new instance as first argument
-   * @return {void}
-   */
-  fabric.Ellipse.fromObject = function(object, callback) {
-    fabric.Object._fromObject('Ellipse', object, callback);
-  };
-
 })(typeof exports !== 'undefined' ? exports : this);
 
 
@@ -18857,716 +22439,552 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
   'use strict';
 
   var fabric = global.fabric || (global.fabric = { }),
-      extend = fabric.util.object.extend;
+      min = fabric.util.array.min,
+      max = fabric.util.array.max;
 
-  if (fabric.Rect) {
-    fabric.warn('fabric.Rect is already defined');
+  if (fabric.Group) {
     return;
   }
 
   /**
-   * Rectangle class
-   * @class fabric.Rect
+   * Group class
+   * @class fabric.Group
    * @extends fabric.Object
-   * @return {fabric.Rect} thisArg
-   * @see {@link fabric.Rect#initialize} for constructor definition
+   * @mixes fabric.Collection
+   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
+   * @see {@link fabric.Group#initialize} for constructor definition
    */
-  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {
-
-    /**
-     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
-     * as well as for history (undo/redo) purposes
-     * @type Array
-     */
-    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),
+  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {
 
     /**
      * Type of an object
      * @type String
      * @default
      */
-    type: 'rect',
+    type: 'group',
 
     /**
-     * Horizontal border radius
+     * Width of stroke
      * @type Number
      * @default
      */
-    rx:   0,
+    strokeWidth: 0,
 
     /**
-     * Vertical border radius
-     * @type Number
+     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
+     * @type Boolean
      * @default
      */
-    ry:   0,
-
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),
-
-    /**
-     * Constructor
-     * @param {Object} [options] Options object
-     * @return {Object} thisArg
-     */
-    initialize: function(options) {
-      this.callSuper('initialize', options);
-      this._initRxRy();
-    },
-
-    /**
-     * Initializes rx/ry attributes
-     * @private
-     */
-    _initRxRy: function() {
-      if (this.rx && !this.ry) {
-        this.ry = this.rx;
-      }
-      else if (this.ry && !this.rx) {
-        this.rx = this.ry;
-      }
-    },
+    subTargetCheck: false,
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Groups are container, do not render anything on theyr own, ence no cache properties
+     * @type Array
+     * @default
      */
-    _render: function(ctx) {
-
-      // 1x1 case (used in spray brush) optimization was removed because
-      // with caching and higher zoom level this makes more damage than help
-
-      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
-          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
-          w = this.width,
-          h = this.height,
-          x = -this.width / 2,
-          y = -this.height / 2,
-          isRounded = rx !== 0 || ry !== 0,
-          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
-          k = 1 - 0.5522847498;
-      ctx.beginPath();
-
-      ctx.moveTo(x + rx, y);
-
-      ctx.lineTo(x + w - rx, y);
-      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
-
-      ctx.lineTo(x + w, y + h - ry);
-      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
-
-      ctx.lineTo(x + rx, y + h);
-      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
-
-      ctx.lineTo(x, y + ry);
-      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
-
-      ctx.closePath();
-
-      this._renderPaintInOrder(ctx);
-    },
+    cacheProperties: [],
 
     /**
-     * Returns object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
+     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
+     * available setting this boolean to true.
+     * @type Boolean
+     * @since 2.0.0
+     * @default
      */
-    toObject: function(propertiesToInclude) {
-      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
-    },
+    useSetOnGroup: false,
 
-    /* _TO_SVG_START_ */
     /**
-     * Returns svg representation of an instance
-     * @return {Array} an array of strings with the specific svg representation
-     * of the instance
+     * Constructor
+     * @param {Object} objects Group objects
+     * @param {Object} [options] Options object
+     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
+     * @return {Object} thisArg
      */
-    _toSVG: function() {
-      var x = -this.width / 2, y = -this.height / 2;
-      return [
-        '<rect ', 'COMMON_PARTS',
-        'x="', x, '" y="', y,
-        '" rx="', this.rx, '" ry="', this.ry,
-        '" width="', this.width, '" height="', this.height,
-        '" />\n'
-      ];
-    },
-    /* _TO_SVG_END_ */
-  });
-
-  /* _FROM_SVG_START_ */
-  /**
-   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
-   * @static
-   * @memberOf fabric.Rect
-   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
-   */
-  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
-
-  /**
-   * Returns {@link fabric.Rect} instance from an SVG element
-   * @static
-   * @memberOf fabric.Rect
-   * @param {SVGElement} element Element to parse
-   * @param {Function} callback callback function invoked after parsing
-   * @param {Object} [options] Options object
-   */
-  fabric.Rect.fromElement = function(element, callback, options) {
-    if (!element) {
-      return callback(null);
-    }
-    options = options || { };
-
-    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
-    parsedAttributes.left = parsedAttributes.left || 0;
-    parsedAttributes.top  = parsedAttributes.top  || 0;
-    parsedAttributes.height  = parsedAttributes.height || 0;
-    parsedAttributes.width  = parsedAttributes.width || 0;
-    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
-    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
-    callback(rect);
-  };
-  /* _FROM_SVG_END_ */
-
-  /**
-   * Returns {@link fabric.Rect} instance from an object representation
-   * @static
-   * @memberOf fabric.Rect
-   * @param {Object} object Object to create an instance from
-   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
-   */
-  fabric.Rect.fromObject = function(object, callback) {
-    return fabric.Object._fromObject('Rect', object, callback);
-  };
+    initialize: function(objects, options, isAlreadyGrouped) {
+      options = options || {};
+      this._objects = [];
+      // if objects enclosed in a group have been grouped already,
+      // we cannot change properties of objects.
+      // Thus we need to set options to group without objects,
+      isAlreadyGrouped && this.callSuper('initialize', options);
+      this._objects = objects || [];
+      for (var i = this._objects.length; i--; ) {
+        this._objects[i].group = this;
+      }
 
-})(typeof exports !== 'undefined' ? exports : this);
+      if (!isAlreadyGrouped) {
+        var center = options && options.centerPoint;
+        // we want to set origins before calculating the bounding box.
+        // so that the topleft can be set with that in mind.
+        // if specific top and left are passed, are overwritten later
+        // with the callSuper('initialize', options)
+        if (options.originX !== undefined) {
+          this.originX = options.originX;
+        }
+        if (options.originY !== undefined) {
+          this.originY = options.originY;
+        }
+        // if coming from svg i do not want to calc bounds.
+        // i assume width and height are passed along options
+        center || this._calcBounds();
+        this._updateObjectsCoords(center);
+        delete options.centerPoint;
+        this.callSuper('initialize', options);
+      }
+      else {
+        this._updateObjectsACoords();
+      }
 
+      this.setCoords();
+    },
 
-(function(global) {
+    /**
+     * @private
+     */
+    _updateObjectsACoords: function() {
+      var skipControls = true;
+      for (var i = this._objects.length; i--; ){
+        this._objects[i].setCoords(skipControls);
+      }
+    },
 
-  'use strict';
+    /**
+     * @private
+     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
+     */
+    _updateObjectsCoords: function(center) {
+      var center = center || this.getCenterPoint();
+      for (var i = this._objects.length; i--; ){
+        this._updateObjectCoords(this._objects[i], center);
+      }
+    },
 
-  var fabric = global.fabric || (global.fabric = { }),
-      extend = fabric.util.object.extend,
-      min = fabric.util.array.min,
-      max = fabric.util.array.max,
-      toFixed = fabric.util.toFixed;
+    /**
+     * @private
+     * @param {Object} object
+     * @param {fabric.Point} center, current center of group.
+     */
+    _updateObjectCoords: function(object, center) {
+      var objectLeft = object.left,
+          objectTop = object.top,
+          skipControls = true;
 
-  if (fabric.Polyline) {
-    fabric.warn('fabric.Polyline is already defined');
-    return;
-  }
+      object.set({
+        left: objectLeft - center.x,
+        top: objectTop - center.y
+      });
+      object.group = this;
+      object.setCoords(skipControls);
+    },
 
-  /**
-   * Polyline class
-   * @class fabric.Polyline
-   * @extends fabric.Object
-   * @see {@link fabric.Polyline#initialize} for constructor definition
-   */
-  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {
+    /**
+     * Returns string represenation of a group
+     * @return {String}
+     */
+    toString: function() {
+      return '#<fabric.Group: (' + this.complexity() + ')>';
+    },
 
     /**
-     * Type of an object
-     * @type String
-     * @default
+     * Adds an object to a group; Then recalculates group's dimension, position.
+     * @param {Object} object
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    type: 'polyline',
+    addWithUpdate: function(object) {
+      var nested = !!this.group;
+      this._restoreObjectsState();
+      fabric.util.resetObjectTransform(this);
+      if (object) {
+        if (nested) {
+          // if this group is inside another group, we need to pre transform the object
+          fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());
+        }
+        this._objects.push(object);
+        object.group = this;
+        object._set('canvas', this.canvas);
+      }
+      this._calcBounds();
+      this._updateObjectsCoords();
+      this.dirty = true;
+      if (nested) {
+        this.group.addWithUpdate();
+      }
+      else {
+        this.setCoords();
+      }
+      return this;
+    },
 
     /**
-     * Points array
-     * @type Array
-     * @default
+     * Removes an object from a group; Then recalculates group's dimension, position.
+     * @param {Object} object
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    points: null,
+    removeWithUpdate: function(object) {
+      this._restoreObjectsState();
+      fabric.util.resetObjectTransform(this);
 
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),
+      this.remove(object);
+      this._calcBounds();
+      this._updateObjectsCoords();
+      this.setCoords();
+      this.dirty = true;
+      return this;
+    },
 
     /**
-     * Constructor
-     * @param {Array} points Array of points (where each point is an object with x and y)
-     * @param {Object} [options] Options object
-     * @return {fabric.Polyline} thisArg
-     * @example
-     * var poly = new fabric.Polyline([
-     *     { x: 10, y: 10 },
-     *     { x: 50, y: 30 },
-     *     { x: 40, y: 70 },
-     *     { x: 60, y: 50 },
-     *     { x: 100, y: 150 },
-     *     { x: 40, y: 100 }
-     *   ], {
-     *   stroke: 'red',
-     *   left: 100,
-     *   top: 100
-     * });
+     * @private
      */
-    initialize: function(points, options) {
-      options = options || {};
-      this.points = points || [];
-      this.callSuper('initialize', options);
-      this._setPositionDimensions(options);
+    _onObjectAdded: function(object) {
+      this.dirty = true;
+      object.group = this;
+      object._set('canvas', this.canvas);
     },
 
-    _setPositionDimensions: function(options) {
-      var calcDim = this._calcDimensions(options), correctLeftTop;
-      this.width = calcDim.width;
-      this.height = calcDim.height;
-      if (!options.fromSVG) {
-        correctLeftTop = this.translateToGivenOrigin(
-          { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
-          'left',
-          'top',
-          this.originX,
-          this.originY
-        );
-      }
-      if (typeof options.left === 'undefined') {
-        this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
-      }
-      if (typeof options.top === 'undefined') {
-        this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
-      }
-      this.pathOffset = {
-        x: calcDim.left + this.width / 2,
-        y: calcDim.top + this.height / 2
-      };
+    /**
+     * @private
+     */
+    _onObjectRemoved: function(object) {
+      this.dirty = true;
+      delete object.group;
     },
 
     /**
-     * Calculate the polygon min and max point from points array,
-     * returning an object with left, top, width, height to measure the
-     * polygon size
-     * @return {Object} object.left X coordinate of the polygon leftmost point
-     * @return {Object} object.top Y coordinate of the polygon topmost point
-     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
-     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
      * @private
      */
-    _calcDimensions: function() {
+    _set: function(key, value) {
+      var i = this._objects.length;
+      if (this.useSetOnGroup) {
+        while (i--) {
+          this._objects[i].setOnGroup(key, value);
+        }
+      }
+      if (key === 'canvas') {
+        while (i--) {
+          this._objects[i]._set(key, value);
+        }
+      }
+      fabric.Object.prototype._set.call(this, key, value);
+    },
 
-      var points = this.points,
-          minX = min(points, 'x') || 0,
-          minY = min(points, 'y') || 0,
-          maxX = max(points, 'x') || 0,
-          maxY = max(points, 'y') || 0,
-          width = (maxX - minX),
-          height = (maxY - minY);
+    /**
+     * Returns object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
+     */
+    toObject: function(propertiesToInclude) {
+      var _includeDefaultValues = this.includeDefaultValues;
+      var objsToObject = this._objects
+        .filter(function (obj) {
+          return !obj.excludeFromExport;
+        })
+        .map(function (obj) {
+          var originalDefaults = obj.includeDefaultValues;
+          obj.includeDefaultValues = _includeDefaultValues;
+          var _obj = obj.toObject(propertiesToInclude);
+          obj.includeDefaultValues = originalDefaults;
+          return _obj;
+        });
+      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
+      obj.objects = objsToObject;
+      return obj;
+    },
 
-      return {
-        left: minX,
-        top: minY,
-        width: width,
-        height: height
-      };
+    /**
+     * Returns object representation of an instance, in dataless mode.
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
+     */
+    toDatalessObject: function(propertiesToInclude) {
+      var objsToObject, sourcePath = this.sourcePath;
+      if (sourcePath) {
+        objsToObject = sourcePath;
+      }
+      else {
+        var _includeDefaultValues = this.includeDefaultValues;
+        objsToObject = this._objects.map(function(obj) {
+          var originalDefaults = obj.includeDefaultValues;
+          obj.includeDefaultValues = _includeDefaultValues;
+          var _obj = obj.toDatalessObject(propertiesToInclude);
+          obj.includeDefaultValues = originalDefaults;
+          return _obj;
+        });
+      }
+      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
+      obj.objects = objsToObject;
+      return obj;
     },
 
     /**
-     * Returns object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} Object representation of an instance
+     * Renders instance on a given context
+     * @param {CanvasRenderingContext2D} ctx context to render instance on
      */
-    toObject: function(propertiesToInclude) {
-      return extend(this.callSuper('toObject', propertiesToInclude), {
-        points: this.points.concat()
-      });
+    render: function(ctx) {
+      this._transformDone = true;
+      this.callSuper('render', ctx);
+      this._transformDone = false;
     },
 
-    /* _TO_SVG_START_ */
     /**
-     * Returns svg representation of an instance
-     * @return {Array} an array of strings with the specific svg representation
-     * of the instance
+     * Decide if the object should cache or not. Create its own cache level
+     * needsItsOwnCache should be used when the object drawing method requires
+     * a cache step. None of the fabric classes requires it.
+     * Generally you do not cache objects in groups because the group is already cached.
+     * @return {Boolean}
      */
-    _toSVG: function() {
-      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
-          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
-
-      for (var i = 0, len = this.points.length; i < len; i++) {
-        points.push(
-          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
-          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
-        );
+    shouldCache: function() {
+      var ownCache = fabric.Object.prototype.shouldCache.call(this);
+      if (ownCache) {
+        for (var i = 0, len = this._objects.length; i < len; i++) {
+          if (this._objects[i].willDrawShadow()) {
+            this.ownCaching = false;
+            return false;
+          }
+        }
       }
-      return [
-        '<' + this.type + ' ', 'COMMON_PARTS',
-        'points="', points.join(''),
-        '" />\n'
-      ];
+      return ownCache;
     },
-    /* _TO_SVG_END_ */
-
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Check if this object or a child object will cast a shadow
+     * @return {Boolean}
      */
-    commonRender: function(ctx) {
-      var point, len = this.points.length,
-          x = this.pathOffset.x,
-          y = this.pathOffset.y;
-
-      if (!len || isNaN(this.points[len - 1].y)) {
-        // do not draw if no points or odd points
-        // NaN comes from parseFloat of a empty string in parser
-        return false;
+    willDrawShadow: function() {
+      if (fabric.Object.prototype.willDrawShadow.call(this)) {
+        return true;
       }
-      ctx.beginPath();
-      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
-      for (var i = 0; i < len; i++) {
-        point = this.points[i];
-        ctx.lineTo(point.x - x, point.y - y);
+      for (var i = 0, len = this._objects.length; i < len; i++) {
+        if (this._objects[i].willDrawShadow()) {
+          return true;
+        }
       }
-      return true;
+      return false;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Check if this group or its parent group are caching, recursively up
+     * @return {Boolean}
      */
-    _render: function(ctx) {
-      if (!this.commonRender(ctx)) {
-        return;
-      }
-      this._renderPaintInOrder(ctx);
+    isOnACache: function() {
+      return this.ownCaching || (this.group && this.group.isOnACache());
     },
 
     /**
-     * Returns complexity of an instance
-     * @return {Number} complexity of this instance
+     * Execute the drawing operation for an object on a specified context
+     * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    complexity: function() {
-      return this.get('points').length;
-    }
-  });
-
-  /* _FROM_SVG_START_ */
-  /**
-   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
-   * @static
-   * @memberOf fabric.Polyline
-   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
-   */
-  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
-
-  /**
-   * Returns fabric.Polyline instance from an SVG element
-   * @static
-   * @memberOf fabric.Polyline
-   * @param {SVGElement} element Element to parser
-   * @param {Function} callback callback function invoked after parsing
-   * @param {Object} [options] Options object
-   */
-  fabric.Polyline.fromElementGenerator = function(_class) {
-    return function(element, callback, options) {
-      if (!element) {
-        return callback(null);
+    drawObject: function(ctx) {
+      for (var i = 0, len = this._objects.length; i < len; i++) {
+        this._objects[i].render(ctx);
       }
-      options || (options = { });
-
-      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
-          parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
-      parsedAttributes.fromSVG = true;
-      callback(new fabric[_class](points, extend(parsedAttributes, options)));
-    };
-  };
-
-  fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');
-
-  /* _FROM_SVG_END_ */
-
-  /**
-   * Returns fabric.Polyline instance from an object representation
-   * @static
-   * @memberOf fabric.Polyline
-   * @param {Object} object Object to create an instance from
-   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
-   */
-  fabric.Polyline.fromObject = function(object, callback) {
-    return fabric.Object._fromObject('Polyline', object, callback, 'points');
-  };
-
-})(typeof exports !== 'undefined' ? exports : this);
-
-
-(function(global) {
-
-  'use strict';
-
-  var fabric = global.fabric || (global.fabric = { });
-
-  if (fabric.Polygon) {
-    fabric.warn('fabric.Polygon is already defined');
-    return;
-  }
-
-  /**
-   * Polygon class
-   * @class fabric.Polygon
-   * @extends fabric.Polyline
-   * @see {@link fabric.Polygon#initialize} for constructor definition
-   */
-  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {
-
-    /**
-     * Type of an object
-     * @type String
-     * @default
-     */
-    type: 'polygon',
+      this._drawClipPath(ctx);
+    },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx Context to render on
+     * Check if cache is dirty
      */
-    _render: function(ctx) {
-      if (!this.commonRender(ctx)) {
-        return;
+    isCacheDirty: function(skipCanvas) {
+      if (this.callSuper('isCacheDirty', skipCanvas)) {
+        return true;
       }
-      ctx.closePath();
-      this._renderPaintInOrder(ctx);
-    },
-
-  });
-
-  /* _FROM_SVG_START_ */
-  /**
-   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
-   * @static
-   * @memberOf fabric.Polygon
-   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
-   */
-  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
-
-  /**
-   * Returns {@link fabric.Polygon} instance from an SVG element
-   * @static
-   * @memberOf fabric.Polygon
-   * @param {SVGElement} element Element to parse
-   * @param {Function} callback callback function invoked after parsing
-   * @param {Object} [options] Options object
-   */
-  fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
-  /* _FROM_SVG_END_ */
-
-  /**
-   * Returns fabric.Polygon instance from an object representation
-   * @static
-   * @memberOf fabric.Polygon
-   * @param {Object} object Object to create an instance from
-   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
-   * @return {void}
-   */
-  fabric.Polygon.fromObject = function(object, callback) {
-    fabric.Object._fromObject('Polygon', object, callback, 'points');
-  };
-
-})(typeof exports !== 'undefined' ? exports : this);
-
-
-(function(global) {
-
-  'use strict';
-
-  var fabric = global.fabric || (global.fabric = { }),
-      min = fabric.util.array.min,
-      max = fabric.util.array.max,
-      extend = fabric.util.object.extend,
-      _toString = Object.prototype.toString,
-      toFixed = fabric.util.toFixed;
-
-  if (fabric.Path) {
-    fabric.warn('fabric.Path is already defined');
-    return;
-  }
-
-  /**
-   * Path class
-   * @class fabric.Path
-   * @extends fabric.Object
-   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
-   * @see {@link fabric.Path#initialize} for constructor definition
-   */
-  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {
+      if (!this.statefullCache) {
+        return false;
+      }
+      for (var i = 0, len = this._objects.length; i < len; i++) {
+        if (this._objects[i].isCacheDirty(true)) {
+          if (this._cacheCanvas) {
+            // if this group has not a cache canvas there is nothing to clean
+            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
+            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
+          }
+          return true;
+        }
+      }
+      return false;
+    },
 
     /**
-     * Type of an object
-     * @type String
-     * @default
+     * Restores original state of each of group objects (original state is that which was before group was created).
+     * if the nested boolean is true, the original state will be restored just for the
+     * first group and not for all the group chain
+     * @private
+     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    type: 'path',
+    _restoreObjectsState: function() {
+      var groupMatrix = this.calcOwnMatrix();
+      this._objects.forEach(function(object) {
+        // instead of using _this = this;
+        fabric.util.addTransformToObject(object, groupMatrix);
+        delete object.group;
+        object.setCoords();
+      });
+      return this;
+    },
 
     /**
-     * Array of path points
-     * @type Array
-     * @default
+     * Realises the transform from this group onto the supplied object
+     * i.e. it tells you what would happen if the supplied object was in
+     * the group, and then the group was destroyed. It mutates the supplied
+     * object.
+     * Warning: this method is not useful anymore, it has been kept to no break the api.
+     * is not used in the fabricJS codebase
+     * this method will be reduced to using the utility.
+     * @private
+     * @deprecated
+     * @param {fabric.Object} object that is inside the group
+     * @param {Array} parentMatrix parent transformation of the object.
+     * @return {fabric.Object} transformedObject
      */
-    path: null,
-
-    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),
-
-    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),
+    realizeTransform: function(object, parentMatrix) {
+      fabric.util.addTransformToObject(
+        object,
+        parentMatrix || this.calcTransformMatrix()
+      );
+      return object;
+    },
 
     /**
-     * Constructor
-     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
-     * @param {Object} [options] Options object
-     * @return {fabric.Path} thisArg
+     * Destroys a group (restoring state of its objects)
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    initialize: function(path, options) {
-      options = options || { };
-      this.callSuper('initialize', options);
-      if (!path) {
-        path = [];
-      }
-
-      var fromArray = _toString.call(path) === '[object Array]';
-
-      this.path = fabric.util.makePathSimpler(
-        fromArray ? path : fabric.util.parsePath(path)
-      );
+    destroy: function() {
+      // when group is destroyed objects needs to get a repaint to be eventually
+      // displayed on canvas.
+      this._objects.forEach(function(object) {
+        object.set('dirty', true);
+      });
+      return this._restoreObjectsState();
+    },
 
-      if (!this.path) {
+    /**
+     * make a group an active selection, remove the group from canvas
+     * the group has to be on canvas for this to work.
+     * @return {fabric.ActiveSelection} thisArg
+     * @chainable
+     */
+    toActiveSelection: function() {
+      if (!this.canvas) {
         return;
       }
-      fabric.Polyline.prototype._setPositionDimensions.call(this, options);
+      var objects = this._objects, canvas = this.canvas;
+      this._objects = [];
+      var options = this.toObject();
+      delete options.objects;
+      var activeSelection = new fabric.ActiveSelection([]);
+      activeSelection.set(options);
+      activeSelection.type = 'activeSelection';
+      canvas.remove(this);
+      objects.forEach(function(object) {
+        object.group = activeSelection;
+        object.dirty = true;
+        canvas.add(object);
+      });
+      activeSelection.canvas = canvas;
+      activeSelection._objects = objects;
+      canvas._activeObject = activeSelection;
+      activeSelection.setCoords();
+      return activeSelection;
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx context to render path on
+     * Destroys a group (restoring state of its objects)
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    _renderPathCommands: function(ctx) {
-      var current, // current instruction
-          subpathStartX = 0,
-          subpathStartY = 0,
-          x = 0, // current x
-          y = 0, // current y
-          controlX = 0, // current control point x
-          controlY = 0, // current control point y
-          l = -this.pathOffset.x,
-          t = -this.pathOffset.y;
-
-      ctx.beginPath();
-
-      for (var i = 0, len = this.path.length; i < len; ++i) {
-
-        current = this.path[i];
-
-        switch (current[0]) { // first letter
-
-          case 'L': // lineto, absolute
-            x = current[1];
-            y = current[2];
-            ctx.lineTo(x + l, y + t);
-            break;
-
-          case 'M': // moveTo, absolute
-            x = current[1];
-            y = current[2];
-            subpathStartX = x;
-            subpathStartY = y;
-            ctx.moveTo(x + l, y + t);
-            break;
-
-          case 'C': // bezierCurveTo, absolute
-            x = current[5];
-            y = current[6];
-            controlX = current[3];
-            controlY = current[4];
-            ctx.bezierCurveTo(
-              current[1] + l,
-              current[2] + t,
-              controlX + l,
-              controlY + t,
-              x + l,
-              y + t
-            );
-            break;
-
-          case 'Q': // quadraticCurveTo, absolute
-            ctx.quadraticCurveTo(
-              current[1] + l,
-              current[2] + t,
-              current[3] + l,
-              current[4] + t
-            );
-            x = current[3];
-            y = current[4];
-            controlX = current[1];
-            controlY = current[2];
-            break;
-
-          case 'z':
-          case 'Z':
-            x = subpathStartX;
-            y = subpathStartY;
-            ctx.closePath();
-            break;
-        }
-      }
+    ungroupOnCanvas: function() {
+      return this._restoreObjectsState();
     },
 
     /**
-     * @private
-     * @param {CanvasRenderingContext2D} ctx context to render path on
+     * Sets coordinates of all objects inside group
+     * @return {fabric.Group} thisArg
+     * @chainable
      */
-    _render: function(ctx) {
-      this._renderPathCommands(ctx);
-      this._renderPaintInOrder(ctx);
+    setObjectsCoords: function() {
+      var skipControls = true;
+      this.forEachObject(function(object) {
+        object.setCoords(skipControls);
+      });
+      return this;
     },
 
     /**
-     * Returns string representation of an instance
-     * @return {String} string representation of an instance
+     * @private
      */
-    toString: function() {
-      return '#<fabric.Path (' + this.complexity() +
-        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
+    _calcBounds: function(onlyWidthHeight) {
+      var aX = [],
+          aY = [],
+          o, prop, coords,
+          props = ['tr', 'br', 'bl', 'tl'],
+          i = 0, iLen = this._objects.length,
+          j, jLen = props.length;
+
+      for ( ; i < iLen; ++i) {
+        o = this._objects[i];
+        coords = o.calcACoords();
+        for (j = 0; j < jLen; j++) {
+          prop = props[j];
+          aX.push(coords[prop].x);
+          aY.push(coords[prop].y);
+        }
+        o.aCoords = coords;
+      }
+
+      this._getBounds(aX, aY, onlyWidthHeight);
     },
 
     /**
-     * Returns object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
+     * @private
      */
-    toObject: function(propertiesToInclude) {
-      return extend(this.callSuper('toObject', propertiesToInclude), {
-        path: this.path.map(function(item) { return item.slice(); }),
-      });
+    _getBounds: function(aX, aY, onlyWidthHeight) {
+      var minXY = new fabric.Point(min(aX), min(aY)),
+          maxXY = new fabric.Point(max(aX), max(aY)),
+          top = minXY.y || 0, left = minXY.x || 0,
+          width = (maxXY.x - minXY.x) || 0,
+          height = (maxXY.y - minXY.y) || 0;
+      this.width = width;
+      this.height = height;
+      if (!onlyWidthHeight) {
+        // the bounding box always finds the topleft most corner.
+        // whatever is the group origin, we set up here the left/top position.
+        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
+      }
     },
 
+    /* _TO_SVG_START_ */
     /**
-     * Returns dataless object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
+     * Returns svg representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
      */
-    toDatalessObject: function(propertiesToInclude) {
-      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
-      if (o.sourcePath) {
-        delete o.path;
+    _toSVG: function(reviver) {
+      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];
+
+      for (var i = 0, len = this._objects.length; i < len; i++) {
+        svgString.push('\t\t', this._objects[i].toSVG(reviver));
       }
-      return o;
+      svgString.push('</g>\n');
+      return svgString;
     },
 
-    /* _TO_SVG_START_ */
     /**
-     * Returns svg representation of an instance
-     * @return {Array} an array of strings with the specific svg representation
-     * of the instance
+     * Returns styles-string for svg-export, specific version for group
+     * @return {String}
      */
-    _toSVG: function() {
-      var path = fabric.util.joinPath(this.path);
+    getSvgStyles: function() {
+      var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
+            'opacity: ' + this.opacity + ';' : '',
+          visibility = this.visible ? '' : ' visibility: hidden;';
       return [
-        '<path ', 'COMMON_PARTS',
-        'd="', path,
-        '" stroke-linecap="round" ',
-        '/>\n'
-      ];
-    },
-
-    _getOffsetTransform: function() {
-      var digits = fabric.Object.NUM_FRACTION_DIGITS;
-      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
-          toFixed(-this.pathOffset.y, digits) + ')';
+        opacity,
+        this.getSvgFilter(),
+        visibility
+      ].join('');
     },
 
     /**
@@ -19575,764 +22993,905 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
      * @return {String} svg representation of an instance
      */
     toClipPathSVG: function(reviver) {
-      var additionalTransform = this._getOffsetTransform();
-      return '\t' + this._createBaseClipPathSVGMarkup(
-        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
-      );
-    },
+      var svgString = [];
 
-    /**
-     * Returns svg representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
-     */
-    toSVG: function(reviver) {
-      var additionalTransform = this._getOffsetTransform();
-      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
+      for (var i = 0, len = this._objects.length; i < len; i++) {
+        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
+      }
+
+      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
     },
     /* _TO_SVG_END_ */
+  });
 
-    /**
-     * Returns number representation of an instance complexity
-     * @return {Number} complexity of this instance
-     */
-    complexity: function() {
-      return this.path.length;
-    },
+  /**
+   * Returns {@link fabric.Group} instance from an object representation
+   * @static
+   * @memberOf fabric.Group
+   * @param {Object} object Object to create a group from
+   * @param {Function} [callback] Callback to invoke when an group instance is created
+   */
+  fabric.Group.fromObject = function(object, callback) {
+    var objects = object.objects,
+        options = fabric.util.object.clone(object, true);
+    delete options.objects;
+    if (typeof objects === 'string') {
+      // it has to be an url or something went wrong.
+      fabric.loadSVGFromURL(objects, function (elements) {
+        var group = fabric.util.groupSVGElements(elements, object, objects);
+        group.set(options);
+        callback && callback(group);
+      });
+      return;
+    }
+    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
+      fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
+        var options = fabric.util.object.clone(object, true);
+        options.clipPath = enlivedClipPath[0];
+        delete options.objects;
+        callback && callback(new fabric.Group(enlivenedObjects, options, true));
+      });
+    });
+  };
 
-    /**
-     * @private
-     */
-    _calcDimensions: function() {
+})(typeof exports !== 'undefined' ? exports : this);
 
-      var aX = [],
-          aY = [],
-          current, // current instruction
-          subpathStartX = 0,
-          subpathStartY = 0,
-          x = 0, // current x
-          y = 0, // current y
-          bounds;
 
-      for (var i = 0, len = this.path.length; i < len; ++i) {
+(function (global) {
 
-        current = this.path[i];
+  'use strict';
 
-        switch (current[0]) { // first letter
+  var fabric = global.fabric || (global.fabric = {}),
+      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
+      invertTransform = fabric.util.invertTransform,
+      applyTransformToObject = fabric.util.applyTransformToObject,
+      clone = fabric.util.object.clone,
+      extend = fabric.util.object.extend;
 
-          case 'L': // lineto, absolute
-            x = current[1];
-            y = current[2];
-            bounds = [];
-            break;
+  if (fabric.ICollection) {
+    fabric.warn('fabric.ICollection is already defined');
+    return;
+  }
 
-          case 'M': // moveTo, absolute
-            x = current[1];
-            y = current[2];
-            subpathStartX = x;
-            subpathStartY = y;
-            bounds = [];
-            break;
+  /**
+   * ICollection class
+   * @class fabric.ICollection
+   * @extends fabric.Object
+   * @mixes fabric.Collection
+   * @fires added on added object before layout
+   * @fires removed on removed object before layout
+   * @see {@link fabric.ICollection#initialize} for constructor definition
+   */
+  fabric.ICollection = fabric.util.createClass(fabric.Object, fabric.Collection,
+    /** @lends fabric.ICollection.prototype */
+    {
 
-          case 'C': // bezierCurveTo, absolute
-            bounds = fabric.util.getBoundsOfCurve(x, y,
-              current[1],
-              current[2],
-              current[3],
-              current[4],
-              current[5],
-              current[6]
-            );
-            x = current[5];
-            y = current[6];
-            break;
+      /**
+       * Type of an object
+       * @type string
+       * @default
+       */
+      type: 'iCollection',
 
-          case 'Q': // quadraticCurveTo, absolute
-            bounds = fabric.util.getBoundsOfCurve(x, y,
-              current[1],
-              current[2],
-              current[1],
-              current[2],
-              current[3],
-              current[4]
-            );
-            x = current[3];
-            y = current[4];
-            break;
+      /**
+       * Specifies the **layout strategy** for instance
+       * Used by `getLayoutStrategyResult` to calculate layout
+       * @type string
+       * @default
+       */
+      layout: 'fit-content',
 
-          case 'z':
-          case 'Z':
-            x = subpathStartX;
-            y = subpathStartY;
-            break;
-        }
-        bounds.forEach(function (point) {
-          aX.push(point.x);
-          aY.push(point.y);
-        });
-        aX.push(x);
-        aY.push(y);
-      }
+      /**
+       * List of properties to consider when checking if state
+       * of an object is changed (fabric.Object#hasStateChanged)
+       * as well as for history (undo/redo) purposes
+       * @type string[]
+       */
+      stateProperties: fabric.Object.prototype.stateProperties.concat('layout'),
 
-      var minX = min(aX) || 0,
-          minY = min(aY) || 0,
-          maxX = max(aX) || 0,
-          maxY = max(aY) || 0,
-          deltaX = maxX - minX,
-          deltaY = maxY - minY;
+      /**
+       * @default
+       * @override
+       */
+      fill: '',
 
-      return {
-        left: minX,
-        top: minY,
-        width: deltaX,
-        height: deltaY
-      };
-    }
-  });
+      /**
+       * @default
+       * @override
+       */
+      strokeWidth: 0,
 
-  /**
-   * Creates an instance of fabric.Path from an object
-   * @static
-   * @memberOf fabric.Path
-   * @param {Object} object
-   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
-   */
-  fabric.Path.fromObject = function(object, callback) {
-    if (typeof object.sourcePath === 'string') {
-      var pathUrl = object.sourcePath;
-      fabric.loadSVGFromURL(pathUrl, function (elements) {
-        var path = elements[0];
-        path.setOptions(object);
-        callback && callback(path);
-      });
-    }
-    else {
-      fabric.Object._fromObject('Path', object, callback, 'path');
-    }
-  };
+      /**
+       * Used to optimize performance
+       * set to `false` if you don't need objects to be interactive
+       * @default
+       * @type boolean
+       */
+      subTargetCheck: true,
 
-  /* _FROM_SVG_START_ */
-  /**
-   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
-   * @static
-   * @memberOf fabric.Path
-   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
-   */
-  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
+      /**
+       * @override
+       * @default
+       */
+      erasable: 'deep',
 
-  /**
-   * Creates an instance of fabric.Path from an SVG <path> element
-   * @static
-   * @memberOf fabric.Path
-   * @param {SVGElement} element to parse
-   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
-   * @param {Object} [options] Options object
-   * @param {Function} [callback] Options callback invoked after parsing is finished
-   */
-  fabric.Path.fromElement = function(element, callback, options) {
-    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
-    parsedAttributes.fromSVG = true;
-    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
-  };
-  /* _FROM_SVG_END_ */
+      /**
+       * Used internally to optimize performance
+       * Once an object is selected, instance is rendered without the selected object.
+       * This way instance is cached only once for the entire interaction with the selected object.
+       * @private
+       */
+      _activeObjects: undefined,
 
-})(typeof exports !== 'undefined' ? exports : this);
+      /**
+       * Constructor
+       * Guard objects' transformations from excessive mutations during initializion.
+       *
+       * @param {fabric.Object[]} [objects] instance objects
+       * @param {Object} [options] Options object
+       * @return {fabric.ICollection} thisArg
+       */
+      initialize: function (objects, options) {
+        this._objects = objects || [];
+        this._activeObjects = [];
+        this.__objectMonitor = this.__objectMonitor.bind(this);
+        this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, true);
+        this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, false);
+        this.callSuper('initialize', options);
+        this._applyLayoutStrategy({ type: 'initializion', options: options });
+        if (!this.subTargetCheck) {
+          this.ownMatrixCache.initialValue = this.calcOwnMatrix();
+        }
+        this.forEachObject(function (object) {
+          if (this.subTargetCheck) {
+            object.setCoords();
+            this._watchObject(true, object);
+          }
+          object.set('parent', this);
+        }, this);
+      },
+
+      /**
+       * @private
+       * @param {string} key
+       * @param {*} value
+       */
+      _set: function (key, value) {
+        if (key === 'subTargetCheck' && this.ownMatrixCache) {
+          //  we want to avoid setting `initialValue` during initializion
+          var initialValue = this.ownMatrixCache.initialValue;
+          if (value && initialValue) {
+            this._applyMatrixDiffToObjects(initialValue, this.calcOwnMatrix());
+            delete this.ownMatrixCache.initialValue;
+          }
+          else if (!value && !initialValue) {
+            //  we want to prevent this logic from writing over the exisitng value before it has been applied to objects
+            this.ownMatrixCache.initialValue = this.calcOwnMatrix();
+          }
+        }
+        this.callSuper('_set', key, value);
+        if (key === 'canvas') {
+          this.forEachObject(function (object) {
+            object._set(key, value);
+          });
+        }
+        if (key === 'layout') {
+          this._applyLayoutStrategy({ type: 'layout_change' });
+        }
+        if (key === 'subTargetCheck') {
+          this.forEachObject(this._watchObject.bind(this, value));
+        }
+        return this;
+      },
 
+      /**
+       * Applies the matrix diff on all objects.
+       * @private
+       * @param {number[]} from The matrix objects are curretly relating to
+       * @param {number[]} to The matrix objects should relate to
+       */
+      _applyMatrixDiffToObjects: function (from, to) {
+        var invTransform = invertTransform(from);
+        this.forEachObject(function (object) {
+          var objectTransform = multiplyTransformMatrices(invTransform, object.calcTransformMatrix());
+          applyTransformToObject(object, multiplyTransformMatrices(to, objectTransform));
+          object.setCoords();
+        });
+      },
 
-(function(global) {
+      /**
+       * Use the matrix diff to keep clip path in place after resizing instance by applying the inverted diff to it
+       * @private
+       */
+      _applyMatrixDiffToClipPath: function () {
+        var clipPath = this.clipPath;
+        if (clipPath && !clipPath.absolutePositioned
+          && this.prevMatrixCache && this.ownMatrixCache.key !== this.prevMatrixCache.key) {
+          var from = this.prevMatrixCache.cache, to = this.calcOwnMatrix();
+          var transformDiff = multiplyTransformMatrices(invertTransform(to), from);
+          applyTransformToObject(clipPath, multiplyTransformMatrices(transformDiff, clipPath.calcTransformMatrix()));
+        }
+      },
 
-  'use strict';
+      /**
+       * Compares changes made to the transform matrix and applies them to instance's objects.
+       * In other words, call this method to make the current transform the starting point of a transform diff for objects.
+       * @param {boolean} [disablePropagation] disable propagation of current transform diff to objects, preventing the existing transform diff from being applied to them unnecessarily.
+       */
+      _applyMatrixDiff: function (disablePropagation) {
+        var key = this.ownMatrixCache && this.ownMatrixCache.key;
+        if ((!this.prevMatrixCache || this.prevMatrixCache.key !== key) && this.subTargetCheck) {
+          var transform = this.calcOwnMatrix();
+          if (this.prevMatrixCache && !disablePropagation) {
+            this._applyMatrixDiffToObjects(this.prevMatrixCache.cache, transform);
+          }
+          this.prevMatrixCache = {
+            key: this.ownMatrixCache.key,
+            cache: transform
+          };
+        }
+      },
 
-  var fabric = global.fabric || (global.fabric = { }),
-      min = fabric.util.array.min,
-      max = fabric.util.array.max;
+      /**
+       * @private
+       */
+      _onBeforeObjectsChange: function () {
+        this._applyMatrixDiff();
+      },
 
-  if (fabric.Group) {
-    return;
-  }
+      add: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.add.apply(this, arguments);
+        this._onAfterObjectsChange('added', arguments);
+        return this;
+      },
 
-  /**
-   * Group class
-   * @class fabric.Group
-   * @extends fabric.Object
-   * @mixes fabric.Collection
-   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
-   * @see {@link fabric.Group#initialize} for constructor definition
-   */
-  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {
+      /**
+       * backward compatibility
+       * @deprecated 
+       */
+      addWithUpdate: function () {
+        this.add.apply(this, arguments);
+      },
 
-    /**
-     * Type of an object
-     * @type String
-     * @default
-     */
-    type: 'group',
+      insertAt: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.insertAt.apply(this, arguments);
+        this._onAfterObjectsChange('added', arguments);
+        return this;
+      },
 
-    /**
-     * Width of stroke
-     * @type Number
-     * @default
-     */
-    strokeWidth: 0,
+      remove: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.remove.apply(this, arguments);
+        this._onAfterObjectsChange('removed', arguments);
+        return this;
+      },
 
-    /**
-     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
-     * @type Boolean
-     * @default
-     */
-    subTargetCheck: false,
+      removeAll: function () {
+        this._activeObjects = [];
+        return this.remove.apply(this, this._objects);
+      },
 
-    /**
-     * Groups are container, do not render anything on theyr own, ence no cache properties
-     * @type Array
-     * @default
-     */
-    cacheProperties: [],
+      /**
+       * backward compatibility
+       * @deprecated
+       */
+      removeWithUpdate: function () {
+        this.remove.apply(this, arguments);
+      },
 
-    /**
-     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
-     * available setting this boolean to true.
-     * @type Boolean
-     * @since 2.0.0
-     * @default
-     */
-    useSetOnGroup: false,
+      /**
+       * @private
+       * @param {'added'|'removed'} type
+       */
+      _onAfterObjectsChange: function (type) {
+        this._applyLayoutStrategy({
+          type: type,
+          targets: arguments
+        });
+        this._set('dirty', true);
+      },
 
-    /**
-     * Constructor
-     * @param {Object} objects Group objects
-     * @param {Object} [options] Options object
-     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
-     * @return {Object} thisArg
-     */
-    initialize: function(objects, options, isAlreadyGrouped) {
-      options = options || {};
-      this._objects = [];
-      // if objects enclosed in a group have been grouped already,
-      // we cannot change properties of objects.
-      // Thus we need to set options to group without objects,
-      isAlreadyGrouped && this.callSuper('initialize', options);
-      this._objects = objects || [];
-      for (var i = this._objects.length; i--; ) {
-        this._objects[i].group = this;
-      }
+      /**
+       * invalidates layout on object modified
+       * @private
+       */
+      __objectMonitor: function (opt) {
+        this._applyLayoutStrategy(extend(clone(opt), {
+          type: 'object_modified'
+        }));
+        this._set('dirty', true);
+      },
 
-      if (!isAlreadyGrouped) {
-        var center = options && options.centerPoint;
-        // we want to set origins before calculating the bounding box.
-        // so that the topleft can be set with that in mind.
-        // if specific top and left are passed, are overwritten later
-        // with the callSuper('initialize', options)
-        if (options.originX !== undefined) {
-          this.originX = options.originX;
+      /**
+       * keeps track of the selected objects
+       * @private
+       */
+      __objectSelectionMonitor: function (selected, opt) {
+        var object = opt.target;
+        if (selected) {
+          this._activeObjects.push(object);
+          this._set('dirty', true);
+        }
+        else if (this._activeObjects.length > 0) {
+          var index = this._activeObjects.indexOf(object);
+          if (index > -1) {
+            this._activeObjects.splice(index, 1);
+            this._set('dirty', true);
+          }
         }
-        if (options.originY !== undefined) {
-          this.originY = options.originY;
+      },
+
+      /**
+       * @private
+       * @param {boolean} watch
+       * @param {fabric.Object} object
+       */
+      _watchObject: function (watch, object) {
+        var directive = watch ? 'on' : 'off';
+        object[directive]('modified', this.__objectMonitor);
+        object[directive]('selected', this.__objectSelectionTracker);
+        object[directive]('deselected', this.__objectSelectionDisposer);
+      },
+
+      /**
+       * @private
+       * @param {fabric.Object} object
+       */
+      _onObjectAdded: function (object) {
+        object._set('parent', this);
+        object._set('canvas', this.canvas);
+        this._watchObject(true, object);
+        object.fire('added', { target: this });
+        var activeObject = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
+        if (activeObject && (activeObject === object || object.isDescendantOf(activeObject))) {
+          this._activeObjects.push(true);
         }
-        // if coming from svg i do not want to calc bounds.
-        // i assume width and height are passed along options
-        center || this._calcBounds();
-        this._updateObjectsCoords(center);
-        delete options.centerPoint;
-        this.callSuper('initialize', options);
-      }
-      else {
-        this._updateObjectsACoords();
-      }
+      },
 
-      this.setCoords();
-    },
+      /**
+       * @private
+       * @param {fabric.Object} object
+       */
+      _onObjectRemoved: function (object) {
+        delete object.canvas;
+        delete object.parent;
+        this._watchObject(false, object);
+        object.fire('removed', { target: this });
+        var index = this._activeObjects.length > 0 ? this._activeObjects.indexOf(object) : -1;
+        if (index > -1) {
+          this._activeObjects.splice(index, 1);
+        }
+      },
 
-    /**
-     * @private
-     */
-    _updateObjectsACoords: function() {
-      var skipControls = true;
-      for (var i = this._objects.length; i--; ){
-        this._objects[i].setCoords(skipControls);
-      }
-    },
+      /**
+       *
+       * @param {object} opt
+       * @param {fabric.Object[]} opt.subTargets
+       * @returns true to abort selection, a `subTarget` to select that or false to defer to default behavior and allow selection to take place
+       */
+      onSelect: function (opt) {
+        return this.callSuper('onSelect', opt) || (opt.subTargets && opt.subTargets.length > 0 && opt.subTargets[0]);
+      },
 
-    /**
-     * @private
-     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
-     */
-    _updateObjectsCoords: function(center) {
-      var center = center || this.getCenterPoint();
-      for (var i = this._objects.length; i--; ){
-        this._updateObjectCoords(this._objects[i], center);
-      }
-    },
+      /**
+       * Check if instance or its parent are caching, recursively up
+       * @return {Boolean}
+       */
+      isOnACache: function () {
+        return this.ownCaching || (!!this.parent && this.parent.isOnACache());
+      },
 
-    /**
-     * @private
-     * @param {Object} object
-     * @param {fabric.Point} center, current center of group.
-     */
-    _updateObjectCoords: function(object, center) {
-      var objectLeft = object.left,
-          objectTop = object.top,
-          skipControls = true;
+      /**
+       * hook used to apply matrix diff on objects
+       * @override
+       * @param {boolean} [skipCanvas]
+       * @returns {boolean}
+       */
+      isCacheDirty: function (skipCanvas) {
+        //  apply matrix diff before deciding if cache isn't dirty
+        this._applyMatrixDiff();
+        if (this.callSuper('isCacheDirty', skipCanvas)) {
+          return true;
+        }
+        if (!this.statefullCache) {
+          return false;
+        }
+        return this._objects.some(function (object) {
+          return object.isCacheDirty(true);
+        });
+      },
 
-      object.set({
-        left: objectLeft - center.x,
-        top: objectTop - center.y
-      });
-      object.group = this;
-      object.setCoords(skipControls);
-    },
+      /**
+       * hook used to apply matrix diff on objects
+       */
+      setCoords: function () {
+        this._applyMatrixDiff();
+        this.callSuper('setCoords');
+      },
 
-    /**
-     * Returns string represenation of a group
-     * @return {String}
-     */
-    toString: function() {
-      return '#<fabric.Group: (' + this.complexity() + ')>';
-    },
+      /**
+       * Renders instance on a given context
+       * @param {CanvasRenderingContext2D} ctx context to render instance on
+       */
+      render: function (ctx) {
+        //  used to inform objects not to double opacity
+        this._transformDone = true;
+        this.callSuper('render', ctx);
+        this._transformDone = false;
+      },
 
-    /**
-     * Adds an object to a group; Then recalculates group's dimension, position.
-     * @param {Object} object
-     * @return {fabric.Group} thisArg
-     * @chainable
-     */
-    addWithUpdate: function(object) {
-      var nested = !!this.group;
-      this._restoreObjectsState();
-      fabric.util.resetObjectTransform(this);
-      if (object) {
-        if (nested) {
-          // if this group is inside another group, we need to pre transform the object
-          fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());
-        }
-        this._objects.push(object);
-        object.group = this;
-        object._set('canvas', this.canvas);
-      }
-      this._calcBounds();
-      this._updateObjectsCoords();
-      this.dirty = true;
-      if (nested) {
-        this.group.addWithUpdate();
-      }
-      else {
-        this.setCoords();
-      }
-      return this;
-    },
+      /**
+       * If `subTargetCheck === true` we transform `ctx` back to canvas plane, objects are up to date with the latest diff
+       * otherwise we transform ctx back to canvas plane by applying the initial matrix, objects relating accordingly
+       *
+       * Performance optimizations:
+       *
+       * **`subTargetCheck === false`**:
+       * In case we don't need instance to be interactive (selectable objects etc.) we don't apply the transform diff to the objects in order to minimize the number of iterations.
+       * We transform the entire ctx with the diff instead.
+       * We store the initial value of the transform matrix to do so, leaving objects as they were when the initial value was stored, rather than updating them continueously.
+       * This means that objects will render correctly on screen, **BUT** that's it. All geometry methods will **NOT WORK**.
+       * This optimization is crucial for an instance that contains a very large amount of objects.
+       * In case you need to select objects toggle `subTargetCheck` accordingly.
+       *
+       * **caching and selection**:
+       * Once an object is selected, instance is rendered without the selected object.
+       * This way instance is cached only once for the entire interaction with the selected object.
+       *
+       * @private
+       * @param {CanvasRenderingContext2D} ctx Context to render on
+       */
+      _render: function (ctx) {
+        ctx.save();
+        var t = this.subTargetCheck ? this.calcTransformMatrix() : this.ownMatrixCache.initialValue;
+        ctx.transform.apply(ctx, invertTransform(t));
+        this._renderObjects(ctx);
+        ctx.restore();
+      },
 
-    /**
-     * Removes an object from a group; Then recalculates group's dimension, position.
-     * @param {Object} object
-     * @return {fabric.Group} thisArg
-     * @chainable
-     */
-    removeWithUpdate: function(object) {
-      this._restoreObjectsState();
-      fabric.util.resetObjectTransform(this);
+      /**
+       * **Performance optimization**:
+       * render only non-selected objects,
+       * canvas is in charge of rendering the selected objects
+       * @private
+       * @param {CanvasRenderingContext2D} ctx Context to render on
+       */
+      _renderObjects: function (ctx) {
+        this.forEachObject(function (object) {
+          if (this._activeObjects.length === 0 || this._activeObjects.indexOf(object) === -1) {
+            object.render(ctx);
+          }
+        }, this);
+      },
 
-      this.remove(object);
-      this._calcBounds();
-      this._updateObjectsCoords();
-      this.setCoords();
-      this.dirty = true;
-      return this;
-    },
+      /**
+       * @private
+       * @param {object} context see `getLayoutStrategyResult`
+       */
+      _applyLayoutStrategy: function (context) {
+        var result = this.getLayoutStrategyResult(this.layout, this._objects, context);
+        if (!result) {
+          return;
+        }
+        this.set({ width: result.width, height: result.height });
+        this.setPositionByOrigin(new fabric.Point(result.x, result.y), result.originX, result.originY);
+        //  refresh matrix cache
+        this.calcOwnMatrix();
+        //  keep clip path in place
+        this._applyMatrixDiffToClipPath();
+        //  set diff point without changing objects matrices
+        this._applyMatrixDiff(true);
+        //  make sure coords are up to date
+        context.type !== 'initialization' && this.callSuper('setCoords');
+        //  fire layout hook
+        this.onLayout(context, result);
+        //  recursive up
+        if (this.parent && this.parent._applyLayoutStrategy) {
+          //  append the path recursion to context
+          if (!context.path) {
+            context.path = [];
+          }
+          context.path.push(this);
+          //  all parents should invalidate their layout
+          this.parent._applyLayoutStrategy(context);
+        }
+      },
 
-    /**
-     * @private
-     */
-    _onObjectAdded: function(object) {
-      this.dirty = true;
-      object.group = this;
-      object._set('canvas', this.canvas);
-    },
+      /**
+       * Override this method to customize layout.
+       * If you need to run logic once layout completes use `onLayout`
+       * @public
+       * @param {string} layoutDirective
+       * @param {fabric.Object[]} objects
+       * @param {object} context object with data regarding what triggered the call
+       * @param {'initializion'|'object_modified'|'added'|'removed'|'layout_change'} context.type
+       * @param {fabric.Object[]} context.path array of objects starting from the object that triggered the call to the current one
+       * @returns {Object} options object
+       */
+      getLayoutStrategyResult: function (layoutDirective, objects, context) {  // eslint-disable-line no-unused-vars
+        if (layoutDirective === 'fit-content') {
+          return this.getObjectsBoundingBox(objects);
+        }
+        else if (layoutDirective === 'fixed' && context.type === 'initializion') {
+          var bbox = this.getObjectsBoundingBox(objects),
+              hasX = typeof context.options.left === 'number',
+              hasY = typeof context.options.top === 'number';
+          return {
+            x: hasX ? this.left : bbox.left,
+            y: hasY ? this.top : bbox.top,
+            width: this.width || bbox.width,
+            height: this.height || bbox.height,
+            originX: hasX ? this.originX : 'center',
+            originY: hasY ? this.originY : 'center'
+          };
+        }
+      },
 
-    /**
-     * @private
-     */
-    _onObjectRemoved: function(object) {
-      this.dirty = true;
-      delete object.group;
-    },
+      /**
+       * Hook that is called once layout has completed.
+       * Provided for layout customization, override if necessary.
+       * Complements `getLayoutStrategyResult`, which is called at the beginning of layout.
+       * @public
+       * @param {*} context layout context
+       * @param {Object} result layout result
+       */
+      onLayout: function () {
+        //  override by subclass
+      },
 
-    /**
-     * @private
-     */
-    _set: function(key, value) {
-      var i = this._objects.length;
-      if (this.useSetOnGroup) {
-        while (i--) {
-          this._objects[i].setOnGroup(key, value);
+      /**
+       * @todo support instance rotation
+       * @public
+       * @param {fabric.Object[]} objects
+       * @returns
+       */
+      getObjectsBoundingBox: function (objects) {
+        if (objects.length === 0) {
+          return {};
         }
-      }
-      if (key === 'canvas') {
-        while (i--) {
-          this._objects[i]._set(key, value);
+        var coords = [];
+        for (var i = 0, o; i < objects.length; ++i) {
+          o = objects[i];
+          coords.push.apply(coords, o.getCoords(true, true));
         }
-      }
-      fabric.Object.prototype._set.call(this, key, value);
-    },
-
-    /**
-     * Returns object representation of an instance
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
-     */
-    toObject: function(propertiesToInclude) {
-      var _includeDefaultValues = this.includeDefaultValues;
-      var objsToObject = this._objects
-        .filter(function (obj) {
-          return !obj.excludeFromExport;
-        })
-        .map(function (obj) {
-          var originalDefaults = obj.includeDefaultValues;
-          obj.includeDefaultValues = _includeDefaultValues;
-          var _obj = obj.toObject(propertiesToInclude);
-          obj.includeDefaultValues = originalDefaults;
-          return _obj;
-        });
-      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
-      obj.objects = objsToObject;
-      return obj;
-    },
+        var bounds = coords.reduce(function (acc, point) {
+          return {
+            min: {
+              x: Math.min(acc.min.x, point.x),
+              y: Math.min(acc.min.y, point.y)
+            },
+            max: {
+              x: Math.max(acc.max.x, point.x),
+              y: Math.max(acc.max.y, point.y)
+            }
+          };
+        }, { min: coords[0], max: coords[0] });
+        var center = new fabric.Point(bounds.min.x, bounds.min.y).midPointFrom(bounds.max),
+            width = (bounds.max.x - bounds.min.x) / (this.scaleX || 1),
+            height = (bounds.max.y - bounds.min.y) / (this.scaleY || 1),
+            rad = fabric.util.degreesToRadians(this.angle || 0),
+            cos = Math.abs(Math.cos(rad)),
+            sin = Math.abs(Math.sin(rad));
+        return {
+          x: center.x,
+          y: center.y,
+          width: width * cos + height * sin,
+          height: width * sin + height * cos,
+          originX: 'center',
+          originY: 'center'
+        };
+      },
 
-    /**
-     * Returns object representation of an instance, in dataless mode.
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
-     */
-    toDatalessObject: function(propertiesToInclude) {
-      var objsToObject, sourcePath = this.sourcePath;
-      if (sourcePath) {
-        objsToObject = sourcePath;
-      }
-      else {
+      /**
+       *
+       * @private
+       * @param {'toObject'|'toDatalessObject'} [method]
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @returns {Object[]} serialized objects
+       */
+      __serializeObjects: function (method, propertiesToInclude) {
         var _includeDefaultValues = this.includeDefaultValues;
-        objsToObject = this._objects.map(function(obj) {
-          var originalDefaults = obj.includeDefaultValues;
-          obj.includeDefaultValues = _includeDefaultValues;
-          var _obj = obj.toDatalessObject(propertiesToInclude);
-          obj.includeDefaultValues = originalDefaults;
-          return _obj;
-        });
-      }
-      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
-      obj.objects = objsToObject;
-      return obj;
-    },
+        return this._objects
+          .filter(function (obj) {
+            return !obj.excludeFromExport;
+          })
+          .map(function (obj) {
+            var originalDefaults = obj.includeDefaultValues;
+            obj.includeDefaultValues = _includeDefaultValues;
+            var data = obj[method || 'toObject'](propertiesToInclude);
+            obj.includeDefaultValues = originalDefaults;
+            delete data.version;
+            return data;
+          });
+      },
 
-    /**
-     * Renders instance on a given context
-     * @param {CanvasRenderingContext2D} ctx context to render instance on
-     */
-    render: function(ctx) {
-      this._transformDone = true;
-      this.callSuper('render', ctx);
-      this._transformDone = false;
-    },
+      /**
+       * Returns object representation of an instance
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @return {Object} object representation of an instance
+       */
+      toObject: function (propertiesToInclude) {
+        var obj = fabric.Object.prototype.toObject.call(this, ['layout'].concat(propertiesToInclude));
+        obj.objects = this.__serializeObjects('toObject', propertiesToInclude);
+        return obj;
+      },
 
-    /**
-     * Decide if the object should cache or not. Create its own cache level
-     * needsItsOwnCache should be used when the object drawing method requires
-     * a cache step. None of the fabric classes requires it.
-     * Generally you do not cache objects in groups because the group is already cached.
-     * @return {Boolean}
-     */
-    shouldCache: function() {
-      var ownCache = fabric.Object.prototype.shouldCache.call(this);
-      if (ownCache) {
+      /**
+       * Returns object representation of an instance, in dataless mode.
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @return {Object} object representation of an instance
+       */
+      toDatalessObject: function (propertiesToInclude) {
+        var obj = fabric.Object.prototype.toDatalessObject.call(this, ['layout'].propertiesToInclude);
+        obj.objects = this.sourcePath || this.__serializeObjects('toDatalessObject', propertiesToInclude);
+        return obj;
+      },
+
+      toString: function () {
+        return '#<fabric.ICollection: (' + this.complexity() + ')>';
+      },
+
+      dispose: function () {
+        this._activeObjects = [];
+        this.forEachObject(function (object) {
+          this._watchObject(false, object);
+          object.dispose && object.dispose();
+        }, this);
+      },
+
+      /* _TO_SVG_START_ */
+
+      /**
+       * Returns svg representation of an instance
+       * @param {Function} [reviver] Method for further parsing of svg representation.
+       * @return {String} svg representation of an instance
+       */
+      _toSVG: function (reviver) {
+        var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];
+        //  in case there's an unapplied matrix diff (`subTargetCheck = false`) we need to use `ownMatrixCache.initialValue`
+        var t = invertTransform(this.ownMatrixCache.initialValue || this.calcTransformMatrix());
+        svgString.push('<g ', 'transform="', fabric.util.matrixToSVG(t), '">\n');
         for (var i = 0, len = this._objects.length; i < len; i++) {
-          if (this._objects[i].willDrawShadow()) {
-            this.ownCaching = false;
-            return false;
-          }
+          svgString.push('\t\t', this._objects[i].toSVG(reviver));
         }
-      }
-      return ownCache;
-    },
+        svgString.push('</g>\n', '</g>\n');
+        return svgString;
+      },
 
-    /**
-     * Check if this object or a child object will cast a shadow
-     * @return {Boolean}
-     */
-    willDrawShadow: function() {
-      if (fabric.Object.prototype.willDrawShadow.call(this)) {
-        return true;
-      }
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        if (this._objects[i].willDrawShadow()) {
-          return true;
+      /**
+       * Returns svg clipPath representation of an instance
+       * @param {Function} [reviver] Method for further parsing of svg representation.
+       * @return {String} svg representation of an instance
+       */
+      toClipPathSVG: function (reviver) {
+        var svgString = [];
+        for (var i = 0, len = this._objects.length; i < len; i++) {
+          svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
         }
-      }
-      return false;
-    },
+        return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
+      },
+      /* _TO_SVG_END_ */
+    });
 
-    /**
-     * Check if this group or its parent group are caching, recursively up
-     * @return {Boolean}
-     */
-    isOnACache: function() {
-      return this.ownCaching || (this.group && this.group.isOnACache());
-    },
+  /**
+   * @todo support loading from svg
+   * @private
+   * @static
+   * @memberOf fabric.ICollection
+   * @param {Object} object Object to create an instance from
+   * @param {(objects: fabric.Object[], options?: Object) => any} [callback]
+   */
+  fabric.ICollection._fromObject = function (object, callback) {
+    var objects = object.objects,
+        options = clone(object, true);
+    delete options.objects;
+    if (typeof objects === 'string') {
+      // it has to be a url or something went wrong.
+      fabric.loadSVGFromURL(objects, function (elements) {
+        options = fabric.util.getOptionsFromSVG(elements, object, objects);
+        callback && callback(elements, options);
+      });
+      return;
+    }
+    fabric.util.enlivenObjects(objects, function (enlivenedObjects) {
+      fabric.util.enlivenObjects([object.clipPath], function (enlivedClipPath) {
+        var options = clone(object, true);
+        options.clipPath = enlivedClipPath[0];
+        delete options.objects;
+        callback && callback(enlivenedObjects, options);
+      });
+    });
+  };
 
-    /**
-     * Execute the drawing operation for an object on a specified context
-     * @param {CanvasRenderingContext2D} ctx Context to render on
-     */
-    drawObject: function(ctx) {
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        this._objects[i].render(ctx);
-      }
-      this._drawClipPath(ctx);
-    },
+  /**
+   * Returns fabric.ICollection instance from an object representation
+   * @static
+   * @memberOf fabric.ICollection
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   */
+  fabric.ICollection.fromObject = function (object, callback) {
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.ICollection(objects, options));
+    });
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
+
+
+(function (global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = {});
+
+  if (fabric.Layer) {
+    fabric.warn('fabric.Layer is already defined');
+    return;
+  }
+
+  /**
+   * Layer class
+   * @class fabric.Layer
+   * @extends fabric.Object
+   * @mixes fabric.Collection
+   * @see {@link fabric.Layer#initialize} for constructor definition
+   */
+  fabric.Layer = fabric.util.createClass(fabric.ICollection, /** @lends fabric.ICollection.prototype */ {
 
     /**
-     * Check if cache is dirty
-     */
-    isCacheDirty: function(skipCanvas) {
-      if (this.callSuper('isCacheDirty', skipCanvas)) {
-        return true;
-      }
-      if (!this.statefullCache) {
-        return false;
-      }
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        if (this._objects[i].isCacheDirty(true)) {
-          if (this._cacheCanvas) {
-            // if this group has not a cache canvas there is nothing to clean
-            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
-            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
-          }
-          return true;
-        }
-      }
-      return false;
-    },
+     * @default
+     * @type string
+     */
+    type: 'layer',
 
     /**
-     * Restores original state of each of group objects (original state is that which was before group was created).
-     * if the nested boolean is true, the original state will be restored just for the
-     * first group and not for all the group chain
-     * @private
-     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more
-     * @return {fabric.Group} thisArg
-     * @chainable
+     * @override
+     * @default
      */
-    _restoreObjectsState: function() {
-      var groupMatrix = this.calcOwnMatrix();
-      this._objects.forEach(function(object) {
-        // instead of using _this = this;
-        fabric.util.addTransformToObject(object, groupMatrix);
-        delete object.group;
-        object.setCoords();
-      });
-      return this;
-    },
+    layout: 'auto',
 
     /**
-     * Realises the transform from this group onto the supplied object
-     * i.e. it tells you what would happen if the supplied object was in
-     * the group, and then the group was destroyed. It mutates the supplied
-     * object.
-     * Warning: this method is not useful anymore, it has been kept to no break the api.
-     * is not used in the fabricJS codebase
-     * this method will be reduced to using the utility.
-     * @private
-     * @deprecated
-     * @param {fabric.Object} object
-     * @param {Array} parentMatrix parent transformation
-     * @return {fabric.Object} transformedObject
+     * @override
+     * @default
      */
-    realizeTransform: function(object, parentMatrix) {
-      fabric.util.addTransformToObject(object, parentMatrix);
-      return object;
-    },
+    objectCaching: false,
 
     /**
-     * Destroys a group (restoring state of its objects)
-     * @return {fabric.Group} thisArg
-     * @chainable
+     * @override
+     * @default
      */
-    destroy: function() {
-      // when group is destroyed objects needs to get a repaint to be eventually
-      // displayed on canvas.
-      this._objects.forEach(function(object) {
-        object.set('dirty', true);
-      });
-      return this._restoreObjectsState();
-    },
+    strokeWidth: 0,
 
     /**
-     * make a group an active selection, remove the group from canvas
-     * the group has to be on canvas for this to work.
-     * @return {fabric.ActiveSelection} thisArg
-     * @chainable
+     * @override
+     * @default
      */
-    toActiveSelection: function() {
-      if (!this.canvas) {
-        return;
-      }
-      var objects = this._objects, canvas = this.canvas;
-      this._objects = [];
-      var options = this.toObject();
-      delete options.objects;
-      var activeSelection = new fabric.ActiveSelection([]);
-      activeSelection.set(options);
-      activeSelection.type = 'activeSelection';
-      canvas.remove(this);
-      objects.forEach(function(object) {
-        object.group = activeSelection;
-        object.dirty = true;
-        canvas.add(object);
-      });
-      activeSelection.canvas = canvas;
-      activeSelection._objects = objects;
-      canvas._activeObject = activeSelection;
-      activeSelection.setCoords();
-      return activeSelection;
-    },
+    hasControls: false,
 
     /**
-     * Destroys a group (restoring state of its objects)
-     * @return {fabric.Group} thisArg
-     * @chainable
+     * @override
+     * @default
      */
-    ungroupOnCanvas: function() {
-      return this._restoreObjectsState();
-    },
+    hasBorders: false,
 
     /**
-     * Sets coordinates of all objects inside group
-     * @return {fabric.Group} thisArg
-     * @chainable
+     * @override
+     * @default
      */
-    setObjectsCoords: function() {
-      var skipControls = true;
-      this.forEachObject(function(object) {
-        object.setCoords(skipControls);
-      });
-      return this;
-    },
+    lockMovementX: true,
 
     /**
-     * @private
+     * @override
+     * @default
      */
-    _calcBounds: function(onlyWidthHeight) {
-      var aX = [],
-          aY = [],
-          o, prop, coords,
-          props = ['tr', 'br', 'bl', 'tl'],
-          i = 0, iLen = this._objects.length,
-          j, jLen = props.length;
+    lockMovementY: true,
 
-      for ( ; i < iLen; ++i) {
-        o = this._objects[i];
-        coords = o.calcACoords();
-        for (j = 0; j < jLen; j++) {
-          prop = props[j];
-          aX.push(coords[prop].x);
-          aY.push(coords[prop].y);
+    /**
+     * Constructor
+     *
+     * @param {fabric.Object[]} [objects] instance objects
+     * @param {Object} [options] Options object
+     * @return {fabric.ICollection} thisArg
+     */
+    initialize: function (objects, options) {
+      this.callSuper('initialize', objects, options);
+      this.__canvasMonitor = this.__canvasMonitor.bind(this);
+    },
+
+    /**
+     * 
+     * @param {string} key 
+     * @param {*} value 
+     */
+    _set: function (key, value) {
+      var settingCanvas = key === 'canvas';
+      if (settingCanvas) {
+        if (!value && this.canvas) {
+          //  detach canvas resize handler
+          this.canvas.off('resize', this.__canvasMonitor);
+        }
+        else if (value && (!this.canvas || this.canvas !== value)) {
+          //  attach canvas resize handler, make sure we listen to the resize event only once
+          this.canvas && this.canvas.off('resize', this.__canvasMonitor);
+          value.off('resize', this.__canvasMonitor);
+          value.on('resize', this.__canvasMonitor);
         }
-        o.aCoords = coords;
       }
-
-      this._getBounds(aX, aY, onlyWidthHeight);
+      this.callSuper('_set', key, value);
+      //  apply layout after canvas is set
+      if (settingCanvas) {
+        this._applyLayoutStrategy({ type: 'canvas' });
+      }
     },
 
     /**
+     * used by canvas' active object logic to determine `subTargets`
      * @private
+     * @memberOf fabric.Object.prototype
+     * @returns {boolean}
      */
-    _getBounds: function(aX, aY, onlyWidthHeight) {
-      var minXY = new fabric.Point(min(aX), min(aY)),
-          maxXY = new fabric.Point(max(aX), max(aY)),
-          top = minXY.y || 0, left = minXY.x || 0,
-          width = (maxXY.x - minXY.x) || 0,
-          height = (maxXY.y - minXY.y) || 0;
-      this.width = width;
-      this.height = height;
-      if (!onlyWidthHeight) {
-        // the bounding box always finds the topleft most corner.
-        // whatever is the group origin, we set up here the left/top position.
-        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
-      }
+    isSelectable: function () {
+      return false;
     },
 
-    /* _TO_SVG_START_ */
     /**
-     * Returns svg representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * we do not need to invalidate layout because layer fills the entire canvas
+     * @override
+     * @private
      */
-    _toSVG: function(reviver) {
-      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];
-
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        svgString.push('\t\t', this._objects[i].toSVG(reviver));
-      }
-      svgString.push('</g>\n');
-      return svgString;
+    __objectMonitor: function () {
+      //  noop
     },
 
     /**
-     * Returns styles-string for svg-export, specific version for group
-     * @return {String}
+     * @private
      */
-    getSvgStyles: function() {
-      var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
-            'opacity: ' + this.opacity + ';' : '',
-          visibility = this.visible ? '' : ' visibility: hidden;';
-      return [
-        opacity,
-        this.getSvgFilter(),
-        visibility
-      ].join('');
+    __canvasMonitor: function () {
+      this._applyLayoutStrategy({ type: 'canvas_resize' });
     },
 
     /**
-     * Returns svg clipPath representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * Override this method to customize layout
+     * @public
+     * @param {string} layoutDirective
+     * @param {fabric.Object[]} objects
+     * @param {object} context object with data regarding what triggered the call
+     * @param {'initializion'|'canvas'|'canvas_resize'|'layout_change'} context.type
+     * @param {fabric.Object[]} context.path array of objects starting from the object that triggered the call to the current one
+     * @returns {Object} options object
      */
-    toClipPathSVG: function(reviver) {
-      var svgString = [];
-
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
+    getLayoutStrategyResult: function (layoutDirective, objects, context) {  // eslint-disable-line no-unused-vars
+      if ((context.type === 'canvas' || context.type === 'canvas_resize') && this.canvas) {
+        return {
+          x: 0,
+          y: 0,
+          originX: 'left',
+          originY: 'top',
+          width: this.canvas.width,
+          height: this.canvas.height
+        };
       }
+    },
 
-      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
+    toString: function () {
+      return '#<fabric.Layer: (' + this.complexity() + ')>';
     },
-    /* _TO_SVG_END_ */
+
   });
 
   /**
-   * Returns {@link fabric.Group} instance from an object representation
+   * Returns fabric.Layer instance from an object representation
    * @static
-   * @memberOf fabric.Group
-   * @param {Object} object Object to create a group from
-   * @param {Function} [callback] Callback to invoke when an group instance is created
+   * @memberOf fabric.Layer
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
    */
-  fabric.Group.fromObject = function(object, callback) {
-    var objects = object.objects,
-        options = fabric.util.object.clone(object, true);
-    delete options.objects;
-    if (typeof objects === 'string') {
-      // it has to be an url or something went wrong.
-      fabric.loadSVGFromURL(objects, function (elements) {
-        var group = fabric.util.groupSVGElements(elements, object, objects);
-        group.set(options);
-        callback && callback(group);
-      });
-      return;
-    }
-    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
-      fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
-        var options = fabric.util.object.clone(object, true);
-        options.clipPath = enlivedClipPath[0];
-        delete options.objects;
-        callback && callback(new fabric.Group(enlivenedObjects, options, true));
-      });
+  fabric.Layer.fromObject = function (object, callback) {
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.Layer(objects, options));
     });
   };
 
@@ -20351,110 +23910,39 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
 
   /**
    * Group class
-   * @class fabric.ActiveSelection
-   * @extends fabric.Group
-   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
-   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
-   */
-  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {
-
-    /**
-     * Type of an object
-     * @type String
-     * @default
-     */
-    type: 'activeSelection',
-
-    /**
-     * Constructor
-     * @param {Object} objects ActiveSelection objects
-     * @param {Object} [options] Options object
-     * @return {Object} thisArg
-     */
-    initialize: function(objects, options) {
-      options = options || {};
-      this._objects = objects || [];
-      for (var i = this._objects.length; i--; ) {
-        this._objects[i].group = this;
-      }
-
-      if (options.originX) {
-        this.originX = options.originX;
-      }
-      if (options.originY) {
-        this.originY = options.originY;
-      }
-      this._calcBounds();
-      this._updateObjectsCoords();
-      fabric.Object.prototype.initialize.call(this, options);
-      this.setCoords();
-    },
-
-    /**
-     * Change te activeSelection to a normal group,
-     * High level function that automatically adds it to canvas as
-     * active object. no events fired.
-     * @since 2.0.0
-     * @return {fabric.Group}
-     */
-    toGroup: function() {
-      var objects = this._objects.concat();
-      this._objects = [];
-      var options = fabric.Object.prototype.toObject.call(this);
-      var newGroup = new fabric.Group([]);
-      delete options.type;
-      newGroup.set(options);
-      objects.forEach(function(object) {
-        object.canvas.remove(object);
-        object.group = newGroup;
-      });
-      newGroup._objects = objects;
-      if (!this.canvas) {
-        return newGroup;
-      }
-      var canvas = this.canvas;
-      canvas.add(newGroup);
-      canvas._activeObject = newGroup;
-      newGroup.setCoords();
-      return newGroup;
-    },
+   * @class fabric.ActiveSelection
+   * @extends fabric.Group
+   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
+   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
+   */
+  fabric.ActiveSelection = fabric.util.createClass(fabric.ICollection, /** @lends fabric.ActiveSelection.prototype */ {
 
     /**
-     * If returns true, deselection is cancelled.
-     * @since 2.0.0
-     * @return {Boolean} [cancel]
+     * Type of an object
+     * @type String
+     * @default
      */
-    onDeselect: function() {
-      this.destroy();
-      return false;
-    },
+    type: 'activeSelection',
 
-    /**
-     * Returns string representation of a group
-     * @return {String}
-     */
-    toString: function() {
-      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
-    },
+    objectCaching: false,
 
     /**
-     * Decide if the object should cache or not. Create its own cache level
-     * objectCaching is a global flag, wins over everything
-     * needsItsOwnCache should be used when the object drawing method requires
-     * a cache step. None of the fabric classes requires it.
-     * Generally you do not cache objects in groups because the group outside is cached.
-     * @return {Boolean}
+     * @override we want instance to render selected objects
+     * @private
      */
-    shouldCache: function() {
-      return false;
+    __objectSelectionMonitor: function () {
+      //  disabled
     },
 
     /**
-     * Check if this group or its parent group are caching, recursively up
-     * @return {Boolean}
+     * @private
+     * @override
+     * @param {fabric.Object} object
      */
-    isOnACache: function() {
-      return false;
+    _onObjectRemoved: function (object) {
+      delete object.parent;
+      this._watchObject(false, object);
+      object.fire('removed', { target: this });
     },
 
     /**
@@ -20463,20 +23951,28 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
      * @param {Object} [styleOverride] properties to override the object style
      * @param {Object} [childrenOverride] properties to override the children overrides
      */
-    _renderControls: function(ctx, styleOverride, childrenOverride) {
+    _renderControls: function (ctx, styleOverride, childrenOverride) {
       ctx.save();
       ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
       this.callSuper('_renderControls', ctx, styleOverride);
-      childrenOverride = childrenOverride || { };
+      childrenOverride = childrenOverride || {};
       if (typeof childrenOverride.hasControls === 'undefined') {
         childrenOverride.hasControls = false;
       }
       childrenOverride.forActiveSelection = true;
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        this._objects[i]._renderControls(ctx, childrenOverride);
-      }
+      this.forEachObject(function (object) {
+        object._renderControls(ctx, childrenOverride);
+      });
       ctx.restore();
     },
+
+    /**
+     * Returns string representation of a group
+     * @return {String}
+     */
+    toString: function() {
+      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
+    }
   });
 
   /**
@@ -20487,9 +23983,8 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
    */
   fabric.ActiveSelection.fromObject = function(object, callback) {
-    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
-      delete object.objects;
-      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.ActiveSelection(objects, options));
     });
   };
 
@@ -25511,7 +29006,7 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
   var additionalProps =
     ('fontFamily fontWeight fontSize text underline overline linethrough' +
     ' textAlign fontStyle lineHeight textBackgroundColor charSpacing styles' +
-    ' direction path pathStartOffset pathSide').split(' ');
+    ' direction path pathStartOffset pathSide pathAlign').split(' ');
 
   /**
    * Text class
@@ -25540,7 +29035,8 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
       'styles',
       'path',
       'pathStartOffset',
-      'pathSide'
+      'pathSide',
+      'pathAlign'
     ],
 
     /**
@@ -25737,6 +29233,16 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
      */
     pathSide:               'left',
 
+    /**
+     * How text is aligned to the path. This property determines
+     * the perpendicular position of each character relative to the path.
+     * (one of "baseline", "center", "ascender", "descender")
+     * This feature is in BETA, and its behavior may change
+     * @type String
+     * @default
+     */
+    pathAlign:               'baseline',
+
     /**
      * @private
      */
@@ -25880,6 +29386,8 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
     /**
      * Return a context for measurement of text string.
      * if created it gets stored for reuse
+     * this is for internal use, please do not use it
+     * @private
      * @param {String} text Text string
      * @param {Object} [options] Options object
      * @return {fabric.Text} thisArg
@@ -26051,7 +29559,20 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
      * @param {String} [charStyle.fontStyle] Font style (italic|normal)
      */
     _setTextStyles: function(ctx, charStyle, forMeasuring) {
-      ctx.textBaseline = 'alphabetic';
+      ctx.textBaseline = 'alphabetical';
+      if (this.path) {
+        switch (this.pathAlign) {
+          case 'center':
+            ctx.textBaseline = 'middle';
+            break;
+          case 'ascender':
+            ctx.textBaseline = 'top';
+            break;
+          case 'descender':
+            ctx.textBaseline = 'bottom';
+            break;
+        }
+      }
       ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
     },
 
@@ -28934,1852 +32455,2679 @@ fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
       }
     },
 
-    /**
-     * Set the selectionStart and selectionEnd according to the new position of cursor
-     * mimic the key - mouse navigation when shift is pressed.
-     */
-    setSelectionStartEndWithShift: function(start, end, newSelection) {
-      if (newSelection <= start) {
-        if (end === start) {
-          this._selectionDirection = 'left';
-        }
-        else if (this._selectionDirection === 'right') {
-          this._selectionDirection = 'left';
-          this.selectionEnd = start;
-        }
-        this.selectionStart = newSelection;
+    /**
+     * Set the selectionStart and selectionEnd according to the new position of cursor
+     * mimic the key - mouse navigation when shift is pressed.
+     */
+    setSelectionStartEndWithShift: function(start, end, newSelection) {
+      if (newSelection <= start) {
+        if (end === start) {
+          this._selectionDirection = 'left';
+        }
+        else if (this._selectionDirection === 'right') {
+          this._selectionDirection = 'left';
+          this.selectionEnd = start;
+        }
+        this.selectionStart = newSelection;
+      }
+      else if (newSelection > start && newSelection < end) {
+        if (this._selectionDirection === 'right') {
+          this.selectionEnd = newSelection;
+        }
+        else {
+          this.selectionStart = newSelection;
+        }
+      }
+      else {
+        // newSelection is > selection start and end
+        if (end === start) {
+          this._selectionDirection = 'right';
+        }
+        else if (this._selectionDirection === 'left') {
+          this._selectionDirection = 'right';
+          this.selectionStart = end;
+        }
+        this.selectionEnd = newSelection;
+      }
+    },
+
+    setSelectionInBoundaries: function() {
+      var length = this.text.length;
+      if (this.selectionStart > length) {
+        this.selectionStart = length;
+      }
+      else if (this.selectionStart < 0) {
+        this.selectionStart = 0;
+      }
+      if (this.selectionEnd > length) {
+        this.selectionEnd = length;
+      }
+      else if (this.selectionEnd < 0) {
+        this.selectionEnd = 0;
+      }
+    }
+  });
+})();
+
+
+fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
+  /**
+   * Initializes "dbclick" event handler
+   */
+  initDoubleClickSimulation: function() {
+
+    // for double click
+    this.__lastClickTime = +new Date();
+
+    // for triple click
+    this.__lastLastClickTime = +new Date();
+
+    this.__lastPointer = { };
+
+    this.on('mousedown', this.onMouseDown);
+  },
+
+  /**
+   * Default event handler to simulate triple click
+   * @private
+   */
+  onMouseDown: function(options) {
+    if (!this.canvas) {
+      return;
+    }
+    this.__newClickTime = +new Date();
+    var newPointer = options.pointer;
+    if (this.isTripleClick(newPointer)) {
+      this.fire('tripleclick', options);
+      this._stopEvent(options.e);
+    }
+    this.__lastLastClickTime = this.__lastClickTime;
+    this.__lastClickTime = this.__newClickTime;
+    this.__lastPointer = newPointer;
+    this.__lastIsEditing = this.isEditing;
+    this.__lastSelected = this.selected;
+  },
+
+  isTripleClick: function(newPointer) {
+    return this.__newClickTime - this.__lastClickTime < 500 &&
+        this.__lastClickTime - this.__lastLastClickTime < 500 &&
+        this.__lastPointer.x === newPointer.x &&
+        this.__lastPointer.y === newPointer.y;
+  },
+
+  /**
+   * @private
+   */
+  _stopEvent: function(e) {
+    e.preventDefault && e.preventDefault();
+    e.stopPropagation && e.stopPropagation();
+  },
+
+  /**
+   * Initializes event handlers related to cursor or selection
+   */
+  initCursorSelectionHandlers: function() {
+    this.initMousedownHandler();
+    this.initMouseupHandler();
+    this.initClicks();
+  },
+
+  /**
+   * Default handler for double click, select a word
+   */
+  doubleClickHandler: function(options) {
+    if (!this.isEditing) {
+      return;
+    }
+    this.selectWord(this.getSelectionStartFromPointer(options.e));
+  },
+
+  /**
+   * Default handler for triple click, select a line
+   */
+  tripleClickHandler: function(options) {
+    if (!this.isEditing) {
+      return;
+    }
+    this.selectLine(this.getSelectionStartFromPointer(options.e));
+  },
+
+  /**
+   * Initializes double and triple click event handlers
+   */
+  initClicks: function() {
+    this.on('mousedblclick', this.doubleClickHandler);
+    this.on('tripleclick', this.tripleClickHandler);
+  },
+
+  /**
+   * Default event handler for the basic functionalities needed on _mouseDown
+   * can be overridden to do something different.
+   * Scope of this implementation is: find the click position, set selectionStart
+   * find selectionEnd, initialize the drawing of either cursor or selection area
+   * initializing a mousedDown on a text area will cancel fabricjs knowledge of
+   * current compositionMode. It will be set to false.
+   */
+  _mouseDownHandler: function(options) {
+    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
+      return;
+    }
+
+    this.__isMousedown = true;
+
+    if (this.selected) {
+      this.inCompositionMode = false;
+      this.setCursorByClick(options.e);
+    }
+
+    if (this.isEditing) {
+      this.__selectionStartOnMouseDown = this.selectionStart;
+      if (this.selectionStart === this.selectionEnd) {
+        this.abortCursorAnimation();
+      }
+      this.renderCursorOrSelection();
+    }
+  },
+
+  /**
+   * Default event handler for the basic functionalities needed on mousedown:before
+   * can be overridden to do something different.
+   * Scope of this implementation is: verify the object is already selected when mousing down
+   */
+  _mouseDownHandlerBefore: function(options) {
+    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
+      return;
+    }
+    // we want to avoid that an object that was selected and then becomes unselectable,
+    // may trigger editing mode in some way.
+    this.selected = this === this.canvas._activeObject;
+  },
+
+  /**
+   * Initializes "mousedown" event handler
+   */
+  initMousedownHandler: function() {
+    this.on('mousedown', this._mouseDownHandler);
+    this.on('mousedown:before', this._mouseDownHandlerBefore);
+  },
+
+  /**
+   * Initializes "mouseup" event handler
+   */
+  initMouseupHandler: function() {
+    this.on('mouseup', this.mouseUpHandler);
+  },
+
+  /**
+   * standard handler for mouse up, overridable
+   * @private
+   */
+  mouseUpHandler: function(options) {
+    this.__isMousedown = false;
+    if (!this.editable || this.group ||
+      (options.transform && options.transform.actionPerformed) ||
+      (options.e.button && options.e.button !== 1)) {
+      return;
+    }
+
+    if (this.canvas) {
+      var currentActive = this.canvas._activeObject;
+      if (currentActive && currentActive !== this) {
+        // avoid running this logic when there is an active object
+        // this because is possible with shift click and fast clicks,
+        // to rapidly deselect and reselect this object and trigger an enterEdit
+        return;
       }
-      else if (newSelection > start && newSelection < end) {
-        if (this._selectionDirection === 'right') {
-          this.selectionEnd = newSelection;
-        }
-        else {
-          this.selectionStart = newSelection;
-        }
+    }
+
+    if (this.__lastSelected && !this.__corner) {
+      this.selected = false;
+      this.__lastSelected = false;
+      this.enterEditing(options.e);
+      if (this.selectionStart === this.selectionEnd) {
+        this.initDelayedCursor(true);
       }
       else {
-        // newSelection is > selection start and end
-        if (end === start) {
-          this._selectionDirection = 'right';
-        }
-        else if (this._selectionDirection === 'left') {
-          this._selectionDirection = 'right';
-          this.selectionStart = end;
-        }
-        this.selectionEnd = newSelection;
+        this.renderCursorOrSelection();
       }
-    },
+    }
+    else {
+      this.selected = true;
+    }
+  },
 
-    setSelectionInBoundaries: function() {
-      var length = this.text.length;
-      if (this.selectionStart > length) {
-        this.selectionStart = length;
+  /**
+   * Changes cursor location in a text depending on passed pointer (x/y) object
+   * @param {Event} e Event object
+   */
+  setCursorByClick: function(e) {
+    var newSelection = this.getSelectionStartFromPointer(e),
+        start = this.selectionStart, end = this.selectionEnd;
+    if (e.shiftKey) {
+      this.setSelectionStartEndWithShift(start, end, newSelection);
+    }
+    else {
+      this.selectionStart = newSelection;
+      this.selectionEnd = newSelection;
+    }
+    if (this.isEditing) {
+      this._fireSelectionChanged();
+      this._updateTextarea();
+    }
+  },
+
+  /**
+   * Returns index of a character corresponding to where an object was clicked
+   * @param {Event} e Event object
+   * @return {Number} Index of a character
+   */
+  getSelectionStartFromPointer: function(e) {
+    var mouseOffset = this.getLocalPointer(e),
+        prevWidth = 0,
+        width = 0,
+        height = 0,
+        charIndex = 0,
+        lineIndex = 0,
+        lineLeftOffset,
+        line;
+    for (var i = 0, len = this._textLines.length; i < len; i++) {
+      if (height <= mouseOffset.y) {
+        height += this.getHeightOfLine(i) * this.scaleY;
+        lineIndex = i;
+        if (i > 0) {
+          charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
+        }
       }
-      else if (this.selectionStart < 0) {
-        this.selectionStart = 0;
+      else {
+        break;
       }
-      if (this.selectionEnd > length) {
-        this.selectionEnd = length;
+    }
+    lineLeftOffset = this._getLineLeftOffset(lineIndex);
+    width = lineLeftOffset * this.scaleX;
+    line = this._textLines[lineIndex];
+    // handling of RTL: in order to get things work correctly,
+    // we assume RTL writing is mirrored compared to LTR writing.
+    // so in position detection we mirror the X offset, and when is time
+    // of rendering it, we mirror it again.
+    if (this.direction === 'rtl') {
+      mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;
+    }
+    for (var j = 0, jlen = line.length; j < jlen; j++) {
+      prevWidth = width;
+      // i removed something about flipX here, check.
+      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
+      if (width <= mouseOffset.x) {
+        charIndex++;
       }
-      else if (this.selectionEnd < 0) {
-        this.selectionEnd = 0;
+      else {
+        break;
       }
     }
-  });
-})();
-
+    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
+  },
 
-fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
   /**
-   * Initializes "dbclick" event handler
+   * @private
    */
-  initDoubleClickSimulation: function() {
+  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
+    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
+    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
+        distanceBtwNextCharAndCursor = width - mouseOffset.x,
+        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
+          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
+        newSelectionStart = index + offset;
+    // if object is horizontally flipped, mirror cursor location from the end
+    if (this.flipX) {
+      newSelectionStart = jlen - newSelectionStart;
+    }
 
-    // for double click
-    this.__lastClickTime = +new Date();
+    if (newSelectionStart > this._text.length) {
+      newSelectionStart = this._text.length;
+    }
 
-    // for triple click
-    this.__lastLastClickTime = +new Date();
+    return newSelectionStart;
+  }
+});
 
-    this.__lastPointer = { };
 
-    this.on('mousedown', this.onMouseDown);
-  },
+fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
 
   /**
-   * Default event handler to simulate triple click
-   * @private
+   * Initializes hidden textarea (needed to bring up keyboard in iOS)
    */
-  onMouseDown: function(options) {
-    if (!this.canvas) {
-      return;
+  initHiddenTextarea: function() {
+    this.hiddenTextarea = fabric.document.createElement('textarea');
+    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
+    this.hiddenTextarea.setAttribute('autocorrect', 'off');
+    this.hiddenTextarea.setAttribute('autocomplete', 'off');
+    this.hiddenTextarea.setAttribute('spellcheck', 'false');
+    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
+    this.hiddenTextarea.setAttribute('wrap', 'off');
+    var style = this._calcTextareaPosition();
+    // line-height: 1px; was removed from the style to fix this:
+    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
+    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
+    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
+    ' paddingｰtop: ' + style.fontSize + ';';
+
+    if (this.hiddenTextareaContainer) {
+      this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);
     }
-    this.__newClickTime = +new Date();
-    var newPointer = options.pointer;
-    if (this.isTripleClick(newPointer)) {
-      this.fire('tripleclick', options);
-      this._stopEvent(options.e);
+    else {
+      fabric.document.body.appendChild(this.hiddenTextarea);
+    }
+
+    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
+    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));
+
+    if (!this._clickHandlerInitialized && this.canvas) {
+      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
+      this._clickHandlerInitialized = true;
     }
-    this.__lastLastClickTime = this.__lastClickTime;
-    this.__lastClickTime = this.__newClickTime;
-    this.__lastPointer = newPointer;
-    this.__lastIsEditing = this.isEditing;
-    this.__lastSelected = this.selected;
   },
 
-  isTripleClick: function(newPointer) {
-    return this.__newClickTime - this.__lastClickTime < 500 &&
-        this.__lastClickTime - this.__lastLastClickTime < 500 &&
-        this.__lastPointer.x === newPointer.x &&
-        this.__lastPointer.y === newPointer.y;
+  /**
+   * For functionalities on keyDown
+   * Map a special key to a function of the instance/prototype
+   * If you need different behaviour for ESC or TAB or arrows, you have to change
+   * this map setting the name of a function that you build on the fabric.Itext or
+   * your prototype.
+   * the map change will affect all Instances unless you need for only some text Instances
+   * in that case you have to clone this object and assign your Instance.
+   * this.keysMap = fabric.util.object.clone(this.keysMap);
+   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
+   */
+  keysMap: {
+    9:  'exitEditing',
+    27: 'exitEditing',
+    33: 'moveCursorUp',
+    34: 'moveCursorDown',
+    35: 'moveCursorRight',
+    36: 'moveCursorLeft',
+    37: 'moveCursorLeft',
+    38: 'moveCursorUp',
+    39: 'moveCursorRight',
+    40: 'moveCursorDown',
+  },
+
+  keysMapRtl: {
+    9:  'exitEditing',
+    27: 'exitEditing',
+    33: 'moveCursorUp',
+    34: 'moveCursorDown',
+    35: 'moveCursorLeft',
+    36: 'moveCursorRight',
+    37: 'moveCursorRight',
+    38: 'moveCursorUp',
+    39: 'moveCursorLeft',
+    40: 'moveCursorDown',
   },
 
   /**
-   * @private
+   * For functionalities on keyUp + ctrl || cmd
    */
-  _stopEvent: function(e) {
-    e.preventDefault && e.preventDefault();
-    e.stopPropagation && e.stopPropagation();
+  ctrlKeysMapUp: {
+    67: 'copy',
+    88: 'cut'
   },
 
   /**
-   * Initializes event handlers related to cursor or selection
+   * For functionalities on keyDown + ctrl || cmd
    */
-  initCursorSelectionHandlers: function() {
-    this.initMousedownHandler();
-    this.initMouseupHandler();
-    this.initClicks();
+  ctrlKeysMapDown: {
+    65: 'selectAll'
   },
 
-  /**
-   * Default handler for double click, select a word
-   */
-  doubleClickHandler: function(options) {
-    if (!this.isEditing) {
-      return;
-    }
-    this.selectWord(this.getSelectionStartFromPointer(options.e));
+  onClick: function() {
+    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
+    this.hiddenTextarea && this.hiddenTextarea.focus();
   },
 
   /**
-   * Default handler for triple click, select a line
+   * Handles keydown event
+   * only used for arrows and combination of modifier keys.
+   * @param {Event} e Event object
    */
-  tripleClickHandler: function(options) {
+  onKeyDown: function(e) {
     if (!this.isEditing) {
       return;
     }
-    this.selectLine(this.getSelectionStartFromPointer(options.e));
+    var keyMap = this.direction === 'rtl' ? this.keysMapRtl : this.keysMap;
+    if (e.keyCode in keyMap) {
+      this[keyMap[e.keyCode]](e);
+    }
+    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
+      this[this.ctrlKeysMapDown[e.keyCode]](e);
+    }
+    else {
+      return;
+    }
+    e.stopImmediatePropagation();
+    e.preventDefault();
+    if (e.keyCode >= 33 && e.keyCode <= 40) {
+      // if i press an arrow key just update selection
+      this.inCompositionMode = false;
+      this.clearContextTop();
+      this.renderCursorOrSelection();
+    }
+    else {
+      this.canvas && this.canvas.requestRenderAll();
+    }
   },
 
   /**
-   * Initializes double and triple click event handlers
+   * Handles keyup event
+   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
+   * if a copy/cut event fired, keyup is dismissed
+   * @param {Event} e Event object
    */
-  initClicks: function() {
-    this.on('mousedblclick', this.doubleClickHandler);
-    this.on('tripleclick', this.tripleClickHandler);
+  onKeyUp: function(e) {
+    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
+      this._copyDone = false;
+      return;
+    }
+    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
+      this[this.ctrlKeysMapUp[e.keyCode]](e);
+    }
+    else {
+      return;
+    }
+    e.stopImmediatePropagation();
+    e.preventDefault();
+    this.canvas && this.canvas.requestRenderAll();
   },
 
   /**
-   * Default event handler for the basic functionalities needed on _mouseDown
-   * can be overridden to do something different.
-   * Scope of this implementation is: find the click position, set selectionStart
-   * find selectionEnd, initialize the drawing of either cursor or selection area
-   * initializing a mousedDown on a text area will cancel fabricjs knowledge of
-   * current compositionMode. It will be set to false.
+   * Handles onInput event
+   * @param {Event} e Event object
    */
-  _mouseDownHandler: function(options) {
-    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
+  onInput: function(e) {
+    var fromPaste = this.fromPaste;
+    this.fromPaste = false;
+    e && e.stopPropagation();
+    if (!this.isEditing) {
+      return;
+    }
+    // decisions about style changes.
+    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
+        charCount = this._text.length,
+        nextCharCount = nextText.length,
+        removedText, insertedText,
+        charDiff = nextCharCount - charCount,
+        selectionStart = this.selectionStart, selectionEnd = this.selectionEnd,
+        selection = selectionStart !== selectionEnd,
+        copiedStyle, removeFrom, removeTo;
+    if (this.hiddenTextarea.value === '') {
+      this.styles = { };
+      this.updateFromTextArea();
+      this.fire('changed');
+      if (this.canvas) {
+        this.canvas.fire('text:changed', { target: this });
+        this.canvas.requestRenderAll();
+      }
       return;
     }
 
-    this.__isMousedown = true;
+    var textareaSelection = this.fromStringToGraphemeSelection(
+      this.hiddenTextarea.selectionStart,
+      this.hiddenTextarea.selectionEnd,
+      this.hiddenTextarea.value
+    );
+    var backDelete = selectionStart > textareaSelection.selectionStart;
 
-    if (this.selected) {
-      this.inCompositionMode = false;
-      this.setCursorByClick(options.e);
+    if (selection) {
+      removedText = this._text.slice(selectionStart, selectionEnd);
+      charDiff += selectionEnd - selectionStart;
     }
-
-    if (this.isEditing) {
-      this.__selectionStartOnMouseDown = this.selectionStart;
-      if (this.selectionStart === this.selectionEnd) {
-        this.abortCursorAnimation();
+    else if (nextCharCount < charCount) {
+      if (backDelete) {
+        removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
       }
-      this.renderCursorOrSelection();
+      else {
+        removedText = this._text.slice(selectionStart, selectionStart - charDiff);
+      }
+    }
+    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
+    if (removedText && removedText.length) {
+      if (insertedText.length) {
+        // let's copy some style before deleting.
+        // we want to copy the style before the cursor OR the style at the cursor if selection
+        // is bigger than 0.
+        copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
+        // now duplicate the style one for each inserted text.
+        copiedStyle = insertedText.map(function() {
+          // this return an array of references, but that is fine since we are
+          // copying the style later.
+          return copiedStyle[0];
+        });
+      }
+      if (selection) {
+        removeFrom = selectionStart;
+        removeTo = selectionEnd;
+      }
+      else if (backDelete) {
+        // detect differences between forwardDelete and backDelete
+        removeFrom = selectionEnd - removedText.length;
+        removeTo = selectionEnd;
+      }
+      else {
+        removeFrom = selectionEnd;
+        removeTo = selectionEnd + removedText.length;
+      }
+      this.removeStyleFromTo(removeFrom, removeTo);
+    }
+    if (insertedText.length) {
+      if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
+        copiedStyle = fabric.copiedTextStyle;
+      }
+      this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
+    }
+    this.updateFromTextArea();
+    this.fire('changed');
+    if (this.canvas) {
+      this.canvas.fire('text:changed', { target: this });
+      this.canvas.requestRenderAll();
     }
   },
-
   /**
-   * Default event handler for the basic functionalities needed on mousedown:before
-   * can be overridden to do something different.
-   * Scope of this implementation is: verify the object is already selected when mousing down
+   * Composition start
    */
-  _mouseDownHandlerBefore: function(options) {
-    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
-      return;
-    }
-    // we want to avoid that an object that was selected and then becomes unselectable,
-    // may trigger editing mode in some way.
-    this.selected = this === this.canvas._activeObject;
+  onCompositionStart: function() {
+    this.inCompositionMode = true;
   },
 
   /**
-   * Initializes "mousedown" event handler
+   * Composition end
    */
-  initMousedownHandler: function() {
-    this.on('mousedown', this._mouseDownHandler);
-    this.on('mousedown:before', this._mouseDownHandlerBefore);
+  onCompositionEnd: function() {
+    this.inCompositionMode = false;
   },
 
-  /**
-   * Initializes "mouseup" event handler
-   */
-  initMouseupHandler: function() {
-    this.on('mouseup', this.mouseUpHandler);
+  // /**
+  //  * Composition update
+  //  */
+  onCompositionUpdate: function(e) {
+    this.compositionStart = e.target.selectionStart;
+    this.compositionEnd = e.target.selectionEnd;
+    this.updateTextareaPosition();
   },
 
   /**
-   * standard handler for mouse up, overridable
-   * @private
+   * Copies selected text
+   * @param {Event} e Event object
    */
-  mouseUpHandler: function(options) {
-    this.__isMousedown = false;
-    if (!this.editable || this.group ||
-      (options.transform && options.transform.actionPerformed) ||
-      (options.e.button && options.e.button !== 1)) {
-      return;
-    }
-
-    if (this.canvas) {
-      var currentActive = this.canvas._activeObject;
-      if (currentActive && currentActive !== this) {
-        // avoid running this logic when there is an active object
-        // this because is possible with shift click and fast clicks,
-        // to rapidly deselect and reselect this object and trigger an enterEdit
-        return;
-      }
-    }
-
-    if (this.__lastSelected && !this.__corner) {
-      this.selected = false;
-      this.__lastSelected = false;
-      this.enterEditing(options.e);
-      if (this.selectionStart === this.selectionEnd) {
-        this.initDelayedCursor(true);
-      }
-      else {
-        this.renderCursorOrSelection();
-      }
+  copy: function() {
+    if (this.selectionStart === this.selectionEnd) {
+      //do not cut-copy if no selection
+      return;
+    }
+
+    fabric.copiedText = this.getSelectedText();
+    if (!fabric.disableStyleCopyPaste) {
+      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
     }
     else {
-      this.selected = true;
+      fabric.copiedTextStyle = null;
     }
+    this._copyDone = true;
   },
 
   /**
-   * Changes cursor location in a text depending on passed pointer (x/y) object
+   * Pastes text
    * @param {Event} e Event object
    */
-  setCursorByClick: function(e) {
-    var newSelection = this.getSelectionStartFromPointer(e),
-        start = this.selectionStart, end = this.selectionEnd;
-    if (e.shiftKey) {
-      this.setSelectionStartEndWithShift(start, end, newSelection);
-    }
-    else {
-      this.selectionStart = newSelection;
-      this.selectionEnd = newSelection;
-    }
-    if (this.isEditing) {
-      this._fireSelectionChanged();
-      this._updateTextarea();
-    }
+  paste: function() {
+    this.fromPaste = true;
   },
 
   /**
-   * Returns index of a character corresponding to where an object was clicked
+   * @private
    * @param {Event} e Event object
-   * @return {Number} Index of a character
+   * @return {Object} Clipboard data object
    */
-  getSelectionStartFromPointer: function(e) {
-    var mouseOffset = this.getLocalPointer(e),
-        prevWidth = 0,
-        width = 0,
-        height = 0,
-        charIndex = 0,
-        lineIndex = 0,
-        lineLeftOffset,
-        line;
-    for (var i = 0, len = this._textLines.length; i < len; i++) {
-      if (height <= mouseOffset.y) {
-        height += this.getHeightOfLine(i) * this.scaleY;
-        lineIndex = i;
-        if (i > 0) {
-          charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
-        }
-      }
-      else {
-        break;
-      }
-    }
-    lineLeftOffset = this._getLineLeftOffset(lineIndex);
-    width = lineLeftOffset * this.scaleX;
-    line = this._textLines[lineIndex];
-    // handling of RTL: in order to get things work correctly,
-    // we assume RTL writing is mirrored compared to LTR writing.
-    // so in position detection we mirror the X offset, and when is time
-    // of rendering it, we mirror it again.
-    if (this.direction === 'rtl') {
-      mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;
-    }
-    for (var j = 0, jlen = line.length; j < jlen; j++) {
-      prevWidth = width;
-      // i removed something about flipX here, check.
-      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
-      if (width <= mouseOffset.x) {
-        charIndex++;
-      }
-      else {
-        break;
-      }
-    }
-    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
+  _getClipboardData: function(e) {
+    return (e && e.clipboardData) || fabric.window.clipboardData;
   },
 
   /**
+   * Finds the width in pixels before the cursor on the same line
    * @private
+   * @param {Number} lineIndex
+   * @param {Number} charIndex
+   * @return {Number} widthBeforeCursor width before cursor
    */
-  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
-    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
-    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
-        distanceBtwNextCharAndCursor = width - mouseOffset.x,
-        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
-          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
-        newSelectionStart = index + offset;
-    // if object is horizontally flipped, mirror cursor location from the end
-    if (this.flipX) {
-      newSelectionStart = jlen - newSelectionStart;
-    }
+  _getWidthBeforeCursor: function(lineIndex, charIndex) {
+    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;
 
-    if (newSelectionStart > this._text.length) {
-      newSelectionStart = this._text.length;
+    if (charIndex > 0) {
+      bound = this.__charBounds[lineIndex][charIndex - 1];
+      widthBeforeCursor += bound.left + bound.width;
     }
-
-    return newSelectionStart;
-  }
-});
-
-
-fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
+    return widthBeforeCursor;
+  },
 
   /**
-   * Initializes hidden textarea (needed to bring up keyboard in iOS)
+   * Gets start offset of a selection
+   * @param {Event} e Event object
+   * @param {Boolean} isRight
+   * @return {Number}
    */
-  initHiddenTextarea: function() {
-    this.hiddenTextarea = fabric.document.createElement('textarea');
-    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
-    this.hiddenTextarea.setAttribute('autocorrect', 'off');
-    this.hiddenTextarea.setAttribute('autocomplete', 'off');
-    this.hiddenTextarea.setAttribute('spellcheck', 'false');
-    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
-    this.hiddenTextarea.setAttribute('wrap', 'off');
-    var style = this._calcTextareaPosition();
-    // line-height: 1px; was removed from the style to fix this:
-    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
-    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
-    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
-    ' paddingｰtop: ' + style.fontSize + ';';
+  getDownCursorOffset: function(e, isRight) {
+    var selectionProp = this._getSelectionForOffset(e, isRight),
+        cursorLocation = this.get2DCursorLocation(selectionProp),
+        lineIndex = cursorLocation.lineIndex;
+    // if on last line, down cursor goes to end of line
+    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
+      // move to the end of a text
+      return this._text.length - selectionProp;
+    }
+    var charIndex = cursorLocation.charIndex,
+        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
+        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
+        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
+    return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
+  },
 
-    if (this.hiddenTextareaContainer) {
-      this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);
+  /**
+   * private
+   * Helps finding if the offset should be counted from Start or End
+   * @param {Event} e Event object
+   * @param {Boolean} isRight
+   * @return {Number}
+   */
+  _getSelectionForOffset: function(e, isRight) {
+    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
+      return this.selectionEnd;
     }
     else {
-      fabric.document.body.appendChild(this.hiddenTextarea);
-    }
-
-    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
-    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));
-
-    if (!this._clickHandlerInitialized && this.canvas) {
-      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
-      this._clickHandlerInitialized = true;
+      return this.selectionStart;
     }
   },
 
   /**
-   * For functionalities on keyDown
-   * Map a special key to a function of the instance/prototype
-   * If you need different behaviour for ESC or TAB or arrows, you have to change
-   * this map setting the name of a function that you build on the fabric.Itext or
-   * your prototype.
-   * the map change will affect all Instances unless you need for only some text Instances
-   * in that case you have to clone this object and assign your Instance.
-   * this.keysMap = fabric.util.object.clone(this.keysMap);
-   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
+   * @param {Event} e Event object
+   * @param {Boolean} isRight
+   * @return {Number}
    */
-  keysMap: {
-    9:  'exitEditing',
-    27: 'exitEditing',
-    33: 'moveCursorUp',
-    34: 'moveCursorDown',
-    35: 'moveCursorRight',
-    36: 'moveCursorLeft',
-    37: 'moveCursorLeft',
-    38: 'moveCursorUp',
-    39: 'moveCursorRight',
-    40: 'moveCursorDown',
-  },
-
-  keysMapRtl: {
-    9:  'exitEditing',
-    27: 'exitEditing',
-    33: 'moveCursorUp',
-    34: 'moveCursorDown',
-    35: 'moveCursorLeft',
-    36: 'moveCursorRight',
-    37: 'moveCursorRight',
-    38: 'moveCursorUp',
-    39: 'moveCursorLeft',
-    40: 'moveCursorDown',
+  getUpCursorOffset: function(e, isRight) {
+    var selectionProp = this._getSelectionForOffset(e, isRight),
+        cursorLocation = this.get2DCursorLocation(selectionProp),
+        lineIndex = cursorLocation.lineIndex;
+    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
+      // if on first line, up cursor goes to start of line
+      return -selectionProp;
+    }
+    var charIndex = cursorLocation.charIndex,
+        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
+        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
+        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
+        missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
+    // return a negative offset
+    return -this._textLines[lineIndex - 1].length
+     + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
   },
 
   /**
-   * For functionalities on keyUp + ctrl || cmd
+   * for a given width it founds the matching character.
+   * @private
    */
-  ctrlKeysMapUp: {
-    67: 'copy',
-    88: 'cut'
+  _getIndexOnLine: function(lineIndex, width) {
+
+    var line = this._textLines[lineIndex],
+        lineLeftOffset = this._getLineLeftOffset(lineIndex),
+        widthOfCharsOnLine = lineLeftOffset,
+        indexOnLine = 0, charWidth, foundMatch;
+
+    for (var j = 0, jlen = line.length; j < jlen; j++) {
+      charWidth = this.__charBounds[lineIndex][j].width;
+      widthOfCharsOnLine += charWidth;
+      if (widthOfCharsOnLine > width) {
+        foundMatch = true;
+        var leftEdge = widthOfCharsOnLine - charWidth,
+            rightEdge = widthOfCharsOnLine,
+            offsetFromLeftEdge = Math.abs(leftEdge - width),
+            offsetFromRightEdge = Math.abs(rightEdge - width);
+
+        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
+        break;
+      }
+    }
+
+    // reached end
+    if (!foundMatch) {
+      indexOnLine = line.length - 1;
+    }
+
+    return indexOnLine;
   },
 
+
   /**
-   * For functionalities on keyDown + ctrl || cmd
+   * Moves cursor down
+   * @param {Event} e Event object
    */
-  ctrlKeysMapDown: {
-    65: 'selectAll'
-  },
-
-  onClick: function() {
-    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
-    this.hiddenTextarea && this.hiddenTextarea.focus();
+  moveCursorDown: function(e) {
+    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
+      return;
+    }
+    this._moveCursorUpOrDown('Down', e);
   },
 
   /**
-   * Handles keydown event
-   * only used for arrows and combination of modifier keys.
+   * Moves cursor up
    * @param {Event} e Event object
    */
-  onKeyDown: function(e) {
-    if (!this.isEditing) {
+  moveCursorUp: function(e) {
+    if (this.selectionStart === 0 && this.selectionEnd === 0) {
       return;
     }
-    var keyMap = this.direction === 'rtl' ? this.keysMapRtl : this.keysMap;
-    if (e.keyCode in keyMap) {
-      this[keyMap[e.keyCode]](e);
-    }
-    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
-      this[this.ctrlKeysMapDown[e.keyCode]](e);
+    this._moveCursorUpOrDown('Up', e);
+  },
+
+  /**
+   * Moves cursor up or down, fires the events
+   * @param {String} direction 'Up' or 'Down'
+   * @param {Event} e Event object
+   */
+  _moveCursorUpOrDown: function(direction, e) {
+    // getUpCursorOffset
+    // getDownCursorOffset
+    var action = 'get' + direction + 'CursorOffset',
+        offset = this[action](e, this._selectionDirection === 'right');
+    if (e.shiftKey) {
+      this.moveCursorWithShift(offset);
     }
     else {
-      return;
-    }
-    e.stopImmediatePropagation();
-    e.preventDefault();
-    if (e.keyCode >= 33 && e.keyCode <= 40) {
-      // if i press an arrow key just update selection
-      this.inCompositionMode = false;
-      this.clearContextTop();
-      this.renderCursorOrSelection();
+      this.moveCursorWithoutShift(offset);
     }
-    else {
-      this.canvas && this.canvas.requestRenderAll();
+    if (offset !== 0) {
+      this.setSelectionInBoundaries();
+      this.abortCursorAnimation();
+      this._currentCursorOpacity = 1;
+      this.initDelayedCursor();
+      this._fireSelectionChanged();
+      this._updateTextarea();
     }
   },
 
   /**
-   * Handles keyup event
-   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
-   * if a copy/cut event fired, keyup is dismissed
-   * @param {Event} e Event object
+   * Moves cursor with shift
+   * @param {Number} offset
    */
-  onKeyUp: function(e) {
-    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
-      this._copyDone = false;
-      return;
-    }
-    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
-      this[this.ctrlKeysMapUp[e.keyCode]](e);
+  moveCursorWithShift: function(offset) {
+    var newSelection = this._selectionDirection === 'left'
+      ? this.selectionStart + offset
+      : this.selectionEnd + offset;
+    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
+    return offset !== 0;
+  },
+
+  /**
+   * Moves cursor up without shift
+   * @param {Number} offset
+   */
+  moveCursorWithoutShift: function(offset) {
+    if (offset < 0) {
+      this.selectionStart += offset;
+      this.selectionEnd = this.selectionStart;
     }
     else {
-      return;
+      this.selectionEnd += offset;
+      this.selectionStart = this.selectionEnd;
     }
-    e.stopImmediatePropagation();
-    e.preventDefault();
-    this.canvas && this.canvas.requestRenderAll();
+    return offset !== 0;
   },
 
   /**
-   * Handles onInput event
+   * Moves cursor left
    * @param {Event} e Event object
    */
-  onInput: function(e) {
-    var fromPaste = this.fromPaste;
-    this.fromPaste = false;
-    e && e.stopPropagation();
-    if (!this.isEditing) {
-      return;
-    }
-    // decisions about style changes.
-    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
-        charCount = this._text.length,
-        nextCharCount = nextText.length,
-        removedText, insertedText,
-        charDiff = nextCharCount - charCount,
-        selectionStart = this.selectionStart, selectionEnd = this.selectionEnd,
-        selection = selectionStart !== selectionEnd,
-        copiedStyle, removeFrom, removeTo;
-    if (this.hiddenTextarea.value === '') {
-      this.styles = { };
-      this.updateFromTextArea();
-      this.fire('changed');
-      if (this.canvas) {
-        this.canvas.fire('text:changed', { target: this });
-        this.canvas.requestRenderAll();
-      }
+  moveCursorLeft: function(e) {
+    if (this.selectionStart === 0 && this.selectionEnd === 0) {
       return;
     }
+    this._moveCursorLeftOrRight('Left', e);
+  },
 
-    var textareaSelection = this.fromStringToGraphemeSelection(
-      this.hiddenTextarea.selectionStart,
-      this.hiddenTextarea.selectionEnd,
-      this.hiddenTextarea.value
-    );
-    var backDelete = selectionStart > textareaSelection.selectionStart;
-
-    if (selection) {
-      removedText = this._text.slice(selectionStart, selectionEnd);
-      charDiff += selectionEnd - selectionStart;
-    }
-    else if (nextCharCount < charCount) {
-      if (backDelete) {
-        removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
-      }
-      else {
-        removedText = this._text.slice(selectionStart, selectionStart - charDiff);
-      }
+  /**
+   * @private
+   * @return {Boolean} true if a change happened
+   */
+  _move: function(e, prop, direction) {
+    var newValue;
+    if (e.altKey) {
+      newValue = this['findWordBoundary' + direction](this[prop]);
     }
-    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
-    if (removedText && removedText.length) {
-      if (insertedText.length) {
-        // let's copy some style before deleting.
-        // we want to copy the style before the cursor OR the style at the cursor if selection
-        // is bigger than 0.
-        copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
-        // now duplicate the style one for each inserted text.
-        copiedStyle = insertedText.map(function() {
-          // this return an array of references, but that is fine since we are
-          // copying the style later.
-          return copiedStyle[0];
-        });
-      }
-      if (selection) {
-        removeFrom = selectionStart;
-        removeTo = selectionEnd;
-      }
-      else if (backDelete) {
-        // detect differences between forwardDelete and backDelete
-        removeFrom = selectionEnd - removedText.length;
-        removeTo = selectionEnd;
-      }
-      else {
-        removeFrom = selectionEnd;
-        removeTo = selectionEnd + removedText.length;
-      }
-      this.removeStyleFromTo(removeFrom, removeTo);
+    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
+      newValue = this['findLineBoundary' + direction](this[prop]);
     }
-    if (insertedText.length) {
-      if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
-        copiedStyle = fabric.copiedTextStyle;
-      }
-      this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
+    else {
+      this[prop] += direction === 'Left' ? -1 : 1;
+      return true;
     }
-    this.updateFromTextArea();
-    this.fire('changed');
-    if (this.canvas) {
-      this.canvas.fire('text:changed', { target: this });
-      this.canvas.requestRenderAll();
+    if (typeof newValue !== undefined && this[prop] !== newValue) {
+      this[prop] = newValue;
+      return true;
     }
   },
+
   /**
-   * Composition start
+   * @private
    */
-  onCompositionStart: function() {
-    this.inCompositionMode = true;
+  _moveLeft: function(e, prop) {
+    return this._move(e, prop, 'Left');
   },
 
   /**
-   * Composition end
+   * @private
    */
-  onCompositionEnd: function() {
-    this.inCompositionMode = false;
-  },
-
-  // /**
-  //  * Composition update
-  //  */
-  onCompositionUpdate: function(e) {
-    this.compositionStart = e.target.selectionStart;
-    this.compositionEnd = e.target.selectionEnd;
-    this.updateTextareaPosition();
+  _moveRight: function(e, prop) {
+    return this._move(e, prop, 'Right');
   },
 
   /**
-   * Copies selected text
-   * @param {Event} e Event object
+   * Moves cursor left without keeping selection
+   * @param {Event} e
    */
-  copy: function() {
-    if (this.selectionStart === this.selectionEnd) {
-      //do not cut-copy if no selection
-      return;
+  moveCursorLeftWithoutShift: function(e) {
+    var change = true;
+    this._selectionDirection = 'left';
+
+    // only move cursor when there is no selection,
+    // otherwise we discard it, and leave cursor on same place
+    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
+      change = this._moveLeft(e, 'selectionStart');
+
     }
+    this.selectionEnd = this.selectionStart;
+    return change;
+  },
 
-    fabric.copiedText = this.getSelectedText();
-    if (!fabric.disableStyleCopyPaste) {
-      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
+  /**
+   * Moves cursor left while keeping selection
+   * @param {Event} e
+   */
+  moveCursorLeftWithShift: function(e) {
+    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
+      return this._moveLeft(e, 'selectionEnd');
     }
-    else {
-      fabric.copiedTextStyle = null;
+    else if (this.selectionStart !== 0){
+      this._selectionDirection = 'left';
+      return this._moveLeft(e, 'selectionStart');
     }
-    this._copyDone = true;
   },
 
   /**
-   * Pastes text
+   * Moves cursor right
    * @param {Event} e Event object
    */
-  paste: function() {
-    this.fromPaste = true;
+  moveCursorRight: function(e) {
+    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
+      return;
+    }
+    this._moveCursorLeftOrRight('Right', e);
   },
 
   /**
-   * @private
+   * Moves cursor right or Left, fires event
+   * @param {String} direction 'Left', 'Right'
    * @param {Event} e Event object
-   * @return {Object} Clipboard data object
    */
-  _getClipboardData: function(e) {
-    return (e && e.clipboardData) || fabric.window.clipboardData;
-  },
-
-  /**
-   * Finds the width in pixels before the cursor on the same line
-   * @private
-   * @param {Number} lineIndex
-   * @param {Number} charIndex
-   * @return {Number} widthBeforeCursor width before cursor
-   */
-  _getWidthBeforeCursor: function(lineIndex, charIndex) {
-    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;
+  _moveCursorLeftOrRight: function(direction, e) {
+    var actionName = 'moveCursor' + direction + 'With';
+    this._currentCursorOpacity = 1;
 
-    if (charIndex > 0) {
-      bound = this.__charBounds[lineIndex][charIndex - 1];
-      widthBeforeCursor += bound.left + bound.width;
+    if (e.shiftKey) {
+      actionName += 'Shift';
+    }
+    else {
+      actionName += 'outShift';
+    }
+    if (this[actionName](e)) {
+      this.abortCursorAnimation();
+      this.initDelayedCursor();
+      this._fireSelectionChanged();
+      this._updateTextarea();
     }
-    return widthBeforeCursor;
   },
 
   /**
-   * Gets start offset of a selection
-   * @param {Event} e Event object
-   * @param {Boolean} isRight
-   * @return {Number}
+   * Moves cursor right while keeping selection
+   * @param {Event} e
    */
-  getDownCursorOffset: function(e, isRight) {
-    var selectionProp = this._getSelectionForOffset(e, isRight),
-        cursorLocation = this.get2DCursorLocation(selectionProp),
-        lineIndex = cursorLocation.lineIndex;
-    // if on last line, down cursor goes to end of line
-    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
-      // move to the end of a text
-      return this._text.length - selectionProp;
+  moveCursorRightWithShift: function(e) {
+    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
+      return this._moveRight(e, 'selectionStart');
+    }
+    else if (this.selectionEnd !== this._text.length) {
+      this._selectionDirection = 'right';
+      return this._moveRight(e, 'selectionEnd');
     }
-    var charIndex = cursorLocation.charIndex,
-        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
-        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
-        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
-    return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
   },
 
   /**
-   * private
-   * Helps finding if the offset should be counted from Start or End
+   * Moves cursor right without keeping selection
    * @param {Event} e Event object
-   * @param {Boolean} isRight
-   * @return {Number}
    */
-  _getSelectionForOffset: function(e, isRight) {
-    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
-      return this.selectionEnd;
+  moveCursorRightWithoutShift: function(e) {
+    var changed = true;
+    this._selectionDirection = 'right';
+
+    if (this.selectionStart === this.selectionEnd) {
+      changed = this._moveRight(e, 'selectionStart');
+      this.selectionEnd = this.selectionStart;
     }
     else {
-      return this.selectionStart;
+      this.selectionStart = this.selectionEnd;
     }
+    return changed;
   },
 
   /**
-   * @param {Event} e Event object
-   * @param {Boolean} isRight
-   * @return {Number}
+   * Removes characters from start/end
+   * start/end ar per grapheme position in _text array.
+   *
+   * @param {Number} start
+   * @param {Number} end default to start + 1
    */
-  getUpCursorOffset: function(e, isRight) {
-    var selectionProp = this._getSelectionForOffset(e, isRight),
-        cursorLocation = this.get2DCursorLocation(selectionProp),
-        lineIndex = cursorLocation.lineIndex;
-    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
-      // if on first line, up cursor goes to start of line
-      return -selectionProp;
+  removeChars: function(start, end) {
+    if (typeof end === 'undefined') {
+      end = start + 1;
     }
-    var charIndex = cursorLocation.charIndex,
-        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
-        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
-        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
-        missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
-    // return a negative offset
-    return -this._textLines[lineIndex - 1].length
-     + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
+    this.removeStyleFromTo(start, end);
+    this._text.splice(start, end - start);
+    this.text = this._text.join('');
+    this.set('dirty', true);
+    if (this._shouldClearDimensionCache()) {
+      this.initDimensions();
+      this.setCoords();
+    }
+    this._removeExtraneousStyles();
   },
 
   /**
-   * for a given width it founds the matching character.
-   * @private
+   * insert characters at start position, before start position.
+   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
+   * if style array is provided, it must be as the same length of text in graphemes
+   * if end is provided and is bigger than start, old text is replaced.
+   * start/end ar per grapheme position in _text array.
+   *
+   * @param {String} text text to insert
+   * @param {Array} style array of style objects
+   * @param {Number} start
+   * @param {Number} end default to start + 1
    */
-  _getIndexOnLine: function(lineIndex, width) {
+  insertChars: function(text, style, start, end) {
+    if (typeof end === 'undefined') {
+      end = start;
+    }
+    if (end > start) {
+      this.removeStyleFromTo(start, end);
+    }
+    var graphemes = fabric.util.string.graphemeSplit(text);
+    this.insertNewStyleBlock(graphemes, start, style);
+    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
+    this.text = this._text.join('');
+    this.set('dirty', true);
+    if (this._shouldClearDimensionCache()) {
+      this.initDimensions();
+      this.setCoords();
+    }
+    this._removeExtraneousStyles();
+  },
 
-    var line = this._textLines[lineIndex],
-        lineLeftOffset = this._getLineLeftOffset(lineIndex),
-        widthOfCharsOnLine = lineLeftOffset,
-        indexOnLine = 0, charWidth, foundMatch;
+});
 
-    for (var j = 0, jlen = line.length; j < jlen; j++) {
-      charWidth = this.__charBounds[lineIndex][j].width;
-      widthOfCharsOnLine += charWidth;
-      if (widthOfCharsOnLine > width) {
-        foundMatch = true;
-        var leftEdge = widthOfCharsOnLine - charWidth,
-            rightEdge = widthOfCharsOnLine,
-            offsetFromLeftEdge = Math.abs(leftEdge - width),
-            offsetFromRightEdge = Math.abs(rightEdge - width);
 
-        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
-        break;
-      }
-    }
+/* _TO_SVG_START_ */
+(function() {
+  var toFixed = fabric.util.toFixed,
+      multipleSpacesRegex = /  +/g;
 
-    // reached end
-    if (!foundMatch) {
-      indexOnLine = line.length - 1;
-    }
+  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
+
+    /**
+     * Returns SVG representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
+     */
+    _toSVG: function() {
+      var offsets = this._getSVGLeftTopOffsets(),
+          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
+      return this._wrapSVGTextAndBg(textAndBg);
+    },
+
+    /**
+     * Returns svg representation of an instance
+     * @param {Function} [reviver] Method for further parsing of svg representation.
+     * @return {String} svg representation of an instance
+     */
+    toSVG: function(reviver) {
+      return this._createBaseSVGMarkup(
+        this._toSVG(),
+        { reviver: reviver, noStyle: true, withShadow: true }
+      );
+    },
+
+    /**
+     * @private
+     */
+    _getSVGLeftTopOffsets: function() {
+      return {
+        textLeft: -this.width / 2,
+        textTop: -this.height / 2,
+        lineTop: this.getHeightOfLine(0)
+      };
+    },
+
+    /**
+     * @private
+     */
+    _wrapSVGTextAndBg: function(textAndBg) {
+      var noShadow = true,
+          textDecoration = this.getSvgTextDecoration(this);
+      return [
+        textAndBg.textBgRects.join(''),
+        '\t\t<text xml:space="preserve" ',
+        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
+        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
+        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
+        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
+        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
+        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
+        textAndBg.textSpans.join(''),
+        '</text>\n'
+      ];
+    },
+
+    /**
+     * @private
+     * @param {Number} textTopOffset Text top offset
+     * @param {Number} textLeftOffset Text left offset
+     * @return {Object}
+     */
+    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
+      var textSpans = [],
+          textBgRects = [],
+          height = textTopOffset, lineOffset;
+      // bounding-box background
+      this._setSVGBg(textBgRects);
+
+      // text and text-background
+      for (var i = 0, len = this._textLines.length; i < len; i++) {
+        lineOffset = this._getLineLeftOffset(i);
+        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
+          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
+        }
+        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
+        height += this.getHeightOfLine(i);
+      }
 
-    return indexOnLine;
-  },
+      return {
+        textSpans: textSpans,
+        textBgRects: textBgRects
+      };
+    },
 
+    /**
+     * @private
+     */
+    _createTextCharSpan: function(_char, styleDecl, left, top) {
+      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
+          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
+          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
+          dy = styleDecl.deltaY, dySpan = '',
+          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
+      if (dy) {
+        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
+      }
+      return [
+        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
+        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
+        fillStyles, '>',
+        fabric.util.string.escapeXml(_char),
+        '</tspan>'
+      ].join('');
+    },
 
-  /**
-   * Moves cursor down
-   * @param {Event} e Event object
-   */
-  moveCursorDown: function(e) {
-    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
-      return;
-    }
-    this._moveCursorUpOrDown('Down', e);
-  },
+    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
+      // set proper line offset
+      var lineHeight = this.getHeightOfLine(lineIndex),
+          isJustify = this.textAlign.indexOf('justify') !== -1,
+          actualStyle,
+          nextStyle,
+          charsToRender = '',
+          charBox, style,
+          boxWidth = 0,
+          line = this._textLines[lineIndex],
+          timeToRender;
 
-  /**
-   * Moves cursor up
-   * @param {Event} e Event object
-   */
-  moveCursorUp: function(e) {
-    if (this.selectionStart === 0 && this.selectionEnd === 0) {
-      return;
-    }
-    this._moveCursorUpOrDown('Up', e);
-  },
+      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
+      for (var i = 0, len = line.length - 1; i <= len; i++) {
+        timeToRender = i === len || this.charSpacing;
+        charsToRender += line[i];
+        charBox = this.__charBounds[lineIndex][i];
+        if (boxWidth === 0) {
+          textLeftOffset += charBox.kernedWidth - charBox.width;
+          boxWidth += charBox.width;
+        }
+        else {
+          boxWidth += charBox.kernedWidth;
+        }
+        if (isJustify && !timeToRender) {
+          if (this._reSpaceAndTab.test(line[i])) {
+            timeToRender = true;
+          }
+        }
+        if (!timeToRender) {
+          // if we have charSpacing, we render char by char
+          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
+          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
+          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
+        }
+        if (timeToRender) {
+          style = this._getStyleDeclaration(lineIndex, i) || { };
+          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
+          charsToRender = '';
+          actualStyle = nextStyle;
+          textLeftOffset += boxWidth;
+          boxWidth = 0;
+        }
+      }
+    },
 
-  /**
-   * Moves cursor up or down, fires the events
-   * @param {String} direction 'Up' or 'Down'
-   * @param {Event} e Event object
-   */
-  _moveCursorUpOrDown: function(direction, e) {
-    // getUpCursorOffset
-    // getDownCursorOffset
-    var action = 'get' + direction + 'CursorOffset',
-        offset = this[action](e, this._selectionDirection === 'right');
-    if (e.shiftKey) {
-      this.moveCursorWithShift(offset);
-    }
-    else {
-      this.moveCursorWithoutShift(offset);
-    }
-    if (offset !== 0) {
-      this.setSelectionInBoundaries();
-      this.abortCursorAnimation();
-      this._currentCursorOpacity = 1;
-      this.initDelayedCursor();
-      this._fireSelectionChanged();
-      this._updateTextarea();
-    }
-  },
+    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
+      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
+      textBgRects.push(
+        '\t\t<rect ',
+        this._getFillAttributes(color),
+        ' x="',
+        toFixed(left, NUM_FRACTION_DIGITS),
+        '" y="',
+        toFixed(top, NUM_FRACTION_DIGITS),
+        '" width="',
+        toFixed(width, NUM_FRACTION_DIGITS),
+        '" height="',
+        toFixed(height, NUM_FRACTION_DIGITS),
+        '"></rect>\n');
+    },
 
-  /**
-   * Moves cursor with shift
-   * @param {Number} offset
-   */
-  moveCursorWithShift: function(offset) {
-    var newSelection = this._selectionDirection === 'left'
-      ? this.selectionStart + offset
-      : this.selectionEnd + offset;
-    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
-    return offset !== 0;
-  },
+    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
+      var line = this._textLines[i],
+          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
+          boxWidth = 0,
+          boxStart = 0,
+          charBox, currentColor,
+          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
+      for (var j = 0, jlen = line.length; j < jlen; j++) {
+        charBox = this.__charBounds[i][j];
+        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
+        if (currentColor !== lastColor) {
+          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
+            textTopOffset, boxWidth, heightOfLine);
+          boxStart = charBox.left;
+          boxWidth = charBox.width;
+          lastColor = currentColor;
+        }
+        else {
+          boxWidth += charBox.kernedWidth;
+        }
+      }
+      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
+        textTopOffset, boxWidth, heightOfLine);
+    },
 
-  /**
-   * Moves cursor up without shift
-   * @param {Number} offset
-   */
-  moveCursorWithoutShift: function(offset) {
-    if (offset < 0) {
-      this.selectionStart += offset;
-      this.selectionEnd = this.selectionStart;
-    }
-    else {
-      this.selectionEnd += offset;
-      this.selectionStart = this.selectionEnd;
-    }
-    return offset !== 0;
-  },
+    /**
+     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
+     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
+     *
+     * @private
+     * @param {*} value
+     * @return {String}
+     */
+    _getFillAttributes: function(value) {
+      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
+      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
+        return 'fill="' + value + '"';
+      }
+      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
+    },
 
-  /**
-   * Moves cursor left
-   * @param {Event} e Event object
-   */
-  moveCursorLeft: function(e) {
-    if (this.selectionStart === 0 && this.selectionEnd === 0) {
-      return;
-    }
-    this._moveCursorLeftOrRight('Left', e);
-  },
+    /**
+     * @private
+     */
+    _getSVGLineTopOffset: function(lineIndex) {
+      var lineTopOffset = 0, lastHeight = 0;
+      for (var j = 0; j < lineIndex; j++) {
+        lineTopOffset += this.getHeightOfLine(j);
+      }
+      lastHeight = this.getHeightOfLine(j);
+      return {
+        lineTop: lineTopOffset,
+        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
+      };
+    },
 
-  /**
-   * @private
-   * @return {Boolean} true if a change happened
-   */
-  _move: function(e, prop, direction) {
-    var newValue;
-    if (e.altKey) {
-      newValue = this['findWordBoundary' + direction](this[prop]);
-    }
-    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
-      newValue = this['findLineBoundary' + direction](this[prop]);
-    }
-    else {
-      this[prop] += direction === 'Left' ? -1 : 1;
-      return true;
-    }
-    if (typeof newValue !== undefined && this[prop] !== newValue) {
-      this[prop] = newValue;
-      return true;
-    }
-  },
+    /**
+     * Returns styles-string for svg-export
+     * @param {Boolean} skipShadow a boolean to skip shadow filter output
+     * @return {String}
+     */
+    getSvgStyles: function(skipShadow) {
+      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
+      return svgStyle + ' white-space: pre;';
+    },
+  });
+})();
+/* _TO_SVG_END_ */
 
-  /**
-   * @private
-   */
-  _moveLeft: function(e, prop) {
-    return this._move(e, prop, 'Left');
-  },
 
-  /**
-   * @private
-   */
-  _moveRight: function(e, prop) {
-    return this._move(e, prop, 'Right');
-  },
+(function(global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = {});
 
   /**
-   * Moves cursor left without keeping selection
-   * @param {Event} e
+   * Textbox class, based on IText, allows the user to resize the text rectangle
+   * and wraps lines automatically. Textboxes have their Y scaling locked, the
+   * user can only change width. Height is adjusted automatically based on the
+   * wrapping of lines.
+   * @class fabric.Textbox
+   * @extends fabric.IText
+   * @mixes fabric.Observable
+   * @return {fabric.Textbox} thisArg
+   * @see {@link fabric.Textbox#initialize} for constructor definition
    */
-  moveCursorLeftWithoutShift: function(e) {
-    var change = true;
-    this._selectionDirection = 'left';
+  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {
 
-    // only move cursor when there is no selection,
-    // otherwise we discard it, and leave cursor on same place
-    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
-      change = this._moveLeft(e, 'selectionStart');
+    /**
+     * Type of an object
+     * @type String
+     * @default
+     */
+    type: 'textbox',
 
-    }
-    this.selectionEnd = this.selectionStart;
-    return change;
-  },
+    /**
+     * Minimum width of textbox, in pixels.
+     * @type Number
+     * @default
+     */
+    minWidth: 20,
 
-  /**
-   * Moves cursor left while keeping selection
-   * @param {Event} e
-   */
-  moveCursorLeftWithShift: function(e) {
-    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
-      return this._moveLeft(e, 'selectionEnd');
-    }
-    else if (this.selectionStart !== 0){
-      this._selectionDirection = 'left';
-      return this._moveLeft(e, 'selectionStart');
-    }
-  },
+    /**
+     * Minimum calculated width of a textbox, in pixels.
+     * fixed to 2 so that an empty textbox cannot go to 0
+     * and is still selectable without text.
+     * @type Number
+     * @default
+     */
+    dynamicMinWidth: 2,
 
-  /**
-   * Moves cursor right
-   * @param {Event} e Event object
-   */
-  moveCursorRight: function(e) {
-    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
-      return;
-    }
-    this._moveCursorLeftOrRight('Right', e);
-  },
+    /**
+     * Cached array of text wrapping.
+     * @type Array
+     */
+    __cachedLines: null,
 
-  /**
-   * Moves cursor right or Left, fires event
-   * @param {String} direction 'Left', 'Right'
-   * @param {Event} e Event object
-   */
-  _moveCursorLeftOrRight: function(direction, e) {
-    var actionName = 'moveCursor' + direction + 'With';
-    this._currentCursorOpacity = 1;
+    /**
+     * Override standard Object class values
+     */
+    lockScalingFlip: true,
 
-    if (e.shiftKey) {
-      actionName += 'Shift';
-    }
-    else {
-      actionName += 'outShift';
-    }
-    if (this[actionName](e)) {
-      this.abortCursorAnimation();
-      this.initDelayedCursor();
-      this._fireSelectionChanged();
-      this._updateTextarea();
-    }
-  },
+    /**
+     * Override standard Object class values
+     * Textbox needs this on false
+     */
+    noScaleCache: false,
 
-  /**
-   * Moves cursor right while keeping selection
-   * @param {Event} e
-   */
-  moveCursorRightWithShift: function(e) {
-    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
-      return this._moveRight(e, 'selectionStart');
-    }
-    else if (this.selectionEnd !== this._text.length) {
-      this._selectionDirection = 'right';
-      return this._moveRight(e, 'selectionEnd');
-    }
-  },
+    /**
+     * Properties which when set cause object to change dimensions
+     * @type Object
+     * @private
+     */
+    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),
 
-  /**
-   * Moves cursor right without keeping selection
-   * @param {Event} e Event object
-   */
-  moveCursorRightWithoutShift: function(e) {
-    var changed = true;
-    this._selectionDirection = 'right';
+    /**
+     * Use this regular expression to split strings in breakable lines
+     * @private
+     */
+    _wordJoiners: /[ \t\r]/,
 
-    if (this.selectionStart === this.selectionEnd) {
-      changed = this._moveRight(e, 'selectionStart');
-      this.selectionEnd = this.selectionStart;
-    }
-    else {
-      this.selectionStart = this.selectionEnd;
-    }
-    return changed;
-  },
+    /**
+     * Use this boolean property in order to split strings that have no white space concept.
+     * this is a cheap way to help with chinese/japanese
+     * @type Boolean
+     * @since 2.6.0
+     */
+    splitByGrapheme: false,
 
-  /**
-   * Removes characters from start/end
-   * start/end ar per grapheme position in _text array.
-   *
-   * @param {Number} start
-   * @param {Number} end default to start + 1
-   */
-  removeChars: function(start, end) {
-    if (typeof end === 'undefined') {
-      end = start + 1;
-    }
-    this.removeStyleFromTo(start, end);
-    this._text.splice(start, end - start);
-    this.text = this._text.join('');
-    this.set('dirty', true);
-    if (this._shouldClearDimensionCache()) {
-      this.initDimensions();
-      this.setCoords();
-    }
-    this._removeExtraneousStyles();
-  },
+    /**
+     * Unlike superclass's version of this function, Textbox does not update
+     * its width.
+     * @private
+     * @override
+     */
+    initDimensions: function() {
+      if (this.__skipDimension) {
+        return;
+      }
+      this.isEditing && this.initDelayedCursor();
+      this.clearContextTop();
+      this._clearCache();
+      // clear dynamicMinWidth as it will be different after we re-wrap line
+      this.dynamicMinWidth = 0;
+      // wrap lines
+      this._styleMap = this._generateStyleMap(this._splitText());
+      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
+      if (this.dynamicMinWidth > this.width) {
+        this._set('width', this.dynamicMinWidth);
+      }
+      if (this.textAlign.indexOf('justify') !== -1) {
+        // once text is measured we need to make space fatter to make justified text.
+        this.enlargeSpaces();
+      }
+      // clear cache and re-calculate height
+      this.height = this.calcTextHeight();
+      this.saveState({ propertySet: '_dimensionAffectingProps' });
+    },
 
-  /**
-   * insert characters at start position, before start position.
-   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
-   * if style array is provided, it must be as the same length of text in graphemes
-   * if end is provided and is bigger than start, old text is replaced.
-   * start/end ar per grapheme position in _text array.
-   *
-   * @param {String} text text to insert
-   * @param {Array} style array of style objects
-   * @param {Number} start
-   * @param {Number} end default to start + 1
-   */
-  insertChars: function(text, style, start, end) {
-    if (typeof end === 'undefined') {
-      end = start;
-    }
-    if (end > start) {
-      this.removeStyleFromTo(start, end);
-    }
-    var graphemes = fabric.util.string.graphemeSplit(text);
-    this.insertNewStyleBlock(graphemes, start, style);
-    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
-    this.text = this._text.join('');
-    this.set('dirty', true);
-    if (this._shouldClearDimensionCache()) {
-      this.initDimensions();
-      this.setCoords();
-    }
-    this._removeExtraneousStyles();
-  },
+    /**
+     * Generate an object that translates the style object so that it is
+     * broken up by visual lines (new lines and automatic wrapping).
+     * The original text styles object is broken up by actual lines (new lines only),
+     * which is only sufficient for Text / IText
+     * @private
+     */
+    _generateStyleMap: function(textInfo) {
+      var realLineCount     = 0,
+          realLineCharCount = 0,
+          charCount         = 0,
+          map               = {};
 
-});
+      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
+        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
+          realLineCharCount = 0;
+          charCount++;
+          realLineCount++;
+        }
+        else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
+          // this case deals with space's that are removed from end of lines when wrapping
+          realLineCharCount++;
+          charCount++;
+        }
 
+        map[i] = { line: realLineCount, offset: realLineCharCount };
 
-/* _TO_SVG_START_ */
-(function() {
-  var toFixed = fabric.util.toFixed,
-      multipleSpacesRegex = /  +/g;
+        charCount += textInfo.graphemeLines[i].length;
+        realLineCharCount += textInfo.graphemeLines[i].length;
+      }
 
-  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
+      return map;
+    },
 
     /**
-     * Returns SVG representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * Returns true if object has a style property or has it on a specified line
+     * @param {Number} lineIndex
+     * @return {Boolean}
      */
-    _toSVG: function() {
-      var offsets = this._getSVGLeftTopOffsets(),
-          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
-      return this._wrapSVGTextAndBg(textAndBg);
+    styleHas: function(property, lineIndex) {
+      if (this._styleMap && !this.isWrapping) {
+        var map = this._styleMap[lineIndex];
+        if (map) {
+          lineIndex = map.line;
+        }
+      }
+      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
     },
 
     /**
-     * Returns svg representation of an instance
-     * @param {Function} [reviver] Method for further parsing of svg representation.
-     * @return {String} svg representation of an instance
+     * Returns true if object has no styling or no styling in a line
+     * @param {Number} lineIndex , lineIndex is on wrapped lines.
+     * @return {Boolean}
      */
-    toSVG: function(reviver) {
-      return this._createBaseSVGMarkup(
-        this._toSVG(),
-        { reviver: reviver, noStyle: true, withShadow: true }
-      );
+    isEmptyStyles: function(lineIndex) {
+      if (!this.styles) {
+        return true;
+      }
+      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
+          map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
+      if (map) {
+        lineIndex = map.line;
+        offset = map.offset;
+      }
+      if (mapNextLine) {
+        nextLineIndex = mapNextLine.line;
+        shouldLimit = nextLineIndex === lineIndex;
+        nextOffset = mapNextLine.offset;
+      }
+      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
+      for (var p1 in obj) {
+        for (var p2 in obj[p1]) {
+          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
+            // eslint-disable-next-line no-unused-vars
+            for (var p3 in obj[p1][p2]) {
+              return false;
+            }
+          }
+        }
+      }
+      return true;
     },
 
     /**
+     * @param {Number} lineIndex
+     * @param {Number} charIndex
      * @private
      */
-    _getSVGLeftTopOffsets: function() {
-      return {
-        textLeft: -this.width / 2,
-        textTop: -this.height / 2,
-        lineTop: this.getHeightOfLine(0)
-      };
+    _getStyleDeclaration: function(lineIndex, charIndex) {
+      if (this._styleMap && !this.isWrapping) {
+        var map = this._styleMap[lineIndex];
+        if (!map) {
+          return null;
+        }
+        lineIndex = map.line;
+        charIndex = map.offset + charIndex;
+      }
+      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
     },
 
     /**
+     * @param {Number} lineIndex
+     * @param {Number} charIndex
+     * @param {Object} style
      * @private
      */
-    _wrapSVGTextAndBg: function(textAndBg) {
-      var noShadow = true,
-          textDecoration = this.getSvgTextDecoration(this);
-      return [
-        textAndBg.textBgRects.join(''),
-        '\t\t<text xml:space="preserve" ',
-        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
-        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
-        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
-        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
-        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
-        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
-        textAndBg.textSpans.join(''),
-        '</text>\n'
-      ];
+    _setStyleDeclaration: function(lineIndex, charIndex, style) {
+      var map = this._styleMap[lineIndex];
+      lineIndex = map.line;
+      charIndex = map.offset + charIndex;
+
+      this.styles[lineIndex][charIndex] = style;
     },
 
     /**
+     * @param {Number} lineIndex
+     * @param {Number} charIndex
      * @private
-     * @param {Number} textTopOffset Text top offset
-     * @param {Number} textLeftOffset Text left offset
-     * @return {Object}
      */
-    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
-      var textSpans = [],
-          textBgRects = [],
-          height = textTopOffset, lineOffset;
-      // bounding-box background
-      this._setSVGBg(textBgRects);
+    _deleteStyleDeclaration: function(lineIndex, charIndex) {
+      var map = this._styleMap[lineIndex];
+      lineIndex = map.line;
+      charIndex = map.offset + charIndex;
+      delete this.styles[lineIndex][charIndex];
+    },
+
+    /**
+     * probably broken need a fix
+     * Returns the real style line that correspond to the wrapped lineIndex line
+     * Used just to verify if the line does exist or not.
+     * @param {Number} lineIndex
+     * @returns {Boolean} if the line exists or not
+     * @private
+     */
+    _getLineStyle: function(lineIndex) {
+      var map = this._styleMap[lineIndex];
+      return !!this.styles[map.line];
+    },
+
+    /**
+     * Set the line style to an empty object so that is initialized
+     * @param {Number} lineIndex
+     * @param {Object} style
+     * @private
+     */
+    _setLineStyle: function(lineIndex) {
+      var map = this._styleMap[lineIndex];
+      this.styles[map.line] = {};
+    },
+
+    /**
+     * Wraps text using the 'width' property of Textbox. First this function
+     * splits text on newlines, so we preserve newlines entered by the user.
+     * Then it wraps each line using the width of the Textbox by calling
+     * _wrapLine().
+     * @param {Array} lines The string array of text that is split into lines
+     * @param {Number} desiredWidth width you want to wrap to
+     * @returns {Array} Array of lines
+     */
+    _wrapText: function(lines, desiredWidth) {
+      var wrapped = [], i;
+      this.isWrapping = true;
+      for (i = 0; i < lines.length; i++) {
+        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
+      }
+      this.isWrapping = false;
+      return wrapped;
+    },
+
+    /**
+     * Helper function to measure a string of text, given its lineIndex and charIndex offset
+     * it gets called when charBounds are not available yet.
+     * @param {CanvasRenderingContext2D} ctx
+     * @param {String} text
+     * @param {number} lineIndex
+     * @param {number} charOffset
+     * @returns {number}
+     * @private
+     */
+    _measureWord: function(word, lineIndex, charOffset) {
+      var width = 0, prevGrapheme, skipLeft = true;
+      charOffset = charOffset || 0;
+      for (var i = 0, len = word.length; i < len; i++) {
+        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
+        width += box.kernedWidth;
+        prevGrapheme = word[i];
+      }
+      return width;
+    },
+
+    /**
+     * Wraps a line of text using the width of the Textbox and a context.
+     * @param {Array} line The grapheme array that represent the line
+     * @param {Number} lineIndex
+     * @param {Number} desiredWidth width you want to wrap the line to
+     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
+     * @returns {Array} Array of line(s) into which the given text is wrapped
+     * to.
+     */
+    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
+      var lineWidth = 0,
+          splitByGrapheme = this.splitByGrapheme,
+          graphemeLines = [],
+          line = [],
+          // spaces in different languages?
+          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
+          word = '',
+          offset = 0,
+          infix = splitByGrapheme ? '' : ' ',
+          wordWidth = 0,
+          infixWidth = 0,
+          largestWordWidth = 0,
+          lineJustStarted = true,
+          additionalSpace = this._getWidthOfCharSpacing(),
+          reservedSpace = reservedSpace || 0;
+      // fix a difference between split and graphemeSplit
+      if (words.length === 0) {
+        words.push([]);
+      }
+      desiredWidth -= reservedSpace;
+      for (var i = 0; i < words.length; i++) {
+        // if using splitByGrapheme words are already in graphemes.
+        word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
+        wordWidth = this._measureWord(word, lineIndex, offset);
+        offset += word.length;
+
+        lineWidth += infixWidth + wordWidth - additionalSpace;
+        if (lineWidth > desiredWidth && !lineJustStarted) {
+          graphemeLines.push(line);
+          line = [];
+          lineWidth = wordWidth;
+          lineJustStarted = true;
+        }
+        else {
+          lineWidth += additionalSpace;
+        }
+
+        if (!lineJustStarted && !splitByGrapheme) {
+          line.push(infix);
+        }
+        line = line.concat(word);
 
-      // text and text-background
-      for (var i = 0, len = this._textLines.length; i < len; i++) {
-        lineOffset = this._getLineLeftOffset(i);
-        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
-          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
+        infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
+        offset++;
+        lineJustStarted = false;
+        // keep track of largest word
+        if (wordWidth > largestWordWidth) {
+          largestWordWidth = wordWidth;
         }
-        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
-        height += this.getHeightOfLine(i);
       }
 
-      return {
-        textSpans: textSpans,
-        textBgRects: textBgRects
-      };
+      i && graphemeLines.push(line);
+
+      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
+        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
+      }
+      return graphemeLines;
     },
 
     /**
-     * @private
+     * Detect if the text line is ended with an hard break
+     * text and itext do not have wrapping, return false
+     * @param {Number} lineIndex text to split
+     * @return {Boolean}
      */
-    _createTextCharSpan: function(_char, styleDecl, left, top) {
-      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
-          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
-          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
-          dy = styleDecl.deltaY, dySpan = '',
-          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
-      if (dy) {
-        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
+    isEndOfWrapping: function(lineIndex) {
+      if (!this._styleMap[lineIndex + 1]) {
+        // is last line, return true;
+        return true;
       }
-      return [
-        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
-        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
-        fillStyles, '>',
-        fabric.util.string.escapeXml(_char),
-        '</tspan>'
-      ].join('');
+      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
+        // this is last line before a line break, return true;
+        return true;
+      }
+      return false;
     },
 
-    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
-      // set proper line offset
-      var lineHeight = this.getHeightOfLine(lineIndex),
-          isJustify = this.textAlign.indexOf('justify') !== -1,
-          actualStyle,
-          nextStyle,
-          charsToRender = '',
-          charBox, style,
-          boxWidth = 0,
-          line = this._textLines[lineIndex],
-          timeToRender;
+    /**
+     * Detect if a line has a linebreak and so we need to account for it when moving
+     * and counting style.
+     * @return Number
+     */
+    missingNewlineOffset: function(lineIndex) {
+      if (this.splitByGrapheme) {
+        return this.isEndOfWrapping(lineIndex) ? 1 : 0;
+      }
+      return 1;
+    },
 
-      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
-      for (var i = 0, len = line.length - 1; i <= len; i++) {
-        timeToRender = i === len || this.charSpacing;
-        charsToRender += line[i];
-        charBox = this.__charBounds[lineIndex][i];
-        if (boxWidth === 0) {
-          textLeftOffset += charBox.kernedWidth - charBox.width;
-          boxWidth += charBox.width;
-        }
-        else {
-          boxWidth += charBox.kernedWidth;
-        }
-        if (isJustify && !timeToRender) {
-          if (this._reSpaceAndTab.test(line[i])) {
-            timeToRender = true;
-          }
-        }
-        if (!timeToRender) {
-          // if we have charSpacing, we render char by char
-          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
-          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
-          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
-        }
-        if (timeToRender) {
-          style = this._getStyleDeclaration(lineIndex, i) || { };
-          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
-          charsToRender = '';
-          actualStyle = nextStyle;
-          textLeftOffset += boxWidth;
-          boxWidth = 0;
-        }
+    /**
+    * Gets lines of text to render in the Textbox. This function calculates
+    * text wrapping on the fly every time it is called.
+    * @param {String} text text to split
+    * @returns {Array} Array of lines in the Textbox.
+    * @override
+    */
+    _splitTextIntoLines: function(text) {
+      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
+          graphemeLines = this._wrapText(newText.lines, this.width),
+          lines = new Array(graphemeLines.length);
+      for (var i = 0; i < graphemeLines.length; i++) {
+        lines[i] = graphemeLines[i].join('');
       }
+      newText.lines = lines;
+      newText.graphemeLines = graphemeLines;
+      return newText;
     },
 
-    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
-      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
-      textBgRects.push(
-        '\t\t<rect ',
-        this._getFillAttributes(color),
-        ' x="',
-        toFixed(left, NUM_FRACTION_DIGITS),
-        '" y="',
-        toFixed(top, NUM_FRACTION_DIGITS),
-        '" width="',
-        toFixed(width, NUM_FRACTION_DIGITS),
-        '" height="',
-        toFixed(height, NUM_FRACTION_DIGITS),
-        '"></rect>\n');
+    getMinWidth: function() {
+      return Math.max(this.minWidth, this.dynamicMinWidth);
     },
 
-    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
-      var line = this._textLines[i],
-          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
-          boxWidth = 0,
-          boxStart = 0,
-          charBox, currentColor,
-          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
-      for (var j = 0, jlen = line.length; j < jlen; j++) {
-        charBox = this.__charBounds[i][j];
-        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
-        if (currentColor !== lastColor) {
-          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
-            textTopOffset, boxWidth, heightOfLine);
-          boxStart = charBox.left;
-          boxWidth = charBox.width;
-          lastColor = currentColor;
+    _removeExtraneousStyles: function() {
+      var linesToKeep = {};
+      for (var prop in this._styleMap) {
+        if (this._textLines[prop]) {
+          linesToKeep[this._styleMap[prop].line] = 1;
         }
-        else {
-          boxWidth += charBox.kernedWidth;
+      }
+      for (var prop in this.styles) {
+        if (!linesToKeep[prop]) {
+          delete this.styles[prop];
         }
       }
-      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
-        textTopOffset, boxWidth, heightOfLine);
     },
 
     /**
-     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
-     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
-     *
-     * @private
-     * @param {*} value
-     * @return {String}
+     * Returns object representation of an instance
+     * @method toObject
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} object representation of an instance
      */
-    _getFillAttributes: function(value) {
-      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
-      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
-        return 'fill="' + value + '"';
-      }
-      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
-    },
+    toObject: function(propertiesToInclude) {
+      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
+    }
+  });
 
-    /**
-     * @private
-     */
-    _getSVGLineTopOffset: function(lineIndex) {
-      var lineTopOffset = 0, lastHeight = 0;
-      for (var j = 0; j < lineIndex; j++) {
-        lineTopOffset += this.getHeightOfLine(j);
-      }
-      lastHeight = this.getHeightOfLine(j);
-      return {
-        lineTop: lineTopOffset,
-        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
-      };
-    },
+  /**
+   * Returns fabric.Textbox instance from an object representation
+   * @static
+   * @memberOf fabric.Textbox
+   * @param {Object} object Object to create an instance from
+   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
+   */
+  fabric.Textbox.fromObject = function(object, callback) {
+    return fabric.Object._fromObject('Textbox', object, callback, 'text');
+  };
+})(typeof exports !== 'undefined' ? exports : this);
 
-    /**
-     * Returns styles-string for svg-export
-     * @param {Boolean} skipShadow a boolean to skip shadow filter output
-     * @return {String}
-     */
-    getSvgStyles: function(skipShadow) {
-      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
-      return svgStyle + ' white-space: pre;';
-    },
+
+(function() {
+
+  var controlsUtils = fabric.controlsUtils,
+      scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler,
+      scaleStyleHandler = controlsUtils.scaleCursorStyleHandler,
+      scalingEqually = controlsUtils.scalingEqually,
+      scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX,
+      scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY,
+      scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName,
+      objectControls = fabric.Object.prototype.controls;
+
+  objectControls.ml = new fabric.Control({
+    x: -0.5,
+    y: 0,
+    cursorStyleHandler: scaleSkewStyleHandler,
+    actionHandler: scalingXOrSkewingY,
+    getActionName: scaleOrSkewActionName,
+  });
+
+  objectControls.mr = new fabric.Control({
+    x: 0.5,
+    y: 0,
+    cursorStyleHandler: scaleSkewStyleHandler,
+    actionHandler: scalingXOrSkewingY,
+    getActionName: scaleOrSkewActionName,
+  });
+
+  objectControls.mb = new fabric.Control({
+    x: 0,
+    y: 0.5,
+    cursorStyleHandler: scaleSkewStyleHandler,
+    actionHandler: scalingYOrSkewingX,
+    getActionName: scaleOrSkewActionName,
   });
-})();
-/* _TO_SVG_END_ */
 
+  objectControls.mt = new fabric.Control({
+    x: 0,
+    y: -0.5,
+    cursorStyleHandler: scaleSkewStyleHandler,
+    actionHandler: scalingYOrSkewingX,
+    getActionName: scaleOrSkewActionName,
+  });
 
-(function(global) {
+  objectControls.tl = new fabric.Control({
+    x: -0.5,
+    y: -0.5,
+    cursorStyleHandler: scaleStyleHandler,
+    actionHandler: scalingEqually
+  });
 
-  'use strict';
+  objectControls.tr = new fabric.Control({
+    x: 0.5,
+    y: -0.5,
+    cursorStyleHandler: scaleStyleHandler,
+    actionHandler: scalingEqually
+  });
 
-  var fabric = global.fabric || (global.fabric = {});
+  objectControls.bl = new fabric.Control({
+    x: -0.5,
+    y: 0.5,
+    cursorStyleHandler: scaleStyleHandler,
+    actionHandler: scalingEqually
+  });
 
-  /**
-   * Textbox class, based on IText, allows the user to resize the text rectangle
-   * and wraps lines automatically. Textboxes have their Y scaling locked, the
-   * user can only change width. Height is adjusted automatically based on the
-   * wrapping of lines.
-   * @class fabric.Textbox
-   * @extends fabric.IText
-   * @mixes fabric.Observable
-   * @return {fabric.Textbox} thisArg
-   * @see {@link fabric.Textbox#initialize} for constructor definition
-   */
-  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {
+  objectControls.br = new fabric.Control({
+    x: 0.5,
+    y: 0.5,
+    cursorStyleHandler: scaleStyleHandler,
+    actionHandler: scalingEqually
+  });
 
-    /**
-     * Type of an object
-     * @type String
-     * @default
-     */
-    type: 'textbox',
+  objectControls.mtr = new fabric.Control({
+    x: 0,
+    y: -0.5,
+    actionHandler: controlsUtils.rotationWithSnapping,
+    cursorStyleHandler: controlsUtils.rotationStyleHandler,
+    offsetY: -40,
+    withConnection: true,
+    actionName: 'rotate',
+  });
 
-    /**
-     * Minimum width of textbox, in pixels.
-     * @type Number
-     * @default
-     */
-    minWidth: 20,
+  if (fabric.Textbox) {
+    // this is breaking the prototype inheritance, no time / ideas to fix it.
+    // is important to document that if you want to have all objects to have a
+    // specific custom control, you have to add it to Object prototype and to Textbox
+    // prototype. The controls are shared as references. So changes to control `tr`
+    // can still apply to all objects if needed.
+    var textBoxControls = fabric.Textbox.prototype.controls = { };
 
-    /**
-     * Minimum calculated width of a textbox, in pixels.
-     * fixed to 2 so that an empty textbox cannot go to 0
-     * and is still selectable without text.
-     * @type Number
-     * @default
-     */
-    dynamicMinWidth: 2,
+    textBoxControls.mtr = objectControls.mtr;
+    textBoxControls.tr = objectControls.tr;
+    textBoxControls.br = objectControls.br;
+    textBoxControls.tl = objectControls.tl;
+    textBoxControls.bl = objectControls.bl;
+    textBoxControls.mt = objectControls.mt;
+    textBoxControls.mb = objectControls.mb;
 
-    /**
-     * Cached array of text wrapping.
-     * @type Array
-     */
-    __cachedLines: null,
+    textBoxControls.mr = new fabric.Control({
+      x: 0.5,
+      y: 0,
+      actionHandler: controlsUtils.changeWidth,
+      cursorStyleHandler: scaleSkewStyleHandler,
+      actionName: 'resizing',
+    });
 
-    /**
-     * Override standard Object class values
-     */
-    lockScalingFlip: true,
+    textBoxControls.ml = new fabric.Control({
+      x: -0.5,
+      y: 0,
+      actionHandler: controlsUtils.changeWidth,
+      cursorStyleHandler: scaleSkewStyleHandler,
+      actionName: 'resizing',
+    });
+  }
+})();
 
-    /**
-     * Override standard Object class values
-     * Textbox needs this on false
-     */
-    noScaleCache: false,
 
-    /**
-     * Properties which when set cause object to change dimensions
-     * @type Object
-     * @private
+(function () {
+  /** ERASER_START */
+  var __set = fabric.Object.prototype._set;
+  var _render = fabric.Object.prototype.render;
+  var _toObject = fabric.Object.prototype.toObject;
+  var __createBaseSVGMarkup = fabric.Object.prototype._createBaseSVGMarkup;
+  /**
+   * @fires erasing:end
+   */
+  fabric.util.object.extend(fabric.Object.prototype, {
+    /**
+     * Indicates whether this object can be erased by {@link fabric.EraserBrush}
+     * The `deep` option introduces fine grained control over a group's `erasable` property.
+     * When set to `deep` the eraser will erase nested objects if they are erasable, leaving the group and the other objects untouched.
+     * When set to `true` the eraser will erase the entire group. Once the group changes the eraser is propagated to its children for proper functionality.
+     * When set to `false` the eraser will leave all objects including the group untouched.
+     * @tutorial {@link http://fabricjs.com/erasing#erasable_property}
+     * @type boolean | 'deep'
+     * @default true
      */
-    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),
+    erasable: true,
 
     /**
-     * Use this regular expression to split strings in breakable lines
-     * @private
+     *
+     * @returns {fabric.Group | undefined}
      */
-    _wordJoiners: /[ \t\r]/,
+    getEraser: function () {
+      return this.clipPath && this.clipPath.eraser ? this.clipPath : undefined;
+    },
 
     /**
-     * Use this boolean property in order to split strings that have no white space concept.
-     * this is a cheap way to help with chinese/japanese
-     * @type Boolean
-     * @since 2.6.0
+     * Get the object's actual clip path regardless of clipping done by erasing
+     * @returns {fabric.Object | undefined}
      */
-    splitByGrapheme: false,
+    getClipPath: function () {
+      var eraser = this.getEraser();
+      return eraser ? eraser._objects[0].clipPath : this.clipPath;
+    },
 
     /**
-     * Unlike superclass's version of this function, Textbox does not update
-     * its width.
-     * @private
-     * @override
+     * Set the object's actual clip path regardless of clipping done by erasing
+     * @param {fabric.Object} [clipPath]
      */
-    initDimensions: function() {
-      if (this.__skipDimension) {
-        return;
-      }
-      this.isEditing && this.initDelayedCursor();
-      this.clearContextTop();
-      this._clearCache();
-      // clear dynamicMinWidth as it will be different after we re-wrap line
-      this.dynamicMinWidth = 0;
-      // wrap lines
-      this._styleMap = this._generateStyleMap(this._splitText());
-      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
-      if (this.dynamicMinWidth > this.width) {
-        this._set('width', this.dynamicMinWidth);
-      }
-      if (this.textAlign.indexOf('justify') !== -1) {
-        // once text is measured we need to make space fatter to make justified text.
-        this.enlargeSpaces();
-      }
-      // clear cache and re-calculate height
-      this.height = this.calcTextHeight();
-      this.saveState({ propertySet: '_dimensionAffectingProps' });
+    setClipPath: function (clipPath) {
+      var eraser = this.getEraser();
+      var target = eraser ? eraser._objects[0] : this;
+      target.set('clipPath', clipPath);
+      this.set('dirty', true);
     },
 
     /**
-     * Generate an object that translates the style object so that it is
-     * broken up by visual lines (new lines and automatic wrapping).
-     * The original text styles object is broken up by actual lines (new lines only),
-     * which is only sufficient for Text / IText
+     * Updates eraser size and position to match object's size
      * @private
+     * @param {Object} [dimensions] uses object's dimensions if unspecified
+     * @param {number} [dimensions.width]
+     * @param {number} [dimensions.height]
+     * @param {boolean} [center=false] postion the eraser relative to object's center or it's top left corner
      */
-    _generateStyleMap: function(textInfo) {
-      var realLineCount     = 0,
-          realLineCharCount = 0,
-          charCount         = 0,
-          map               = {};
-
-      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
-        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
-          realLineCharCount = 0;
-          charCount++;
-          realLineCount++;
+    _updateEraserDimensions: function (dimensions, center) {
+      var eraser = this.getEraser();
+      if (eraser) {
+        var rect = eraser._objects[0];
+        var eraserSize = { width: rect.width, height: rect.height };
+        var size = this._getNonTransformedDimensions();
+        var newSize = fabric.util.object.extend({ width: size.x, height: size.y }, dimensions);
+        if (eraserSize.width === newSize.width && eraserSize.height === newSize.height) {
+          return;
         }
-        else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
-          // this case deals with space's that are removed from end of lines when wrapping
-          realLineCharCount++;
-          charCount++;
+        var offset = new fabric.Point((eraserSize.width - newSize.width) / 2, (eraserSize.height - newSize.height) / 2);
+        eraser.set(newSize);
+        eraser.setPositionByOrigin(new fabric.Point(0, 0), 'center', 'center');
+        rect.set(newSize);
+        eraser.set('dirty', true);
+        if (!center) {
+          eraser.getObjects('path').forEach(function (path) {
+            path.setPositionByOrigin(path.getCenterPoint().add(offset), 'center', 'center');
+          });
         }
-
-        map[i] = { line: realLineCount, offset: realLineCharCount };
-
-        charCount += textInfo.graphemeLines[i].length;
-        realLineCharCount += textInfo.graphemeLines[i].length;
+        this.setCoords();
       }
-
-      return map;
     },
 
-    /**
-     * Returns true if object has a style property or has it on a specified line
-     * @param {Number} lineIndex
-     * @return {Boolean}
-     */
-    styleHas: function(property, lineIndex) {
-      if (this._styleMap && !this.isWrapping) {
-        var map = this._styleMap[lineIndex];
-        if (map) {
-          lineIndex = map.line;
-        }
+    _set: function (key, value) {
+      __set.call(this, key, value);
+      if (key === 'width' || key === 'height') {
+        this._updateEraserDimensions();
       }
-      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
+      return this;
     },
 
-    /**
-     * Returns true if object has no styling or no styling in a line
-     * @param {Number} lineIndex , lineIndex is on wrapped lines.
-     * @return {Boolean}
-     */
-    isEmptyStyles: function(lineIndex) {
-      if (!this.styles) {
-        return true;
-      }
-      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
-          map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
-      if (map) {
-        lineIndex = map.line;
-        offset = map.offset;
-      }
-      if (mapNextLine) {
-        nextLineIndex = mapNextLine.line;
-        shouldLimit = nextLineIndex === lineIndex;
-        nextOffset = mapNextLine.offset;
-      }
-      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
-      for (var p1 in obj) {
-        for (var p2 in obj[p1]) {
-          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
-            // eslint-disable-next-line no-unused-vars
-            for (var p3 in obj[p1][p2]) {
-              return false;
-            }
-          }
-        }
-      }
-      return true;
+    render: function (ctx) {
+      this._updateEraserDimensions();
+      _render.call(this, ctx);
     },
 
     /**
-     * @param {Number} lineIndex
-     * @param {Number} charIndex
-     * @private
+     * Returns an object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} Object representation of an instance
      */
-    _getStyleDeclaration: function(lineIndex, charIndex) {
-      if (this._styleMap && !this.isWrapping) {
-        var map = this._styleMap[lineIndex];
-        if (!map) {
-          return null;
-        }
-        lineIndex = map.line;
-        charIndex = map.offset + charIndex;
+    toObject: function (additionalProperties) {
+      return _toObject.call(this, ['erasable'].concat(additionalProperties));
+    },
+
+    /**
+     * use <mask> to achieve erasing for svg
+     * credit: https://travishorn.com/removing-parts-of-shapes-in-svg-b539a89e5649
+     * @param {Function} reviver
+     * @returns {string} markup
+     */
+    eraserToSVG: function (options) {
+      var eraser = this.getEraser();
+      if (eraser) {
+        var fill = eraser._objects[0].fill;
+        eraser._objects[0].fill = 'white';
+        eraser.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
+        var commons = [
+          'id="' + eraser.clipPathId + '"',
+          /*options.additionalTransform ? ' transform="' + options.additionalTransform + '" ' : ''*/
+        ].join(' ');
+        var objectMarkup = ['<defs>', '<mask ' + commons + ' >', eraser.toSVG(options.reviver), '</mask>', '</defs>'];
+        eraser._objects[0].fill = fill;
+        return objectMarkup.join('\n');
       }
-      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
+      return '';
     },
 
     /**
-     * @param {Number} lineIndex
-     * @param {Number} charIndex
-     * @param {Object} style
+     * use <mask> to achieve erasing for svg, override <clipPath>
+     * @param {string[]} objectMarkup
+     * @param {Object} options
+     * @returns
+     */
+    _createBaseSVGMarkup: function (objectMarkup, options) {
+      var eraser = this.getEraser();
+      if (eraser) {
+        var eraserMarkup = this.eraserToSVG(options);
+        this.clipPath = null;
+        var markup = __createBaseSVGMarkup.call(this, objectMarkup, options);
+        this.clipPath = eraser;
+        return [
+          eraserMarkup,
+          markup.replace('>', 'mask="url(#' + eraser.clipPathId + ')" >')
+        ].join('\n');
+      }
+      else {
+        return __createBaseSVGMarkup.call(this, objectMarkup, options);
+      }
+    }
+  });
+
+  var __restoreObjectsState = fabric.Group.prototype._restoreObjectsState;
+  var _groupToObject = fabric.Group.prototype.toObject;
+  var __getBounds = fabric.Group.prototype._getBounds;
+  fabric.util.object.extend(fabric.Group.prototype, {
+
+    /**
+     * If group is an eraser then dimensions should not change when paths are added or removed and should remain the size of the base rect
      * @private
      */
-    _setStyleDeclaration: function(lineIndex, charIndex, style) {
-      var map = this._styleMap[lineIndex];
-      lineIndex = map.line;
-      charIndex = map.offset + charIndex;
-
-      this.styles[lineIndex][charIndex] = style;
+    _getBounds: function (aX, aY, onlyWidthHeight) {
+      if (this.eraser) {
+        this.width = this._objects[0].width;
+        this.height = this._objects[0].height;
+        return;
+      }
+      __getBounds.call(this, aX, aY, onlyWidthHeight);
     },
 
     /**
-     * @param {Number} lineIndex
-     * @param {Number} charIndex
      * @private
+     * @param {fabric.Path} path
      */
-    _deleteStyleDeclaration: function(lineIndex, charIndex) {
-      var map = this._styleMap[lineIndex];
-      lineIndex = map.line;
-      charIndex = map.offset + charIndex;
-      delete this.styles[lineIndex][charIndex];
+    _addEraserPathToObjects: function (path) {
+      this._objects.forEach(function (object) {
+        fabric.EraserBrush.prototype._addPathToObjectEraser.call(
+          fabric.EraserBrush.prototype,
+          object,
+          path
+        );
+      });
     },
 
     /**
-     * probably broken need a fix
-     * Returns the real style line that correspond to the wrapped lineIndex line
-     * Used just to verify if the line does exist or not.
-     * @param {Number} lineIndex
-     * @returns {Boolean} if the line exists or not
-     * @private
+     * Applies the group's eraser to its objects
+     * @tutorial {@link http://fabricjs.com/erasing#erasable_property}
      */
-    _getLineStyle: function(lineIndex) {
-      var map = this._styleMap[lineIndex];
-      return !!this.styles[map.line];
+    applyEraserToObjects: function () {
+      var _this = this;
+      if (this.getEraser()) {
+        var transform = _this.calcTransformMatrix();
+        _this.getEraser().clone(function (eraser) {
+          var clipPath = eraser._objects[0].clipPath;
+          _this.clipPath = clipPath ? clipPath : undefined;
+          eraser.getObjects('path')
+            .forEach(function (path) {
+              //  first we transform the path from the group's coordinate system to the canvas'
+              var originalTransform = fabric.util.multiplyTransformMatrices(
+                transform,
+                path.calcTransformMatrix()
+              );
+              fabric.util.applyTransformToObject(path, originalTransform);
+              if (clipPath) {
+                clipPath.clone(function (_clipPath) {
+                  fabric.EraserBrush.prototype.applyClipPathToPath.call(
+                    fabric.EraserBrush.prototype,
+                    path,
+                    _clipPath,
+                    transform
+                  );
+                  _this._addEraserPathToObjects(path);
+                });
+              }
+              else {
+                _this._addEraserPathToObjects(path);
+              }
+            });
+        });
+      }
     },
 
     /**
-     * Set the line style to an empty object so that is initialized
-     * @param {Number} lineIndex
-     * @param {Object} style
+     * Propagate the group's eraser to its objects, crucial for proper functionality of the eraser within the group and nested objects.
      * @private
      */
-    _setLineStyle: function(lineIndex) {
-      var map = this._styleMap[lineIndex];
-      this.styles[map.line] = {};
+    _restoreObjectsState: function () {
+      this.erasable === true && this.applyEraserToObjects();
+      return __restoreObjectsState.call(this);
     },
 
     /**
-     * Wraps text using the 'width' property of Textbox. First this function
-     * splits text on newlines, so we preserve newlines entered by the user.
-     * Then it wraps each line using the width of the Textbox by calling
-     * _wrapLine().
-     * @param {Array} lines The string array of text that is split into lines
-     * @param {Number} desiredWidth width you want to wrap to
-     * @returns {Array} Array of lines
+     * Returns an object representation of an instance
+     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
+     * @return {Object} Object representation of an instance
      */
-    _wrapText: function(lines, desiredWidth) {
-      var wrapped = [], i;
-      this.isWrapping = true;
-      for (i = 0; i < lines.length; i++) {
-        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
-      }
-      this.isWrapping = false;
-      return wrapped;
-    },
+    toObject: function (additionalProperties) {
+      return _groupToObject.call(this, ['eraser'].concat(additionalProperties));
+    }
+  });
 
+  /**
+   * @fires erasing:start
+   * @fires erasing:end
+   */
+  fabric.util.object.extend(fabric.Canvas.prototype, {
     /**
-     * Helper function to measure a string of text, given its lineIndex and charIndex offset
-     * it gets called when charBounds are not available yet.
-     * @param {CanvasRenderingContext2D} ctx
-     * @param {String} text
-     * @param {number} lineIndex
-     * @param {number} charOffset
-     * @returns {number}
-     * @private
+     * Used by {@link #renderAll}
+     * @returns boolean
      */
-    _measureWord: function(word, lineIndex, charOffset) {
-      var width = 0, prevGrapheme, skipLeft = true;
-      charOffset = charOffset || 0;
-      for (var i = 0, len = word.length; i < len; i++) {
-        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
-        width += box.kernedWidth;
-        prevGrapheme = word[i];
-      }
-      return width;
+    isErasing: function () {
+      return (
+        this.isDrawingMode &&
+        this.freeDrawingBrush &&
+        this.freeDrawingBrush.type === 'eraser' &&
+        this.freeDrawingBrush._isErasing
+      );
     },
 
     /**
-     * Wraps a line of text using the width of the Textbox and a context.
-     * @param {Array} line The grapheme array that represent the line
-     * @param {Number} lineIndex
-     * @param {Number} desiredWidth width you want to wrap the line to
-     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
-     * @returns {Array} Array of line(s) into which the given text is wrapped
-     * to.
+     * While erasing, the brush is in charge of rendering the canvas
+     * It uses both layers to achieve diserd erasing effect
+     *
+     * @returns fabric.Canvas
      */
-    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
-      var lineWidth = 0,
-          splitByGrapheme = this.splitByGrapheme,
-          graphemeLines = [],
-          line = [],
-          // spaces in different languages?
-          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
-          word = '',
-          offset = 0,
-          infix = splitByGrapheme ? '' : ' ',
-          wordWidth = 0,
-          infixWidth = 0,
-          largestWordWidth = 0,
-          lineJustStarted = true,
-          additionalSpace = this._getWidthOfCharSpacing(),
-          reservedSpace = reservedSpace || 0;
-      // fix a difference between split and graphemeSplit
-      if (words.length === 0) {
-        words.push([]);
+    renderAll: function () {
+      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
+        this.clearContext(this.contextTop);
+        this.contextTopDirty = false;
       }
-      desiredWidth -= reservedSpace;
-      for (var i = 0; i < words.length; i++) {
-        // if using splitByGrapheme words are already in graphemes.
-        word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
-        wordWidth = this._measureWord(word, lineIndex, offset);
-        offset += word.length;
+      // while erasing the brush is in charge of rendering the canvas so we return
+      if (this.isErasing()) {
+        this.freeDrawingBrush._render();
+        return;
+      }
+      if (this.hasLostContext) {
+        this.renderTopLayer(this.contextTop);
+      }
+      var canvasToDrawOn = this.contextContainer;
+      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
+      return this;
+    }
+  });
 
-        lineWidth += infixWidth + wordWidth - additionalSpace;
-        if (lineWidth > desiredWidth && !lineJustStarted) {
-          graphemeLines.push(line);
-          line = [];
-          lineWidth = wordWidth;
-          lineJustStarted = true;
+  /**
+   * EraserBrush class
+   * Supports selective erasing meaning that only erasable objects are affected by the eraser brush.
+   * In order to support selective erasing all non erasable objects are rendered on the main/bottom ctx
+   * while the entire canvas is rendered on the top ctx.
+   * Canvas background/overlay images are handled as well.
+   * When erasing occurs, the path clips the top ctx and reveals the bottom ctx.
+   * This achieves the desired effect of seeming to erase only erasable objects.
+   * After erasing is done the created path is added to all intersected objects' `clipPath` property.
+   *
+   * @tutorial {@link http://fabricjs.com/erasing}
+   * @class fabric.EraserBrush
+   * @extends fabric.PencilBrush
+   */
+  fabric.EraserBrush = fabric.util.createClass(
+    fabric.PencilBrush,
+    /** @lends fabric.EraserBrush.prototype */ {
+      type: 'eraser',
+
+      /**
+       * Indicates that the ctx is ready and rendering can begin.
+       * Used to prevent a race condition caused by {@link fabric.EraserBrush#onMouseMove} firing before {@link fabric.EraserBrush#onMouseDown} has completed
+       *
+       * @private
+       */
+      _ready: false,
+
+      /**
+       * @private
+       */
+      _drawOverlayOnTop: false,
+
+      /**
+       * @private
+       */
+      _isErasing: false,
+
+      initialize: function (canvas) {
+        this.callSuper('initialize', canvas);
+        this._renderBound = this._render.bind(this);
+        this.render = this.render.bind(this);
+      },
+
+      /**
+       * Used to hide a drawable from the rendering process
+       * @param {fabric.Object} object
+       */
+      hideObject: function (object) {
+        if (object) {
+          object._originalOpacity = object.opacity;
+          object.set({ opacity: 0 });
         }
-        else {
-          lineWidth += additionalSpace;
+      },
+
+      /**
+       * Restores hiding an object
+       * {@link fabric.EraserBrush#hideObject}
+       * @param {fabric.Object} object
+       */
+      restoreObjectVisibility: function (object) {
+        if (object && object._originalOpacity) {
+          object.set({ opacity: object._originalOpacity });
+          object._originalOpacity = undefined;
         }
+      },
 
-        if (!lineJustStarted && !splitByGrapheme) {
-          line.push(infix);
+      /**
+       *
+       * @private
+       * @param {fabric.Object} object
+       * @returns boolean
+       */
+      _isErasable: function (object) {
+        return object.erasable !== false;
+      },
+
+      /**
+       * Drawing Logic For background drawables: (`backgroundImage`)
+       * 1. if erasable = true:
+       *    we need to hide the drawable on the bottom ctx so when the brush is erasing it will clip the top ctx and reveal white space underneath
+       * 2. if erasable = false:
+       *    we need to draw the drawable only on the bottom ctx so the brush won't affect it
+       * @param {'bottom' | 'top' | 'overlay'} layer
+       */
+      prepareCanvasBackgroundForLayer: function (layer) {
+        if (layer === 'overlay') {
+          return;
         }
-        line = line.concat(word);
+        var canvas = this.canvas;
+        var image = canvas.backgroundImage;
+        var erasablesOnLayer = layer === 'top';
+        if (image && this._isErasable(image) === !erasablesOnLayer) {
+          this.hideObject(image);
+        }
+      },
 
-        infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
-        offset++;
-        lineJustStarted = false;
-        // keep track of largest word
-        if (wordWidth > largestWordWidth) {
-          largestWordWidth = wordWidth;
+      /**
+       * Drawing Logic For overlay drawables (`overlayImage`)
+       * We must draw on top ctx to be on top of visible canvas
+       * 1. if erasable = true:
+       *    we need to draw the drawable on the top ctx as a normal object
+       * 2. if erasable = false:
+       *    we need to draw the drawable on top of the brush,
+       *    this means we need to repaint for every stroke
+       *
+       * @param {'bottom' | 'top' | 'overlay'} layer
+       * @returns boolean render overlay above brush
+       */
+      prepareCanvasOverlayForLayer: function (layer) {
+        var canvas = this.canvas;
+        var image = canvas.overlayImage;
+        var hasOverlayColor = !!canvas.overlayColor;
+        if (canvas.overlayColor && layer !== 'overlay') {
+          this.__overlayColor = canvas.overlayColor;
+          delete canvas.overlayColor;
+        }
+        if (layer === 'bottom') {
+          this.hideObject(image);
+          return false;
+        };
+        var erasablesOnLayer = layer === 'top';
+        var renderOverlayOnTop = (image && !this._isErasable(image)) || hasOverlayColor;
+        if (image && this._isErasable(image) === !erasablesOnLayer) {
+          this.hideObject(image);
         }
-      }
+        return renderOverlayOnTop;
+      },
 
-      i && graphemeLines.push(line);
+      /**
+       * @private
+       */
+      restoreCanvasDrawables: function () {
+        var canvas = this.canvas;
+        if (this.__overlayColor) {
+          canvas.overlayColor = this.__overlayColor;
+          delete this.__overlayColor;
+        }
+        this.restoreObjectVisibility(canvas.backgroundImage);
+        this.restoreObjectVisibility(canvas.overlayImage);
+      },
 
-      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
-        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
-      }
-      return graphemeLines;
-    },
+      /**
+       * @private
+       * This is designed to support erasing a group with both erasable and non-erasable objects.
+       * Iterates over collections to allow nested selective erasing.
+       * Used by {@link fabric.EraserBrush#prepareCanvasObjectsForLayer}
+       * to prepare the bottom layer by hiding erasable nested objects
+       *
+       * @param {fabric.Collection} collection
+       */
+      prepareCollectionTraversal: function (collection) {
+        var _this = this;
+        collection.forEachObject(function (obj) {
+          if (obj.forEachObject && obj.erasable === 'deep') {
+            _this.prepareCollectionTraversal(obj);
+          }
+          else if (obj.erasable) {
+            _this.hideObject(obj);
+          }
+        });
+      },
 
-    /**
-     * Detect if the text line is ended with an hard break
-     * text and itext do not have wrapping, return false
-     * @param {Number} lineIndex text to split
-     * @return {Boolean}
-     */
-    isEndOfWrapping: function(lineIndex) {
-      if (!this._styleMap[lineIndex + 1]) {
-        // is last line, return true;
-        return true;
-      }
-      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
-        // this is last line before a line break, return true;
-        return true;
-      }
-      return false;
-    },
+      /**
+       * @private
+       * Used by {@link fabric.EraserBrush#prepareCanvasObjectsForLayer}
+       * to reverse the action of {@link fabric.EraserBrush#prepareCollectionTraversal}
+       *
+       * @param {fabric.Collection} collection
+       */
+      restoreCollectionTraversal: function (collection) {
+        var _this = this;
+        collection.forEachObject(function (obj) {
+          if (obj.forEachObject && obj.erasable === 'deep') {
+            _this.restoreCollectionTraversal(obj);
+          }
+          else {
+            _this.restoreObjectVisibility(obj);
+          }
+        });
+      },
 
-    /**
-     * Detect if a line has a linebreak and so we need to account for it when moving
-     * and counting style.
-     * @return Number
-     */
-    missingNewlineOffset: function(lineIndex) {
-      if (this.splitByGrapheme) {
-        return this.isEndOfWrapping(lineIndex) ? 1 : 0;
-      }
-      return 1;
-    },
+      /**
+       * @private
+       * This is designed to support erasing a group with both erasable and non-erasable objects.
+       *
+       * @param {'bottom' | 'top' | 'overlay'} layer
+       */
+      prepareCanvasObjectsForLayer: function (layer) {
+        if (layer !== 'bottom') { return; }
+        this.prepareCollectionTraversal(this.canvas);
+      },
 
-    /**
-    * Gets lines of text to render in the Textbox. This function calculates
-    * text wrapping on the fly every time it is called.
-    * @param {String} text text to split
-    * @returns {Array} Array of lines in the Textbox.
-    * @override
-    */
-    _splitTextIntoLines: function(text) {
-      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
-          graphemeLines = this._wrapText(newText.lines, this.width),
-          lines = new Array(graphemeLines.length);
-      for (var i = 0; i < graphemeLines.length; i++) {
-        lines[i] = graphemeLines[i].join('');
-      }
-      newText.lines = lines;
-      newText.graphemeLines = graphemeLines;
-      return newText;
-    },
+      /**
+       * @private
+       * @param {'bottom' | 'top' | 'overlay'} layer
+       */
+      restoreCanvasObjectsFromLayer: function (layer) {
+        if (layer !== 'bottom') { return; }
+        this.restoreCollectionTraversal(this.canvas);
+      },
 
-    getMinWidth: function() {
-      return Math.max(this.minWidth, this.dynamicMinWidth);
-    },
+      /**
+       * @private
+       * @param {'bottom' | 'top' | 'overlay'} layer
+       * @returns boolean render overlay above brush
+       */
+      prepareCanvasForLayer: function (layer) {
+        this.prepareCanvasBackgroundForLayer(layer);
+        this.prepareCanvasObjectsForLayer(layer);
+        return this.prepareCanvasOverlayForLayer(layer);
+      },
 
-    _removeExtraneousStyles: function() {
-      var linesToKeep = {};
-      for (var prop in this._styleMap) {
-        if (this._textLines[prop]) {
-          linesToKeep[this._styleMap[prop].line] = 1;
-        }
-      }
-      for (var prop in this.styles) {
-        if (!linesToKeep[prop]) {
-          delete this.styles[prop];
-        }
-      }
-    },
+      /**
+      * @private
+      * @param {'bottom' | 'top' | 'overlay'} layer
+      */
+      restoreCanvasFromLayer: function (layer) {
+        this.restoreCanvasDrawables();
+        this.restoreCanvasObjectsFromLayer(layer);
+      },
 
-    /**
-     * Returns object representation of an instance
-     * @method toObject
-     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
-     * @return {Object} object representation of an instance
-     */
-    toObject: function(propertiesToInclude) {
-      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
-    }
-  });
+      /**
+       * Render all non-erasable objects on bottom layer with the exception of overlays to avoid being clipped by the brush.
+       * Groups are rendered for nested selective erasing, non-erasable objects are visible while erasable objects are not.
+       */
+      renderBottomLayer: function () {
+        var canvas = this.canvas;
+        this.prepareCanvasForLayer('bottom');
+        canvas.renderCanvas(
+          canvas.getContext(),
+          canvas.getObjects().filter(function (obj) {
+            return !obj.erasable || obj.forEachObject;
+          })
+        );
+        this.restoreCanvasFromLayer('bottom');
+      },
 
-  /**
-   * Returns fabric.Textbox instance from an object representation
-   * @static
-   * @memberOf fabric.Textbox
-   * @param {Object} object Object to create an instance from
-   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
-   */
-  fabric.Textbox.fromObject = function(object, callback) {
-    return fabric.Object._fromObject('Textbox', object, callback, 'text');
-  };
-})(typeof exports !== 'undefined' ? exports : this);
+      /**
+       * 1. Render all objects on top layer, erasable and non-erasable
+       *    This is important for cases such as overlapping objects, the background object erasable and the foreground object not erasable.
+       * 2. Render the brush
+       */
+      renderTopLayer: function () {
+        var canvas = this.canvas;
+        this._drawOverlayOnTop = this.prepareCanvasForLayer('top');
+        canvas.renderCanvas(
+          canvas.contextTop,
+          canvas.getObjects()
+        );
+        this.callSuper('_render');
+        this.restoreCanvasFromLayer('top');
+      },
 
+      /**
+       * Render all non-erasable overlays on top of the brush so that they won't get erased
+       */
+      renderOverlay: function () {
+        this.prepareCanvasForLayer('overlay');
+        var canvas = this.canvas;
+        var ctx = canvas.contextTop;
+        canvas._renderOverlay(ctx);
+        this.restoreCanvasFromLayer('overlay');
+      },
 
-(function() {
+      /**
+       * @extends @class fabric.BaseBrush
+       * @param {CanvasRenderingContext2D} ctx
+       */
+      _saveAndTransform: function (ctx) {
+        this.callSuper('_saveAndTransform', ctx);
+        ctx.globalCompositeOperation = 'destination-out';
+      },
 
-  var controlsUtils = fabric.controlsUtils,
-      scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler,
-      scaleStyleHandler = controlsUtils.scaleCursorStyleHandler,
-      scalingEqually = controlsUtils.scalingEqually,
-      scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX,
-      scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY,
-      scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName,
-      objectControls = fabric.Object.prototype.controls;
+      /**
+       * We indicate {@link fabric.PencilBrush} to repaint itself if necessary
+       * @returns
+       */
+      needsFullRender: function () {
+        return this.callSuper('needsFullRender') || this._drawOverlayOnTop;
+      },
 
-  objectControls.ml = new fabric.Control({
-    x: -0.5,
-    y: 0,
-    cursorStyleHandler: scaleSkewStyleHandler,
-    actionHandler: scalingXOrSkewingY,
-    getActionName: scaleOrSkewActionName,
-  });
+      /**
+       *
+       * @param {fabric.Point} pointer
+       * @param {fabric.IEvent} options
+       * @returns
+       */
+      onMouseDown: function (pointer, options) {
+        if (!this.canvas._isMainEvent(options.e)) {
+          return;
+        }
+        this._prepareForDrawing(pointer);
+        // capture coordinates immediately
+        // this allows to draw dots (when movement never occurs)
+        this._captureDrawingPath(pointer);
 
-  objectControls.mr = new fabric.Control({
-    x: 0.5,
-    y: 0,
-    cursorStyleHandler: scaleSkewStyleHandler,
-    actionHandler: scalingXOrSkewingY,
-    getActionName: scaleOrSkewActionName,
-  });
+        this._isErasing = true;
+        this.canvas.fire('erasing:start');
+        this._ready = true;
+        this._render();
+      },
 
-  objectControls.mb = new fabric.Control({
-    x: 0,
-    y: 0.5,
-    cursorStyleHandler: scaleSkewStyleHandler,
-    actionHandler: scalingYOrSkewingX,
-    getActionName: scaleOrSkewActionName,
-  });
+      /**
+       * Rendering is done in 4 steps:
+       * 1. Draw all non-erasable objects on bottom ctx with the exception of overlays {@link fabric.EraserBrush#renderBottomLayer}
+       * 2. Draw all objects on top ctx including erasable drawables {@link fabric.EraserBrush#renderTopLayer}
+       * 3. Draw eraser {@link fabric.PencilBrush#_render} at {@link fabric.EraserBrush#renderTopLayer}
+       * 4. Draw non-erasable overlays {@link fabric.EraserBrush#renderOverlay}
+       *
+       * @param {fabric.Canvas} canvas
+       */
+      _render: function () {
+        if (!this._ready) {
+          return;
+        }
+        this.isRendering = 1;
+        this.renderBottomLayer();
+        this.renderTopLayer();
+        this.renderOverlay();
+        this.isRendering = 0;
+      },
 
-  objectControls.mt = new fabric.Control({
-    x: 0,
-    y: -0.5,
-    cursorStyleHandler: scaleSkewStyleHandler,
-    actionHandler: scalingYOrSkewingX,
-    getActionName: scaleOrSkewActionName,
-  });
+      /**
+       * @public
+       */
+      render: function () {
+        if (this._isErasing) {
+          if (this.isRendering) {
+            this.isRendering = fabric.util.requestAnimFrame(this._renderBound);
+          }
+          else {
+            this._render();
+          }
+          return true;
+        }
+        return false;
+      },
 
-  objectControls.tl = new fabric.Control({
-    x: -0.5,
-    y: -0.5,
-    cursorStyleHandler: scaleStyleHandler,
-    actionHandler: scalingEqually
-  });
+      /**
+       * Utility to apply a clip path to a path.
+       * Used to preserve clipping on eraser paths in nested objects.
+       * Called when a group has a clip path that should be applied to the path before applying erasing on the group's objects.
+       * @param {fabric.Path} path The eraser path
+       * @param {fabric.Object} clipPath The clipPath to apply to the path
+       * @param {number[]} clipPathContainerTransformMatrix The transform matrix of the object that the clip path belongs to
+       * @returns {fabric.Path} path with clip path
+       */
+      applyClipPathToPath: function (path, clipPath, clipPathContainerTransformMatrix) {
+        var pathTransform = path.calcTransformMatrix();
+        var clipPathTransform = clipPath.calcTransformMatrix();
+        var transform = fabric.util.multiplyTransformMatrices(
+          fabric.util.invertTransform(pathTransform),
+          clipPathContainerTransformMatrix
+        );
+        fabric.util.applyTransformToObject(
+          clipPath,
+          fabric.util.multiplyTransformMatrices(
+            transform,
+            clipPathTransform
+          )
+        );
+        path.clipPath = clipPath;
+        return path;
+      },
 
-  objectControls.tr = new fabric.Control({
-    x: 0.5,
-    y: -0.5,
-    cursorStyleHandler: scaleStyleHandler,
-    actionHandler: scalingEqually
-  });
+      /**
+       * Utility to apply a clip path to a path.
+       * Used to preserve clipping on eraser paths in nested objects.
+       * Called when a group has a clip path that should be applied to the path before applying erasing on the group's objects.
+       * @param {fabric.Path} path The eraser path
+       * @param {fabric.Object} object The clipPath to apply to path belongs to object
+       * @param {Function} callback Callback to be invoked with the cloned path after applying the clip path
+       */
+      clonePathWithClipPath: function (path, object, callback) {
+        var objTransform = object.calcTransformMatrix();
+        var clipPath = object.getClipPath();
+        var _this = this;
+        path.clone(function (_path) {
+          clipPath.clone(function (_clipPath) {
+            callback(_this.applyClipPathToPath(_path, _clipPath, objTransform));
+          });
+        });
+      },
 
-  objectControls.bl = new fabric.Control({
-    x: -0.5,
-    y: 0.5,
-    cursorStyleHandler: scaleStyleHandler,
-    actionHandler: scalingEqually
-  });
+      /**
+       * Adds path to existing clipPath of object
+       *
+       * @param {fabric.Object} obj
+       * @param {fabric.Path} path
+       */
+      _addPathToObjectEraser: function (obj, path) {
+        var clipObject;
+        var _this = this;
+        //  object is collection, i.e group
+        if (obj.forEachObject && obj.erasable === 'deep') {
+          var targets = obj._objects.filter(function (_obj) {
+            return _obj.erasable;
+          });
+          if (targets.length > 0 && obj.clipPath) {
+            this.clonePathWithClipPath(path, obj, function (_path) {
+              targets.forEach(function (_obj) {
+                _this._addPathToObjectEraser(_obj, _path);
+              });
+            });
+          }
+          else if (targets.length > 0) {
+            targets.forEach(function (_obj) {
+              _this._addPathToObjectEraser(_obj, path);
+            });
+          }
+          return;
+        }
+        if (!obj.getEraser()) {
+          var size = obj._getNonTransformedDimensions();
+          var rect = new fabric.Rect({
+            fill: 'rgb(0,0,0)',
+            width: size.x,
+            height: size.y,
+            clipPath: obj.clipPath,
+            originX: 'center',
+            originY: 'center'
+          });
+          clipObject = new fabric.Group([rect], {
+            eraser: true
+          });
+        }
+        else {
+          clipObject = obj.clipPath;
+        }
 
-  objectControls.br = new fabric.Control({
-    x: 0.5,
-    y: 0.5,
-    cursorStyleHandler: scaleStyleHandler,
-    actionHandler: scalingEqually
-  });
+        path.clone(function (path) {
+          path.globalCompositeOperation = 'destination-out';
+          // http://fabricjs.com/using-transformations
+          var desiredTransform = fabric.util.multiplyTransformMatrices(
+            fabric.util.invertTransform(
+              obj.calcTransformMatrix()
+            ),
+            path.calcTransformMatrix()
+          );
+          fabric.util.applyTransformToObject(path, desiredTransform);
+          clipObject.addWithUpdate(path);
+          obj.set({
+            clipPath: clipObject,
+            dirty: true
+          });
+          obj.fire('erasing:end', {
+            path: path
+          });
+          if (obj.group && Array.isArray(_this.__subTargets)) {
+            _this.__subTargets.push(obj);
+          }
+        });
+      },
 
-  objectControls.mtr = new fabric.Control({
-    x: 0,
-    y: -0.5,
-    actionHandler: controlsUtils.rotationWithSnapping,
-    cursorStyleHandler: controlsUtils.rotationStyleHandler,
-    offsetY: -40,
-    withConnection: true,
-    actionName: 'rotate',
-  });
+      /**
+       * Add the eraser path to canvas drawables' clip paths
+       *
+       * @param {fabric.Canvas} source
+       * @param {fabric.Canvas} path
+       * @returns {Object} canvas drawables that were erased by the path
+       */
+      applyEraserToCanvas: function (path) {
+        var canvas = this.canvas;
+        var drawables = {};
+        [
+          'backgroundImage',
+          'overlayImage',
+        ].forEach(function (prop) {
+          var drawable = canvas[prop];
+          if (drawable && drawable.erasable) {
+            this._addPathToObjectEraser(drawable, path);
+            drawables[prop] = drawable;
+          }
+        }, this);
+        return drawables;
+      },
 
-  if (fabric.Textbox) {
-    // this is breaking the prototype inheritance, no time / ideas to fix it.
-    // is important to document that if you want to have all objects to have a
-    // specific custom control, you have to add it to Object prototype and to Textbox
-    // prototype. The controls are shared as references. So changes to control `tr`
-    // can still apply to all objects if needed.
-    var textBoxControls = fabric.Textbox.prototype.controls = { };
+      /**
+       * On mouseup after drawing the path on contextTop canvas
+       * we use the points captured to create an new fabric path object
+       * and add it to every intersected erasable object.
+       */
+      _finalizeAndAddPath: function () {
+        var ctx = this.canvas.contextTop, canvas = this.canvas;
+        ctx.closePath();
+        if (this.decimate) {
+          this._points = this.decimatePoints(this._points, this.decimate);
+        }
+
+        // clear
+        canvas.clearContext(canvas.contextTop);
+        this._isErasing = false;
+
+        var pathData = this._points && this._points.length > 1 ?
+          this.convertPointsToSVGPath(this._points) :
+          null;
+        if (!pathData || this._isEmptySVGPath(pathData)) {
+          canvas.fire('erasing:end');
+          // do not create 0 width/height paths, as they are
+          // rendered inconsistently across browsers
+          // Firefox 4, for example, renders a dot,
+          // whereas Chrome 10 renders nothing
+          canvas.requestRenderAll();
+          return;
+        }
 
-    textBoxControls.mtr = objectControls.mtr;
-    textBoxControls.tr = objectControls.tr;
-    textBoxControls.br = objectControls.br;
-    textBoxControls.tl = objectControls.tl;
-    textBoxControls.bl = objectControls.bl;
-    textBoxControls.mt = objectControls.mt;
-    textBoxControls.mb = objectControls.mb;
+        var path = this.createPath(pathData);
+        //  needed for `intersectsWithObject`
+        path.setCoords();
+        canvas.fire('before:path:created', { path: path });
 
-    textBoxControls.mr = new fabric.Control({
-      x: 0.5,
-      y: 0,
-      actionHandler: controlsUtils.changeWidth,
-      cursorStyleHandler: scaleSkewStyleHandler,
-      actionName: 'resizing',
-    });
+        // finalize erasing
+        var drawables = this.applyEraserToCanvas(path);
+        var _this = this;
+        this.__subTargets = [];
+        var targets = [];
+        canvas.forEachObject(function (obj) {
+          if (obj.erasable && obj.intersectsWithObject(path, true, true)) {
+            _this._addPathToObjectEraser(obj, path);
+            targets.push(obj);
+          }
+        });
+        canvas.fire('erasing:end', {
+          path: path,
+          targets: targets,
+          subTargets: this.__subTargets,
+          drawables: drawables
+        });
+        delete this.__subTargets;
 
-    textBoxControls.ml = new fabric.Control({
-      x: -0.5,
-      y: 0,
-      actionHandler: controlsUtils.changeWidth,
-      cursorStyleHandler: scaleSkewStyleHandler,
-      actionName: 'resizing',
-    });
-  }
+        canvas.requestRenderAll();
+        path.setCoords();
+        this._resetShadow();
+
+        // fire event 'path' created
+        canvas.fire('path:created', { path: path });
+      }
+    }
+  );
+
+  /** ERASER_END */
 })();
 
diff --git a/package-lock.json b/package-lock.json
index a0efffc4..70562fc3 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -349,12 +349,6 @@
         }
       }
     },
-    "@tootallnate/once": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/@tootallnate/once/-/once-2.0.0.tgz",
-      "integrity": "sha512-XCuKFP5PS55gnMVu3dty8KPatLqUoy/ZYzDzAGCQ8JNFCkLXzmI7vNHCR+XpbZaMWQK/vQubr7PkYq8g470J/A==",
-      "optional": true
-    },
     "abab": {
       "version": "2.0.5",
       "resolved": "https://registry.npmjs.org/abab/-/abab-2.0.5.tgz",
@@ -378,25 +372,25 @@
       }
     },
     "acorn": {
-      "version": "8.7.0",
-      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.7.0.tgz",
-      "integrity": "sha512-V/LGr1APy+PXIwKebEWrkZPwoeoF+w1jiOBUmuxuiUIaOHtob8Qc9BTrYo7VuI5fR8tqsy+buA2WFooR5olqvQ==",
+      "version": "7.4.1",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
+      "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
       "optional": true
     },
     "acorn-globals": {
-      "version": "6.0.0",
-      "resolved": "https://registry.npmjs.org/acorn-globals/-/acorn-globals-6.0.0.tgz",
-      "integrity": "sha512-ZQl7LOWaF5ePqqcX4hLuv/bLXYQNfNWw2c0/yX/TsPRKamzHcTGQnlCjHT3TsmkOUVEPS3crCxiPfdzE/Trlhg==",
+      "version": "4.3.4",
+      "resolved": "https://registry.npmjs.org/acorn-globals/-/acorn-globals-4.3.4.tgz",
+      "integrity": "sha512-clfQEh21R+D0leSbUdWf3OcfqyaCSAQ8Ryq00bofSekfr9W8u1jyYZo6ir0xu9Gtcf7BjcHJpnbZH7JOCpP60A==",
       "optional": true,
       "requires": {
-        "acorn": "^7.1.1",
-        "acorn-walk": "^7.1.1"
+        "acorn": "^6.0.1",
+        "acorn-walk": "^6.0.1"
       },
       "dependencies": {
         "acorn": {
-          "version": "7.4.1",
-          "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
-          "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
+          "version": "6.4.2",
+          "resolved": "https://registry.npmjs.org/acorn/-/acorn-6.4.2.tgz",
+          "integrity": "sha512-XtGIhXwF8YM8bJhGxG5kXgjkEuNGLTkoYqVE+KMR+aspr4KGYmKYg7yUe3KghyQ9yheNwLnjmzh/7+gfDBmHCQ==",
           "optional": true
         }
       }
@@ -419,9 +413,9 @@
       }
     },
     "acorn-walk": {
-      "version": "7.2.0",
-      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-7.2.0.tgz",
-      "integrity": "sha512-OPdCF6GsMIP+Az+aWfAAOEt2/+iVDKE7oy6lJ098aoe59oAmK76qV6Gw60SbZ8jHuG2wH058GF4pLFbYamYrVA==",
+      "version": "6.2.0",
+      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-6.2.0.tgz",
+      "integrity": "sha512-7evsyfH1cLOCdAzZAd43Cic04yKydNx0cF+7tiA19p1XnLLPU4dpCQOqpjqwokFe//vS0QqfqqjCS2JkiIs0cA==",
       "optional": true
     },
     "after": {
@@ -466,6 +460,18 @@
         "indent-string": "^4.0.0"
       }
     },
+    "ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "optional": true,
+      "requires": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      }
+    },
     "ajv-keywords": {
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-2.1.1.tgz",
@@ -561,6 +567,12 @@
       "integrity": "sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ=",
       "dev": true
     },
+    "array-equal": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/array-equal/-/array-equal-1.0.0.tgz",
+      "integrity": "sha1-jCpe8kcv2ep0KwTHenUJO6J1fJM=",
+      "optional": true
+    },
     "array-flatten": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
@@ -585,6 +597,21 @@
       "integrity": "sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=",
       "dev": true
     },
+    "asn1": {
+      "version": "0.2.4",
+      "resolved": "https://registry.npmjs.org/asn1/-/asn1-0.2.4.tgz",
+      "integrity": "sha512-jxwzQpLQjSmWXgwaCZE9Nz+glAG01yF1QnWgbhGwHI5A6FRIEY6IVqtHhIepHqI7/kyEyQEagBC5mBEFlIYvdg==",
+      "optional": true,
+      "requires": {
+        "safer-buffer": "~2.1.0"
+      }
+    },
+    "assert-plus": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz",
+      "integrity": "sha1-8S4PPF13sLHN2RRpQuTpbB5N1SU=",
+      "optional": true
+    },
     "assign-symbols": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz",
@@ -615,6 +642,18 @@
       "integrity": "sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg==",
       "dev": true
     },
+    "aws-sign2": {
+      "version": "0.7.0",
+      "resolved": "https://registry.npmjs.org/aws-sign2/-/aws-sign2-0.7.0.tgz",
+      "integrity": "sha1-tG6JCTSpWR8tL2+G1+ap8bP+dqg=",
+      "optional": true
+    },
+    "aws4": {
+      "version": "1.11.0",
+      "resolved": "https://registry.npmjs.org/aws4/-/aws4-1.11.0.tgz",
+      "integrity": "sha512-xh1Rl34h6Fi1DC2WWKfxUTVqRsNnr6LsKz2+hfwDxQJWmrx8+c7ylaqBMcHfl1U1r2dsifOvKX3LQuLNZ+XSvA==",
+      "optional": true
+    },
     "babel-code-frame": {
       "version": "6.26.0",
       "resolved": "https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz",
@@ -752,6 +791,15 @@
       "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
       "dev": true
     },
+    "bcrypt-pbkdf": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz",
+      "integrity": "sha1-pDAdOJtqQ/m2f/PKEaP2Y342Dp4=",
+      "optional": true,
+      "requires": {
+        "tweetnacl": "^0.14.3"
+      }
+    },
     "binary-extensions": {
       "version": "1.13.1",
       "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.1.tgz",
@@ -934,6 +982,12 @@
         "simple-get": "^3.0.3"
       }
     },
+    "caseless": {
+      "version": "0.12.0",
+      "resolved": "https://registry.npmjs.org/caseless/-/caseless-0.12.0.tgz",
+      "integrity": "sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw=",
+      "optional": true
+    },
     "chalk": {
       "version": "2.4.2",
       "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
@@ -1290,9 +1344,9 @@
       }
     },
     "cssom": {
-      "version": "0.5.0",
-      "resolved": "https://registry.npmjs.org/cssom/-/cssom-0.5.0.tgz",
-      "integrity": "sha512-iKuQcq+NdHqlAcwUY0o/HL69XQrUaQdMjmStJ8JFmUaiiQErlhrmuigkg/CU4E2J0IyUKUrMAgl36TvN67MqTw==",
+      "version": "0.4.4",
+      "resolved": "https://registry.npmjs.org/cssom/-/cssom-0.4.4.tgz",
+      "integrity": "sha512-p3pvU7r1MyyqbTk+WbNJIgJjG2VmTIaB10rI93LzVPrmDJKkzKYMtxxyAvQXR/NS6otuzveI7+7BBq3SjBS2mw==",
       "optional": true
     },
     "cssstyle": {
@@ -1312,15 +1366,24 @@
         }
       }
     },
+    "dashdash": {
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/dashdash/-/dashdash-1.14.1.tgz",
+      "integrity": "sha1-hTz6D3y+L+1d4gMmuN1YEDX24vA=",
+      "optional": true,
+      "requires": {
+        "assert-plus": "^1.0.0"
+      }
+    },
     "data-urls": {
-      "version": "3.0.1",
-      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-3.0.1.tgz",
-      "integrity": "sha512-Ds554NeT5Gennfoo9KN50Vh6tpgtvYEwraYjejXnyTpu1C7oXKxdFk75REooENHE8ndTVOJuv+BEs4/J/xcozw==",
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-1.1.0.tgz",
+      "integrity": "sha512-YTWYI9se1P55u58gL5GkQHW4P6VJBJ5iBT+B5a7i2Tjadhv52paJG0qHX4A0OR6/t52odI64KP2YvFpkDOi3eQ==",
       "optional": true,
       "requires": {
-        "abab": "^2.0.3",
-        "whatwg-mimetype": "^3.0.0",
-        "whatwg-url": "^10.0.0"
+        "abab": "^2.0.0",
+        "whatwg-mimetype": "^2.2.0",
+        "whatwg-url": "^7.0.0"
       }
     },
     "debug": {
@@ -1338,12 +1401,6 @@
       "integrity": "sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=",
       "dev": true
     },
-    "decimal.js": {
-      "version": "10.3.1",
-      "resolved": "https://registry.npmjs.org/decimal.js/-/decimal.js-10.3.1.tgz",
-      "integrity": "sha512-V0pfhfr8suzyPGOx3nmq4aHqabehUZn6Ch9kyFpV79TGDTWFmHqUqXdabR7QHqxzrYolF4+tVmJhUG4OURg5dQ==",
-      "optional": true
-    },
     "decode-uri-component": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz",
@@ -1465,12 +1522,22 @@
       }
     },
     "domexception": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/domexception/-/domexception-4.0.0.tgz",
-      "integrity": "sha512-A2is4PLG+eeSfoTMA95/s4pvAoSo2mKtiM5jlHkAVewmiO8ISFTFKZjH7UAM1Atli/OT/7JHOrJRJiMKUZKYBw==",
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/domexception/-/domexception-1.0.1.tgz",
+      "integrity": "sha512-raigMkn7CJNNo6Ihro1fzG7wr3fHuYVytzquZKX5n0yizGsTcYgzdIUwj1X9pK0VvjeihV+XiclP+DjwbsSKug==",
       "optional": true,
       "requires": {
-        "webidl-conversions": "^7.0.0"
+        "webidl-conversions": "^4.0.2"
+      }
+    },
+    "ecc-jsbn": {
+      "version": "0.1.2",
+      "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
+      "integrity": "sha1-OoOpBOVDUyh4dMVkt1SThoSamMk=",
+      "optional": true,
+      "requires": {
+        "jsbn": "~0.1.0",
+        "safer-buffer": "^2.1.0"
       }
     },
     "ee-first": {
@@ -1599,24 +1666,16 @@
       "dev": true
     },
     "escodegen": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-2.0.0.tgz",
-      "integrity": "sha512-mmHKys/C8BFUGI+MAWNcSYoORYLMdPzjrknd2Vc+bUsjN5bXcr8EhrNB+UTqfL1y3I9c4fw2ihgtMPQLBRiQxw==",
+      "version": "1.14.3",
+      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.14.3.tgz",
+      "integrity": "sha512-qFcX0XJkdg+PB3xjZZG/wKSuT1PnQWx57+TVSjIMmILd2yC/6ByYElPwJnslDsuWuSAp4AwJGumarAAmJch5Kw==",
       "optional": true,
       "requires": {
         "esprima": "^4.0.1",
-        "estraverse": "^5.2.0",
+        "estraverse": "^4.2.0",
         "esutils": "^2.0.2",
         "optionator": "^0.8.1",
         "source-map": "~0.6.1"
-      },
-      "dependencies": {
-        "estraverse": {
-          "version": "5.3.0",
-          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
-          "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
-          "optional": true
-        }
       }
     },
     "eslint": {
@@ -1781,8 +1840,7 @@
     "estraverse": {
       "version": "4.3.0",
       "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
-      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
-      "dev": true
+      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw=="
     },
     "esutils": {
       "version": "2.0.3",
@@ -1928,6 +1986,12 @@
         }
       }
     },
+    "extend": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
+      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
+      "optional": true
+    },
     "extend-shallow": {
       "version": "3.0.2",
       "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
@@ -1969,11 +2033,22 @@
         "is-extglob": "^1.0.0"
       }
     },
+    "extsprintf": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.3.0.tgz",
+      "integrity": "sha1-lpGEQOMEGnpBT4xS48V06zw+HgU=",
+      "optional": true
+    },
+    "fast-deep-equal": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
+      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
+      "optional": true
+    },
     "fast-json-stable-stringify": {
       "version": "2.1.0",
       "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
-      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
-      "dev": true
+      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
     },
     "fast-levenshtein": {
       "version": "2.0.6",
@@ -2182,14 +2257,20 @@
         }
       }
     },
+    "forever-agent": {
+      "version": "0.6.1",
+      "resolved": "https://registry.npmjs.org/forever-agent/-/forever-agent-0.6.1.tgz",
+      "integrity": "sha1-+8cfDEGt6zf5bFd60e1C2P2sypE=",
+      "optional": true
+    },
     "form-data": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz",
-      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",
+      "version": "2.3.3",
+      "resolved": "https://registry.npmjs.org/form-data/-/form-data-2.3.3.tgz",
+      "integrity": "sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==",
       "optional": true,
       "requires": {
         "asynckit": "^0.4.0",
-        "combined-stream": "^1.0.8",
+        "combined-stream": "^1.0.6",
         "mime-types": "^2.1.12"
       }
     },
@@ -2316,6 +2397,15 @@
       "integrity": "sha1-3BXKHGcjh8p2vTesCjlbogQqLCg=",
       "dev": true
     },
+    "getpass": {
+      "version": "0.1.7",
+      "resolved": "https://registry.npmjs.org/getpass/-/getpass-0.1.7.tgz",
+      "integrity": "sha1-Xv+OPmhNVprkyysSgmBOi6YhSfo=",
+      "optional": true,
+      "requires": {
+        "assert-plus": "^1.0.0"
+      }
+    },
     "glob": {
       "version": "7.1.6",
       "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
@@ -2378,6 +2468,22 @@
       "integrity": "sha1-8QdIy+dq+WS3yWyTxrzCivEgwIE=",
       "dev": true
     },
+    "har-schema": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/har-schema/-/har-schema-2.0.0.tgz",
+      "integrity": "sha1-qUwiJOvKwEeCoNkDVSHyRzW37JI=",
+      "optional": true
+    },
+    "har-validator": {
+      "version": "5.1.5",
+      "resolved": "https://registry.npmjs.org/har-validator/-/har-validator-5.1.5.tgz",
+      "integrity": "sha512-nmT2T0lljbxdQZfspsno9hgrG3Uir6Ks5afism62poxqBM6sDnMEuPmzTq8XN0OEwqKLLdh1jQI3qyE66Nzb3w==",
+      "optional": true,
+      "requires": {
+        "ajv": "^6.12.3",
+        "har-schema": "^2.0.0"
+      }
+    },
     "has-ansi": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz",
@@ -2492,12 +2598,12 @@
       }
     },
     "html-encoding-sniffer": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-3.0.0.tgz",
-      "integrity": "sha512-oWv4T4yJ52iKrufjnyZPkrN0CH3QnrUqdB6In1g5Fe1mia8GmF36gnfNySxoZtxD5+NmYw1EElVXiBk93UeskA==",
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-1.0.2.tgz",
+      "integrity": "sha512-71lZziiDnsuabfdYiUeWdCVyKuqwWi23L8YeIgV9jSSZHCtb6wB1BKWooH7L3tn4/FuZJMVWyNaIDr4RGmaSYw==",
       "optional": true,
       "requires": {
-        "whatwg-encoding": "^2.0.0"
+        "whatwg-encoding": "^1.0.1"
       }
     },
     "html-escaper": {
@@ -2538,32 +2644,15 @@
         "requires-port": "^1.0.0"
       }
     },
-    "http-proxy-agent": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-5.0.0.tgz",
-      "integrity": "sha512-n2hY8YdoRE1i7r6M0w9DIw5GgZN0G25P8zLCRQ8rjXtTU3vsNFBI/vWK/UIeE6g5MUUz6avwAPXmL6Fy9D/90w==",
+    "http-signature": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/http-signature/-/http-signature-1.2.0.tgz",
+      "integrity": "sha1-muzZJRFHcvPZW2WmCruPfBj7rOE=",
       "optional": true,
       "requires": {
-        "@tootallnate/once": "2",
-        "agent-base": "6",
-        "debug": "4"
-      },
-      "dependencies": {
-        "debug": {
-          "version": "4.3.3",
-          "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.3.tgz",
-          "integrity": "sha512-/zxw5+vh1Tfv+4Qn7a5nsbcJKPaSvCDhojn6FEl9vupwK2VCSDtEiEtqr8DFtzYFOdz63LBkxec7DYuc2jon6Q==",
-          "optional": true,
-          "requires": {
-            "ms": "2.1.2"
-          }
-        },
-        "ms": {
-          "version": "2.1.2",
-          "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
-          "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
-          "optional": true
-        }
+        "assert-plus": "^1.0.0",
+        "jsprim": "^1.2.2",
+        "sshpk": "^1.7.0"
       }
     },
     "https-proxy-agent": {
@@ -2597,7 +2686,6 @@
       "version": "0.4.24",
       "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
       "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
-      "dev": true,
       "requires": {
         "safer-buffer": ">= 2.1.2 < 3"
       }
@@ -2695,6 +2783,12 @@
         }
       }
     },
+    "ip-regex": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/ip-regex/-/ip-regex-2.1.0.tgz",
+      "integrity": "sha1-+ni/XS5pE8kRzp+BnuUUa7bYROk=",
+      "optional": true
+    },
     "ipaddr.js": {
       "version": "1.9.1",
       "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
@@ -2829,12 +2923,6 @@
       "integrity": "sha1-MzTceXdDaOkvAW5vvAqI9c1ua8Q=",
       "dev": true
     },
-    "is-potential-custom-element-name": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/is-potential-custom-element-name/-/is-potential-custom-element-name-1.0.1.tgz",
-      "integrity": "sha512-bCYeRA2rVibKZd+s2625gGnGF/t7DSqDs4dP7CrLA1m7jKWz6pps0LpYLJN8Q64HtmPKJ1hrN3nzPNKFEKOUiQ==",
-      "optional": true
-    },
     "is-primitive": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/is-primitive/-/is-primitive-2.0.0.tgz",
@@ -2865,8 +2953,7 @@
     "is-typedarray": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/is-typedarray/-/is-typedarray-1.0.0.tgz",
-      "integrity": "sha1-5HnICFjfDBsR3dppQPlgEfzaSpo=",
-      "dev": true
+      "integrity": "sha1-5HnICFjfDBsR3dppQPlgEfzaSpo="
     },
     "is-windows": {
       "version": "1.0.2",
@@ -2900,6 +2987,12 @@
         "isarray": "1.0.0"
       }
     },
+    "isstream": {
+      "version": "0.1.2",
+      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
+      "integrity": "sha1-R+Y/evVa+m+S4VAOaQ64uFKcCZo=",
+      "optional": true
+    },
     "istanbul-lib-coverage": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.0.0.tgz",
@@ -3084,47 +3177,44 @@
         "esprima": "^4.0.0"
       }
     },
+    "jsbn": {
+      "version": "0.1.1",
+      "resolved": "https://registry.npmjs.org/jsbn/-/jsbn-0.1.1.tgz",
+      "integrity": "sha1-peZUwuWi3rXyAdls77yoDA7y9RM=",
+      "optional": true
+    },
     "jsdom": {
-      "version": "19.0.0",
-      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-19.0.0.tgz",
-      "integrity": "sha512-RYAyjCbxy/vri/CfnjUWJQQtZ3LKlLnDqj+9XLNnJPgEGeirZs3hllKR20re8LUZ6o1b1X4Jat+Qd26zmP41+A==",
+      "version": "15.2.1",
+      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-15.2.1.tgz",
+      "integrity": "sha512-fAl1W0/7T2G5vURSyxBzrJ1LSdQn6Tr5UX/xD4PXDx/PDgwygedfW6El/KIj3xJ7FU61TTYnc/l/B7P49Eqt6g==",
       "optional": true,
       "requires": {
-        "abab": "^2.0.5",
-        "acorn": "^8.5.0",
-        "acorn-globals": "^6.0.0",
-        "cssom": "^0.5.0",
-        "cssstyle": "^2.3.0",
-        "data-urls": "^3.0.1",
-        "decimal.js": "^10.3.1",
-        "domexception": "^4.0.0",
-        "escodegen": "^2.0.0",
-        "form-data": "^4.0.0",
-        "html-encoding-sniffer": "^3.0.0",
-        "http-proxy-agent": "^5.0.0",
-        "https-proxy-agent": "^5.0.0",
-        "is-potential-custom-element-name": "^1.0.1",
+        "abab": "^2.0.0",
+        "acorn": "^7.1.0",
+        "acorn-globals": "^4.3.2",
+        "array-equal": "^1.0.0",
+        "cssom": "^0.4.1",
+        "cssstyle": "^2.0.0",
+        "data-urls": "^1.1.0",
+        "domexception": "^1.0.1",
+        "escodegen": "^1.11.1",
+        "html-encoding-sniffer": "^1.0.2",
         "nwsapi": "^2.2.0",
-        "parse5": "6.0.1",
-        "saxes": "^5.0.1",
-        "symbol-tree": "^3.2.4",
-        "tough-cookie": "^4.0.0",
-        "w3c-hr-time": "^1.0.2",
-        "w3c-xmlserializer": "^3.0.0",
-        "webidl-conversions": "^7.0.0",
-        "whatwg-encoding": "^2.0.0",
-        "whatwg-mimetype": "^3.0.0",
-        "whatwg-url": "^10.0.0",
-        "ws": "^8.2.3",
-        "xml-name-validator": "^4.0.0"
-      },
-      "dependencies": {
-        "ws": {
-          "version": "8.4.0",
-          "resolved": "https://registry.npmjs.org/ws/-/ws-8.4.0.tgz",
-          "integrity": "sha512-IHVsKe2pjajSUIl4KYMQOdlyliovpEPquKkqbwswulszzI7r0SfQrxnXdWAEqOlDCLrVSJzo+O1hAwdog2sKSQ==",
-          "optional": true
-        }
+        "parse5": "5.1.0",
+        "pn": "^1.1.0",
+        "request": "^2.88.0",
+        "request-promise-native": "^1.0.7",
+        "saxes": "^3.1.9",
+        "symbol-tree": "^3.2.2",
+        "tough-cookie": "^3.0.1",
+        "w3c-hr-time": "^1.0.1",
+        "w3c-xmlserializer": "^1.1.2",
+        "webidl-conversions": "^4.0.2",
+        "whatwg-encoding": "^1.0.5",
+        "whatwg-mimetype": "^2.3.0",
+        "whatwg-url": "^7.0.0",
+        "ws": "^7.0.0",
+        "xml-name-validator": "^3.0.0"
       }
     },
     "jsesc": {
@@ -3133,12 +3223,30 @@
       "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==",
       "dev": true
     },
+    "json-schema": {
+      "version": "0.2.3",
+      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.2.3.tgz",
+      "integrity": "sha1-tIDIkuWaLwWVTOcnvT8qTogvnhM=",
+      "optional": true
+    },
+    "json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "optional": true
+    },
     "json-stable-stringify-without-jsonify": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
       "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
       "dev": true
     },
+    "json-stringify-safe": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
+      "integrity": "sha1-Epai1Y/UXxmg9s4B1lcB4sc1tus=",
+      "optional": true
+    },
     "json5": {
       "version": "2.1.3",
       "resolved": "https://registry.npmjs.org/json5/-/json5-2.1.3.tgz",
@@ -3148,6 +3256,18 @@
         "minimist": "^1.2.5"
       }
     },
+    "jsprim": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/jsprim/-/jsprim-1.4.1.tgz",
+      "integrity": "sha1-MT5mvB5cwG5Di8G3SZwuXFastqI=",
+      "optional": true,
+      "requires": {
+        "assert-plus": "1.0.0",
+        "extsprintf": "1.3.0",
+        "json-schema": "0.2.3",
+        "verror": "1.10.0"
+      }
+    },
     "kind-of": {
       "version": "3.2.2",
       "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
@@ -3178,8 +3298,7 @@
     "lodash": {
       "version": "4.17.20",
       "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.20.tgz",
-      "integrity": "sha512-PlhdFcillOINfeV7Ni6oF1TAEayyZBoZ8bcshTHqOYJYlrqzRK5hagpagky5o4HfCzzd1TRkXPMFq6cKk9rGmA==",
-      "dev": true
+      "integrity": "sha512-PlhdFcillOINfeV7Ni6oF1TAEayyZBoZ8bcshTHqOYJYlrqzRK5hagpagky5o4HfCzzd1TRkXPMFq6cKk9rGmA=="
     },
     "lodash._baseflatten": {
       "version": "3.1.4",
@@ -3264,6 +3383,12 @@
       "integrity": "sha1-eeTriMNqgSKvhvhEqpvNhRtfu1U=",
       "dev": true
     },
+    "lodash.sortby": {
+      "version": "4.7.0",
+      "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
+      "integrity": "sha1-7dFMgk4sycHgsKG0K7UhBRakJDg=",
+      "optional": true
+    },
     "lodash.uniqby": {
       "version": "4.7.0",
       "resolved": "https://registry.npmjs.org/lodash.uniqby/-/lodash.uniqby-4.7.0.tgz",
@@ -3726,6 +3851,12 @@
         }
       }
     },
+    "oauth-sign": {
+      "version": "0.9.0",
+      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
+      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ==",
+      "optional": true
+    },
     "object-assign": {
       "version": "4.1.1",
       "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
@@ -3925,9 +4056,9 @@
       }
     },
     "parse5": {
-      "version": "6.0.1",
-      "resolved": "https://registry.npmjs.org/parse5/-/parse5-6.0.1.tgz",
-      "integrity": "sha512-Ofn/CTFzRGTTxwpNEs9PP93gXShHcTq255nzRYSKe8AkVpZY7e1fpmTfOyoIvjP5HG7Z2ZM7VS9PPhQGW2pOpw==",
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/parse5/-/parse5-5.1.0.tgz",
+      "integrity": "sha512-fxNG2sQjHvlVAYmzBZS9YlDp6PTSSDwa98vkD4QgVDDCAo84z5X1t5XyJQ62ImdLXx5NdIIfihey6xpum9/gRQ==",
       "optional": true
     },
     "parseqs": {
@@ -3983,6 +4114,12 @@
       "integrity": "sha1-32BBeABfUi8V60SQ5yR6G/qmf4w=",
       "dev": true
     },
+    "performance-now": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
+      "integrity": "sha1-Ywn04OX6kT7BxpMHrjZLSzd8nns=",
+      "optional": true
+    },
     "pixelmatch": {
       "version": "4.0.2",
       "resolved": "https://registry.npmjs.org/pixelmatch/-/pixelmatch-4.0.2.tgz",
@@ -4007,6 +4144,12 @@
       "integrity": "sha512-ARhBOdzS3e41FbkW/XWrTEtukqqLoK5+Z/4UeDaLuSW+39JPeFgs4gCGqsrJHVZX0fUrx//4OF0K1CUGwlIFow==",
       "dev": true
     },
+    "pn": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/pn/-/pn-1.1.0.tgz",
+      "integrity": "sha512-2qHaIQr2VLRFoxe2nASzsV6ef4yOOH+Fi9FBOVH6cqeSgUnoyySPZkxzLuzd+RYOQTRpROA0ztTMqxROKSb/nA==",
+      "optional": true
+    },
     "pngjs": {
       "version": "3.4.0",
       "resolved": "https://registry.npmjs.org/pngjs/-/pngjs-3.4.0.tgz",
@@ -4094,6 +4237,12 @@
       "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
       "optional": true
     },
+    "qs": {
+      "version": "6.5.2",
+      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
+      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA==",
+      "optional": true
+    },
     "qunit": {
       "version": "2.14.0",
       "resolved": "https://registry.npmjs.org/qunit/-/qunit-2.14.0.tgz",
@@ -4519,6 +4668,78 @@
       "integrity": "sha1-jcrkcOHIirwtYA//Sndihtp15jc=",
       "dev": true
     },
+    "request": {
+      "version": "2.88.2",
+      "resolved": "https://registry.npmjs.org/request/-/request-2.88.2.tgz",
+      "integrity": "sha512-MsvtOrfG9ZcrOwAW+Qi+F6HbD0CWXEh9ou77uOb7FM2WPhwT7smM833PzanhJLsgXjN89Ir6V2PczXNnMpwKhw==",
+      "optional": true,
+      "requires": {
+        "aws-sign2": "~0.7.0",
+        "aws4": "^1.8.0",
+        "caseless": "~0.12.0",
+        "combined-stream": "~1.0.6",
+        "extend": "~3.0.2",
+        "forever-agent": "~0.6.1",
+        "form-data": "~2.3.2",
+        "har-validator": "~5.1.3",
+        "http-signature": "~1.2.0",
+        "is-typedarray": "~1.0.0",
+        "isstream": "~0.1.2",
+        "json-stringify-safe": "~5.0.1",
+        "mime-types": "~2.1.19",
+        "oauth-sign": "~0.9.0",
+        "performance-now": "^2.1.0",
+        "qs": "~6.5.2",
+        "safe-buffer": "^5.1.2",
+        "tough-cookie": "~2.5.0",
+        "tunnel-agent": "^0.6.0",
+        "uuid": "^3.3.2"
+      },
+      "dependencies": {
+        "tough-cookie": {
+          "version": "2.5.0",
+          "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.5.0.tgz",
+          "integrity": "sha512-nlLsUzgm1kfLXSXfRZMc1KLAugd4hqJHDTvc2hDIwS3mZAfMEuMbc03SujMF+GEcpaX/qboeycw6iO8JwVv2+g==",
+          "optional": true,
+          "requires": {
+            "psl": "^1.1.28",
+            "punycode": "^2.1.1"
+          }
+        }
+      }
+    },
+    "request-promise-core": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/request-promise-core/-/request-promise-core-1.1.4.tgz",
+      "integrity": "sha512-TTbAfBBRdWD7aNNOoVOBH4pN/KigV6LyapYNNlAPA8JwbovRti1E88m3sYAwsLi5ryhPKsE9APwnjFTgdUjTpw==",
+      "optional": true,
+      "requires": {
+        "lodash": "^4.17.19"
+      }
+    },
+    "request-promise-native": {
+      "version": "1.0.9",
+      "resolved": "https://registry.npmjs.org/request-promise-native/-/request-promise-native-1.0.9.tgz",
+      "integrity": "sha512-wcW+sIUiWnKgNY0dqCpOZkUbF/I+YPi+f09JZIDa39Ec+q82CpSYniDp+ISgTTbKmnpJWASeJBPZmoxH84wt3g==",
+      "optional": true,
+      "requires": {
+        "request-promise-core": "1.1.4",
+        "stealthy-require": "^1.1.1",
+        "tough-cookie": "^2.3.3"
+      },
+      "dependencies": {
+        "tough-cookie": {
+          "version": "2.5.0",
+          "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.5.0.tgz",
+          "integrity": "sha512-nlLsUzgm1kfLXSXfRZMc1KLAugd4hqJHDTvc2hDIwS3mZAfMEuMbc03SujMF+GEcpaX/qboeycw6iO8JwVv2+g==",
+          "optional": true,
+          "requires": {
+            "psl": "^1.1.28",
+            "punycode": "^2.1.1"
+          }
+        }
+      }
+    },
     "require-directory": {
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
@@ -4625,12 +4846,12 @@
       "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
     },
     "saxes": {
-      "version": "5.0.1",
-      "resolved": "https://registry.npmjs.org/saxes/-/saxes-5.0.1.tgz",
-      "integrity": "sha512-5LBh1Tls8c9xgGjw3QrMwETmTMVk0oFgvrFSvWx62llR2hcEInrKNZ2GZCCuuy2lvWrdl5jhbpeqc5hRYKFOcw==",
+      "version": "3.1.11",
+      "resolved": "https://registry.npmjs.org/saxes/-/saxes-3.1.11.tgz",
+      "integrity": "sha512-Ydydq3zC+WYDJK1+gRxRapLIED9PWeSuuS41wqyoRmzvhhh9nc+QQrVMKJYzJFULazeGhzSV0QleN2wD3boh2g==",
       "optional": true,
       "requires": {
-        "xmlchars": "^2.2.0"
+        "xmlchars": "^2.1.1"
       }
     },
     "semver": {
@@ -5117,6 +5338,23 @@
       "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
       "dev": true
     },
+    "sshpk": {
+      "version": "1.16.1",
+      "resolved": "https://registry.npmjs.org/sshpk/-/sshpk-1.16.1.tgz",
+      "integrity": "sha512-HXXqVUq7+pcKeLqqZj6mHFUMvXtOJt1uoUx09pFW6011inTMxqI8BA8PM95myrIyyKwdnzjdFjLiE6KBPVtJIg==",
+      "optional": true,
+      "requires": {
+        "asn1": "~0.2.3",
+        "assert-plus": "^1.0.0",
+        "bcrypt-pbkdf": "^1.0.0",
+        "dashdash": "^1.12.0",
+        "ecc-jsbn": "~0.1.1",
+        "getpass": "^0.1.1",
+        "jsbn": "~0.1.0",
+        "safer-buffer": "^2.0.2",
+        "tweetnacl": "~0.14.0"
+      }
+    },
     "static-extend": {
       "version": "0.1.2",
       "resolved": "https://registry.npmjs.org/static-extend/-/static-extend-0.1.2.tgz",
@@ -5144,6 +5382,12 @@
       "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
       "dev": true
     },
+    "stealthy-require": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/stealthy-require/-/stealthy-require-1.1.1.tgz",
+      "integrity": "sha1-NbCYdbT/SfJqd35QmzCQoyJr8ks=",
+      "optional": true
+    },
     "string-width": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
@@ -5476,23 +5720,23 @@
       "dev": true
     },
     "tough-cookie": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-4.0.0.tgz",
-      "integrity": "sha512-tHdtEpQCMrc1YLrMaqXXcj6AxhYi/xgit6mZu1+EDWUn+qhUf8wMQoFIy9NXuq23zAwtcB0t/MjACGR18pcRbg==",
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-3.0.1.tgz",
+      "integrity": "sha512-yQyJ0u4pZsv9D4clxO69OEjLWYw+jbgspjTue4lTQZLfV0c5l1VmK2y1JK8E9ahdpltPOaAThPcp5nKPUgSnsg==",
       "optional": true,
       "requires": {
-        "psl": "^1.1.33",
-        "punycode": "^2.1.1",
-        "universalify": "^0.1.2"
+        "ip-regex": "^2.1.0",
+        "psl": "^1.1.28",
+        "punycode": "^2.1.1"
       }
     },
     "tr46": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/tr46/-/tr46-3.0.0.tgz",
-      "integrity": "sha512-l7FvfAHlcmulp8kr+flpQZmVwtu7nfRV7NZujtN0OqES8EL4O4e0qqzL0DC5gAvx/ZC/9lk6rhcUwYvkBnBnYA==",
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz",
+      "integrity": "sha1-qLE/1r/SSJUZZ0zN5VujaTtwbQk=",
       "optional": true,
       "requires": {
-        "punycode": "^2.1.1"
+        "punycode": "^2.1.0"
       }
     },
     "tree-kill": {
@@ -5501,6 +5745,21 @@
       "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
       "dev": true
     },
+    "tunnel-agent": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
+      "integrity": "sha1-J6XeoGs2sEoKmWZ3SykIaPD8QP0=",
+      "optional": true,
+      "requires": {
+        "safe-buffer": "^5.0.1"
+      }
+    },
+    "tweetnacl": {
+      "version": "0.14.5",
+      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-0.14.5.tgz",
+      "integrity": "sha1-WuaBd/GS1EViadEIr6k/+HQ/T2Q=",
+      "optional": true
+    },
     "type-check": {
       "version": "0.3.2",
       "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.3.2.tgz",
@@ -5576,12 +5835,6 @@
         "set-value": "^2.0.1"
       }
     },
-    "universalify": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/universalify/-/universalify-0.1.2.tgz",
-      "integrity": "sha512-rBJeI5CXAlmy1pV+617WB9J63U6XcazHHF2f2dbJix4XzpUF0RS3Zbj0FGIOCAva5P/d/GBOYaACQ1w+0azUkg==",
-      "optional": true
-    },
     "unpipe": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
@@ -5634,6 +5887,15 @@
         }
       }
     },
+    "uri-js": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
+      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
+      "optional": true,
+      "requires": {
+        "punycode": "^2.1.0"
+      }
+    },
     "urix": {
       "version": "0.1.0",
       "resolved": "https://registry.npmjs.org/urix/-/urix-0.1.0.tgz",
@@ -5660,8 +5922,7 @@
     "uuid": {
       "version": "3.4.0",
       "resolved": "https://registry.npmjs.org/uuid/-/uuid-3.4.0.tgz",
-      "integrity": "sha512-HjSDRw6gZE5JMggctHBcjVak08+KEVhSIiDzFnT9S9aegmp85S/bReBVTb4QTFaRNptJ9kuYaNhnbNEOkbKb/A==",
-      "dev": true
+      "integrity": "sha512-HjSDRw6gZE5JMggctHBcjVak08+KEVhSIiDzFnT9S9aegmp85S/bReBVTb4QTFaRNptJ9kuYaNhnbNEOkbKb/A=="
     },
     "vary": {
       "version": "1.1.2",
@@ -5669,6 +5930,17 @@
       "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw=",
       "dev": true
     },
+    "verror": {
+      "version": "1.10.0",
+      "resolved": "https://registry.npmjs.org/verror/-/verror-1.10.0.tgz",
+      "integrity": "sha1-OhBcoXBTr1XW4nDB+CiGguGNpAA=",
+      "optional": true,
+      "requires": {
+        "assert-plus": "^1.0.0",
+        "core-util-is": "1.0.2",
+        "extsprintf": "^1.2.0"
+      }
+    },
     "w3c-hr-time": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/w3c-hr-time/-/w3c-hr-time-1.0.2.tgz",
@@ -5679,54 +5951,46 @@
       }
     },
     "w3c-xmlserializer": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-3.0.0.tgz",
-      "integrity": "sha512-3WFqGEgSXIyGhOmAFtlicJNMjEps8b1MG31NCA0/vOF9+nKMUW1ckhi9cnNHmf88Rzw5V+dwIwsm2C7X8k9aQg==",
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-1.1.2.tgz",
+      "integrity": "sha512-p10l/ayESzrBMYWRID6xbuCKh2Fp77+sA0doRuGn4tTIMrrZVeqfpKjXHY+oDh3K4nLdPgNwMTVP6Vp4pvqbNg==",
       "optional": true,
       "requires": {
-        "xml-name-validator": "^4.0.0"
+        "domexception": "^1.0.1",
+        "webidl-conversions": "^4.0.2",
+        "xml-name-validator": "^3.0.0"
       }
     },
     "webidl-conversions": {
-      "version": "7.0.0",
-      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-7.0.0.tgz",
-      "integrity": "sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==",
+      "version": "4.0.2",
+      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz",
+      "integrity": "sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==",
       "optional": true
     },
     "whatwg-encoding": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-2.0.0.tgz",
-      "integrity": "sha512-p41ogyeMUrw3jWclHWTQg1k05DSVXPLcVxRTYsXUk+ZooOCZLcoYgPZ/HL/D/N+uQPOtcp1me1WhBEaX02mhWg==",
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-1.0.5.tgz",
+      "integrity": "sha512-b5lim54JOPN9HtzvK9HFXvBma/rnfFeqsic0hSpjtDbVxR3dJKLc+KB4V6GgiGOvl7CY/KNh8rxSo9DKQrnUEw==",
       "optional": true,
       "requires": {
-        "iconv-lite": "0.6.3"
-      },
-      "dependencies": {
-        "iconv-lite": {
-          "version": "0.6.3",
-          "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
-          "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
-          "optional": true,
-          "requires": {
-            "safer-buffer": ">= 2.1.2 < 3.0.0"
-          }
-        }
+        "iconv-lite": "0.4.24"
       }
     },
     "whatwg-mimetype": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-3.0.0.tgz",
-      "integrity": "sha512-nt+N2dzIutVRxARx1nghPKGv1xHikU7HKdfafKkLNLindmPU/ch3U31NOCGGA/dmPcmb1VlofO0vnKAcsm0o/Q==",
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-2.3.0.tgz",
+      "integrity": "sha512-M4yMwr6mAnQz76TbJm914+gPpB/nCwvZbJU28cUD6dR004SAxDLOOSUaB1JDRqLtaOV/vi0IC5lEAGFgrjGv/g==",
       "optional": true
     },
     "whatwg-url": {
-      "version": "10.0.0",
-      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-10.0.0.tgz",
-      "integrity": "sha512-CLxxCmdUby142H5FZzn4D8ikO1cmypvXVQktsgosNy4a4BHrDHeciBBGZhb0bNoR5/MltoCatso+vFjjGx8t0w==",
+      "version": "7.1.0",
+      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz",
+      "integrity": "sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==",
       "optional": true,
       "requires": {
-        "tr46": "^3.0.0",
-        "webidl-conversions": "^7.0.0"
+        "lodash.sortby": "^4.7.0",
+        "tr46": "^1.0.1",
+        "webidl-conversions": "^4.0.2"
       }
     },
     "which": {
@@ -5855,13 +6119,12 @@
     "ws": {
       "version": "7.4.2",
       "resolved": "https://registry.npmjs.org/ws/-/ws-7.4.2.tgz",
-      "integrity": "sha512-T4tewALS3+qsrpGI/8dqNMLIVdq/g/85U98HPMa6F0m6xTbvhXU6RCQLqPH3+SlomNV/LdY6RXEbBpMH6EOJnA==",
-      "dev": true
+      "integrity": "sha512-T4tewALS3+qsrpGI/8dqNMLIVdq/g/85U98HPMa6F0m6xTbvhXU6RCQLqPH3+SlomNV/LdY6RXEbBpMH6EOJnA=="
     },
     "xml-name-validator": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-4.0.0.tgz",
-      "integrity": "sha512-ICP2e+jsHvAj2E2lIHxa5tjXRlKDJo4IdvPvCXbXQGdzSfmSpNVyIKMvoZHjDY9DP0zV17iI85o90vRFXNccRw==",
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-3.0.0.tgz",
+      "integrity": "sha512-A5CUptxDsvxKJEU3yO6DuWBSJz/qizqzJKOMIfUJHETbBw/sFaDxgd6fxm1ewUaM0jZ444Fc5vC5ROYurg/4Pw==",
       "optional": true
     },
     "xmlchars": {
diff --git a/package.json b/package.json
index 6aace659..cf3e90c9 100644
--- a/package.json
+++ b/package.json
@@ -69,7 +69,7 @@
   },
   "optionalDependencies": {
     "canvas": "^2.8.0",
-    "jsdom": "^19.0.0"
+    "jsdom": "^15.2.1"
   },
   "devDependencies": {
     "chalk": "^2.4.1",
@@ -82,7 +82,7 @@
     "uglify-js": "3.3.x"
   },
   "engines": {
-    "node": ">=14.0.0"
+    "node": ">=8.0.0"
   },
   "main": "./dist/fabric.js",
   "dependencies": {}
diff --git a/src/canvas.class.js b/src/canvas.class.js
index 03f0c450..d041d523 100644
--- a/src/canvas.class.js
+++ b/src/canvas.class.js
@@ -386,15 +386,21 @@
      * @return {Array} objects to render immediately and pushes the other in the activeGroup.
      */
     _chooseObjectsToRender: function() {
-      var activeObjects = this.getActiveObjects(),
+      var activeObjects = this.getActiveObjects(), objects = this._objects,
           object, objsToRender, activeGroupObjects;
 
       if (activeObjects.length > 0 && !this.preserveObjectStacking) {
         objsToRender = [];
         activeGroupObjects = [];
+        var ancestors = activeObjects.map(function (obj) {
+          while (obj && objects.indexOf(obj) === -1) {
+            obj = obj.parent || obj.group;
+          }
+          return obj;
+        });
         for (var i = 0, length = this._objects.length; i < length; i++) {
           object = this._objects[i];
-          if (activeObjects.indexOf(object) === -1 ) {
+          if (activeObjects.indexOf(object) === -1 && ancestors.indexOf(object) === -1) {
             objsToRender.push(object);
           }
           else {
@@ -404,6 +410,9 @@
         if (activeObjects.length > 1) {
           this._activeObject._objects = activeGroupObjects;
         }
+        else if (activeObjects[0].parent) {
+          activeGroupObjects.push(activeObjects[0]);
+        }
         objsToRender.push.apply(objsToRender, activeGroupObjects);
       }
       else {
@@ -823,7 +832,7 @@
           this._normalizePointer(objToCheck.group, pointer) : pointer;
         if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
           target = objects[i];
-          if (target.subTargetCheck && target instanceof fabric.Group) {
+          if (target.subTargetCheck && Array.isArray(target._objects)) {
             subTarget = this._searchPossibleTargets(target._objects, pointer);
             subTarget && this.targets.push(subTarget);
           }
@@ -1138,18 +1147,71 @@
      * @param {Event} [e] Event (passed along when firing "object:selected")
      * @return {Boolean} true if the selection happened
      */
-    _setActiveObject: function(object, e) {
-      if (this._activeObject === object) {
+    _setActiveObject: function (object, e) {
+      var isCollection = Array.isArray(object._objects), activeObject = this._activeObject;
+      if (this._activeObject === object && !isCollection) {
         return false;
       }
+      //  return if active object doesn't allow to be deselected
       if (!this._discardActiveObject(e, object)) {
         return false;
       }
-      if (object.onSelect({ e: e })) {
+      var subTargets;
+      if (e) {
+        //  prepare subTargets
+        var pointer = this.getPointer(e, true), targets = this.targets, target;
+        this.targets = [];
+        //  push children and `activeObject` to `targets`
+        if (activeObject && activeObject.subTargetCheck && Array.isArray(activeObject._objects)) {
+          target = this._searchPossibleTargets([activeObject], pointer);
+          target && this.targets.push(target);
+        }
+        //  push siblings and parents to `targets` recursively up
+        var parent = activeObject && activeObject.parent;
+        while (parent) {
+          target = this._searchPossibleTargets([parent], pointer);
+          target && this.targets.push(target);
+          parent = parent.parent;
+        }
+        subTargets = this.targets;
+        var lastIndex = subTargets.lastIndexOf(activeObject);
+        //  it is possible that `activeObject` exists twice in `subTargets`
+        //  if so we remove the last ref that was pushed as part of siblings check because we want it to be on top of all it's siblings
+        if (subTargets.indexOf(activeObject) !== lastIndex) {
+          subTargets.splice(lastIndex, 1);
+        }
+        this.targets = targets;
+      }
+      return this.__setActiveObject(object, e, subTargets);
+    },
+
+    __setActiveObject: function (object, e, subTargets) {
+      var activeObject = this._activeObject;
+      var result = object.onSelect({
+        e: e,
+        object: activeObject,
+        subTargets: this.targets.filter(function (object) { return object.isSelectable(); }),
+        activeSubTargets: subTargets && subTargets.filter(function (object) { return object.isSelectable(); })
+      });
+      if (result === true) {
         return false;
       }
-      this._activeObject = object;
-      return true;
+      else if (result && result instanceof fabric.Object && result !== object) {
+        var targets = this.targets;
+        if (e) {
+          //  prepare `targets`          
+          this.targets = [];
+          this._searchPossibleTargets([result], this.getPointer(e, true));
+        }
+        if (this.__setActiveObject(result, e) === true) {
+          //  restore `targets` if object declined selection
+          this.targets = targets;
+        };
+      }
+      else {
+        this._activeObject = object;
+      }
+      return activeObject !== this._activeObject;
     },
 
     /**
diff --git a/src/mixins/canvas_events.mixin.js b/src/mixins/canvas_events.mixin.js
index 6d27be65..f932037c 100644
--- a/src/mixins/canvas_events.mixin.js
+++ b/src/mixins/canvas_events.mixin.js
@@ -369,8 +369,9 @@
     /**
      * @private
      */
-    _onResize: function () {
+    _onResize: function (e) {
       this.calcOffset();
+      this.fire('resize', { e: e });
     },
 
     /**
@@ -450,9 +451,12 @@
           );
         }
       }
+      var actualTarget = target;
       if (target) {
         if (target.selectable && target !== this._activeObject && target.activeOn === 'up') {
           this.setActiveObject(target, e);
+          //  reassign in case a different object was selected
+          actualTarget = this._activeObject;
           shouldRender = true;
         }
         else {
@@ -469,7 +473,7 @@
         }
         target.isMoving = false;
       }
-      this._setCursorFromEvent(e, target);
+      this._setCursorFromEvent(e, actualTarget);
       this._handleEvent(e, 'up', LEFT_CLICK, isClick);
       this._groupSelector = null;
       this._currentTransform = null;
@@ -719,11 +723,16 @@
         };
       }
 
+      if (target && target.selectable && target.activeOn === 'down') {
+        this.setActiveObject(target, e);
+        //  reassign in case a different object was selected
+        if (target !== this._activeObject) {
+          shouldRender = true;
+          target = this._target = this._activeObject;
+        }
+      }
       if (target) {
         var alreadySelected = target === this._activeObject;
-        if (target.selectable && target.activeOn === 'down') {
-          this.setActiveObject(target, e);
-        }
         var corner = target._findTargetCorner(
           this.getPointer(e, true),
           fabric.util.isTouchEvent(e)
diff --git a/src/mixins/collection.mixin.js b/src/mixins/collection.mixin.js
index 49af03f1..6c94deec 100644
--- a/src/mixins/collection.mixin.js
+++ b/src/mixins/collection.mixin.js
@@ -140,7 +140,8 @@ fabric.Collection = {
   },
 
   /**
-   * Returns true if collection contains an object
+   * Returns true if collection contains an object.\
+   * **Prefer using `Object.isDescendantOf` for performance reasons**
    * @param {Object} object Object to check against
    * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`
    * @return {Boolean} `true` if collection contains an object
diff --git a/src/mixins/itext_behavior.mixin.js b/src/mixins/itext_behavior.mixin.js
index 4d075b4f..c523578e 100644
--- a/src/mixins/itext_behavior.mixin.js
+++ b/src/mixins/itext_behavior.mixin.js
@@ -866,13 +866,7 @@
           this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
         }
         else if (copiedStyle) {
-          // this test is required in order to close #6841
-          // when a pasted buffer begins with a newline then
-          // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]
-          // may be undefined for some reason
-          if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {
-            this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
-          }
+          this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
         }
         copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
       }
diff --git a/src/mixins/object.svg_export.js b/src/mixins/object.svg_export.js
index 05e83243..5eedcb06 100644
--- a/src/mixins/object.svg_export.js
+++ b/src/mixins/object.svg_export.js
@@ -36,7 +36,7 @@
           strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
           strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
           strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
-          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
+          opacity = this.parent ? this.getObjectOpacity() : typeof this.opacity !== 'undefined' ? this.opacity : '1',
           visibility = this.visible ? '' : ' visibility: hidden;',
           filter = skipShadow ? '' : this.getSvgFilter(),
           fill = getSvgColorString('fill', this.fill),
diff --git a/src/mixins/object_geometry.mixin.js b/src/mixins/object_geometry.mixin.js
index 5ae77bd1..2bc32986 100644
--- a/src/mixins/object_geometry.mixin.js
+++ b/src/mixins/object_geometry.mixin.js
@@ -518,8 +518,7 @@
      * oCoords are used to find the corners
      * aCoords are used to quickly find an object on the canvas
      * lineCoords are used to quickly find object during pointer events.
-     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}
-     * 
+     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
      * @param {Boolean} [skipCorners] skip calculation of oCoords.
      * @return {fabric.Object} thisArg
      * @chainable
diff --git a/src/mixins/object_interactivity.mixin.js b/src/mixins/object_interactivity.mixin.js
index 4aea3954..da0d2119 100644
--- a/src/mixins/object_interactivity.mixin.js
+++ b/src/mixins/object_interactivity.mixin.js
@@ -295,6 +295,7 @@
      * try to to deselect this object. If the function returns true, the process is cancelled
      * @param {Object} [options] options sent from the upper functions
      * @param {Event} [options.e] event if the process is generated by an event
+     * @param {fabric.Object} [options.object] the object that is about to be selected if the process finishes
      */
     onDeselect: function() {
       // implemented by sub-classes, as needed.
@@ -306,9 +307,16 @@
      * try to to select this object. If the function returns true, the process is cancelled
      * @param {Object} [options] options sent from the upper functions
      * @param {Event} [options.e] event if the process is generated by an event
+     * @param {fabric.Object} [options.object] the object that was deselected
+     * @param {fabric.Object} [options.subTaregts] instance sub targets for current action
+     * @param {fabric.Object[]} [options.activeSubTargets] sub targets related to `options.object` (children, self, siblings, parent) to help manage selection
+     * @returns {boolean | fabric.Object | undefined} `true` to cancel selection, an object to select instead of this one, `false` for default behavior
      */
-    onSelect: function() {
+    onSelect: function (options) {
       // implemented by sub-classes, as needed.
+      if (options.activeSubTargets) {
+        return options.activeSubTargets[0];
+      }
     }
   });
 })();
diff --git a/src/mixins/object_stacking.mixin.js b/src/mixins/object_stacking.mixin.js
index 8c8e87d5..d21bc653 100644
--- a/src/mixins/object_stacking.mixin.js
+++ b/src/mixins/object_stacking.mixin.js
@@ -5,13 +5,9 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @return {fabric.Object} thisArg
    * @chainable
    */
-  sendToBack: function() {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
-    }
-    else if (this.canvas) {
-      this.canvas.sendToBack(this);
-    }
+  sendToBack: function () {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.sendToBack.call(stack, this);
     return this;
   },
 
@@ -21,12 +17,8 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @chainable
    */
   bringToFront: function() {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
-    }
-    else if (this.canvas) {
-      this.canvas.bringToFront(this);
-    }
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.bringToFront.call(stack, this);
     return this;
   },
 
@@ -37,12 +29,8 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @chainable
    */
   sendBackwards: function(intersecting) {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
-    }
-    else if (this.canvas) {
-      this.canvas.sendBackwards(this, intersecting);
-    }
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.sendBackwards.call(stack, this, intersecting);
     return this;
   },
 
@@ -52,13 +40,9 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @return {fabric.Object} thisArg
    * @chainable
    */
-  bringForward: function(intersecting) {
-    if (this.group) {
-      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
-    }
-    else if (this.canvas) {
-      this.canvas.bringForward(this, intersecting);
-    }
+  bringForward: function (intersecting) {
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.bringForward.call(stack, this, intersecting);
     return this;
   },
 
@@ -69,12 +53,8 @@ fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prot
    * @chainable
    */
   moveTo: function(index) {
-    if (this.group && this.group.type !== 'activeSelection') {
-      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
-    }
-    else if (this.canvas) {
-      this.canvas.moveTo(this, index);
-    }
+    var stack = this.parent || this.group || this.canvas;
+    stack && fabric.StaticCanvas.prototype.moveTo.call(stack, this, index);
     return this;
   }
 });
diff --git a/src/parser.js b/src/parser.js
index a4592642..256cdb20 100644
--- a/src/parser.js
+++ b/src/parser.js
@@ -1001,26 +1001,22 @@
         if (styleContents.trim() === '') {
           continue;
         }
-        // recovers all the rule in this form `body { style code... }`
-        // rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
-        rules = styleContents.split('}');
-        // remove empty rules.
-        rules = rules.filter(function(rule) { return rule.trim(); });
-        // at this point we have hopefully an array of rules `body { style code... `
+        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
+        rules = rules.map(function(rule) { return rule.trim(); });
         // eslint-disable-next-line no-loop-func
         rules.forEach(function(rule) {
 
-          var match = rule.split('{'),
-              ruleObj = { }, declaration = match[1].trim(),
-              propertyValuePairs = declaration.split(';').filter(function(pair) { return pair.trim(); });
+          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
+              ruleObj = { }, declaration = match[2].trim(),
+              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
 
           for (i = 0, len = propertyValuePairs.length; i < len; i++) {
-            var pair = propertyValuePairs[i].split(':'),
-                property = pair[0].trim(),
-                value = pair[1].trim();
+            var pair = propertyValuePairs[i].split(/\s*:\s*/),
+                property = pair[0],
+                value = pair[1];
             ruleObj[property] = value;
           }
-          rule = match[0].trim();
+          rule = match[1];
           rule.split(',').forEach(function(_rule) {
             _rule = _rule.replace(/^svg/i, '').trim();
             if (_rule === '') {
diff --git a/src/shapes/active_selection.class.js b/src/shapes/active_selection.class.js
index 93ee250c..cac3cee6 100644
--- a/src/shapes/active_selection.class.js
+++ b/src/shapes/active_selection.class.js
@@ -15,7 +15,7 @@
    * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
    * @see {@link fabric.ActiveSelection#initialize} for constructor definition
    */
-  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {
+  fabric.ActiveSelection = fabric.util.createClass(fabric.ICollection, /** @lends fabric.ActiveSelection.prototype */ {
 
     /**
      * Type of an object
@@ -24,96 +24,25 @@
      */
     type: 'activeSelection',
 
-    /**
-     * Constructor
-     * @param {Object} objects ActiveSelection objects
-     * @param {Object} [options] Options object
-     * @return {Object} thisArg
-     */
-    initialize: function(objects, options) {
-      options = options || {};
-      this._objects = objects || [];
-      for (var i = this._objects.length; i--; ) {
-        this._objects[i].group = this;
-      }
-
-      if (options.originX) {
-        this.originX = options.originX;
-      }
-      if (options.originY) {
-        this.originY = options.originY;
-      }
-      this._calcBounds();
-      this._updateObjectsCoords();
-      fabric.Object.prototype.initialize.call(this, options);
-      this.setCoords();
-    },
-
-    /**
-     * Change te activeSelection to a normal group,
-     * High level function that automatically adds it to canvas as
-     * active object. no events fired.
-     * @since 2.0.0
-     * @return {fabric.Group}
-     */
-    toGroup: function() {
-      var objects = this._objects.concat();
-      this._objects = [];
-      var options = fabric.Object.prototype.toObject.call(this);
-      var newGroup = new fabric.Group([]);
-      delete options.type;
-      newGroup.set(options);
-      objects.forEach(function(object) {
-        object.canvas.remove(object);
-        object.group = newGroup;
-      });
-      newGroup._objects = objects;
-      if (!this.canvas) {
-        return newGroup;
-      }
-      var canvas = this.canvas;
-      canvas.add(newGroup);
-      canvas._activeObject = newGroup;
-      newGroup.setCoords();
-      return newGroup;
-    },
-
-    /**
-     * If returns true, deselection is cancelled.
-     * @since 2.0.0
-     * @return {Boolean} [cancel]
-     */
-    onDeselect: function() {
-      this.destroy();
-      return false;
-    },
+    objectCaching: false,
 
     /**
-     * Returns string representation of a group
-     * @return {String}
+     * @override we want instance to render selected objects
+     * @private
      */
-    toString: function() {
-      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
+    __objectSelectionMonitor: function () {
+      //  disabled
     },
 
     /**
-     * Decide if the object should cache or not. Create its own cache level
-     * objectCaching is a global flag, wins over everything
-     * needsItsOwnCache should be used when the object drawing method requires
-     * a cache step. None of the fabric classes requires it.
-     * Generally you do not cache objects in groups because the group outside is cached.
-     * @return {Boolean}
+     * @private
+     * @override
+     * @param {fabric.Object} object
      */
-    shouldCache: function() {
-      return false;
-    },
-
-    /**
-     * Check if this group or its parent group are caching, recursively up
-     * @return {Boolean}
-     */
-    isOnACache: function() {
-      return false;
+    _onObjectRemoved: function (object) {
+      delete object.parent;
+      this._watchObject(false, object);
+      object.fire('removed', { target: this });
     },
 
     /**
@@ -122,20 +51,28 @@
      * @param {Object} [styleOverride] properties to override the object style
      * @param {Object} [childrenOverride] properties to override the children overrides
      */
-    _renderControls: function(ctx, styleOverride, childrenOverride) {
+    _renderControls: function (ctx, styleOverride, childrenOverride) {
       ctx.save();
       ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
       this.callSuper('_renderControls', ctx, styleOverride);
-      childrenOverride = childrenOverride || { };
+      childrenOverride = childrenOverride || {};
       if (typeof childrenOverride.hasControls === 'undefined') {
         childrenOverride.hasControls = false;
       }
       childrenOverride.forActiveSelection = true;
-      for (var i = 0, len = this._objects.length; i < len; i++) {
-        this._objects[i]._renderControls(ctx, childrenOverride);
-      }
+      this.forEachObject(function (object) {
+        object._renderControls(ctx, childrenOverride);
+      });
       ctx.restore();
     },
+
+    /**
+     * Returns string representation of a group
+     * @return {String}
+     */
+    toString: function() {
+      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
+    }
   });
 
   /**
@@ -146,9 +83,8 @@
    * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
    */
   fabric.ActiveSelection.fromObject = function(object, callback) {
-    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
-      delete object.objects;
-      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.ActiveSelection(objects, options));
     });
   };
 
diff --git a/src/shapes/icollection.class.js b/src/shapes/icollection.class.js
new file mode 100644
index 00000000..3546c541
--- /dev/null
+++ b/src/shapes/icollection.class.js
@@ -0,0 +1,682 @@
+(function (global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = {}),
+      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
+      invertTransform = fabric.util.invertTransform,
+      applyTransformToObject = fabric.util.applyTransformToObject,
+      clone = fabric.util.object.clone,
+      extend = fabric.util.object.extend;
+
+  if (fabric.ICollection) {
+    fabric.warn('fabric.ICollection is already defined');
+    return;
+  }
+
+  /**
+   * ICollection class
+   * @class fabric.ICollection
+   * @extends fabric.Object
+   * @mixes fabric.Collection
+   * @fires added on added object before layout
+   * @fires removed on removed object before layout
+   * @see {@link fabric.ICollection#initialize} for constructor definition
+   */
+  fabric.ICollection = fabric.util.createClass(fabric.Object, fabric.Collection,
+    /** @lends fabric.ICollection.prototype */
+    {
+
+      /**
+       * Type of an object
+       * @type string
+       * @default
+       */
+      type: 'iCollection',
+
+      /**
+       * Specifies the **layout strategy** for instance
+       * Used by `getLayoutStrategyResult` to calculate layout
+       * @type string
+       * @default
+       */
+      layout: 'fit-content',
+
+      /**
+       * List of properties to consider when checking if state
+       * of an object is changed (fabric.Object#hasStateChanged)
+       * as well as for history (undo/redo) purposes
+       * @type string[]
+       */
+      stateProperties: fabric.Object.prototype.stateProperties.concat('layout'),
+
+      /**
+       * @default
+       * @override
+       */
+      fill: '',
+
+      /**
+       * @default
+       * @override
+       */
+      strokeWidth: 0,
+
+      /**
+       * Used to optimize performance
+       * set to `false` if you don't need objects to be interactive
+       * @default
+       * @type boolean
+       */
+      subTargetCheck: true,
+
+      /**
+       * @override
+       * @default
+       */
+      erasable: 'deep',
+
+      /**
+       * Used internally to optimize performance
+       * Once an object is selected, instance is rendered without the selected object.
+       * This way instance is cached only once for the entire interaction with the selected object.
+       * @private
+       */
+      _activeObjects: undefined,
+
+      /**
+       * Constructor
+       * Guard objects' transformations from excessive mutations during initializion.
+       *
+       * @param {fabric.Object[]} [objects] instance objects
+       * @param {Object} [options] Options object
+       * @return {fabric.ICollection} thisArg
+       */
+      initialize: function (objects, options) {
+        this._objects = objects || [];
+        this._activeObjects = [];
+        this.__objectMonitor = this.__objectMonitor.bind(this);
+        this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, true);
+        this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, false);
+        this.callSuper('initialize', options);
+        this._applyLayoutStrategy({ type: 'initializion', options: options });
+        if (!this.subTargetCheck) {
+          this.ownMatrixCache.initialValue = this.calcOwnMatrix();
+        }
+        this.forEachObject(function (object) {
+          if (this.subTargetCheck) {
+            object.setCoords();
+            this._watchObject(true, object);
+          }
+          object.set('parent', this);
+        }, this);
+      },
+
+      /**
+       * @private
+       * @param {string} key
+       * @param {*} value
+       */
+      _set: function (key, value) {
+        if (key === 'subTargetCheck' && this.ownMatrixCache) {
+          //  we want to avoid setting `initialValue` during initializion
+          var initialValue = this.ownMatrixCache.initialValue;
+          if (value && initialValue) {
+            this._applyMatrixDiffToObjects(initialValue, this.calcOwnMatrix());
+            delete this.ownMatrixCache.initialValue;
+          }
+          else if (!value && !initialValue) {
+            //  we want to prevent this logic from writing over the exisitng value before it has been applied to objects
+            this.ownMatrixCache.initialValue = this.calcOwnMatrix();
+          }
+        }
+        this.callSuper('_set', key, value);
+        if (key === 'canvas') {
+          this.forEachObject(function (object) {
+            object._set(key, value);
+          });
+        }
+        if (key === 'layout') {
+          this._applyLayoutStrategy({ type: 'layout_change' });
+        }
+        if (key === 'subTargetCheck') {
+          this.forEachObject(this._watchObject.bind(this, value));
+        }
+        return this;
+      },
+
+      /**
+       * Applies the matrix diff on all objects.
+       * @private
+       * @param {number[]} from The matrix objects are curretly relating to
+       * @param {number[]} to The matrix objects should relate to
+       */
+      _applyMatrixDiffToObjects: function (from, to) {
+        var invTransform = invertTransform(from);
+        this.forEachObject(function (object) {
+          var objectTransform = multiplyTransformMatrices(invTransform, object.calcTransformMatrix());
+          applyTransformToObject(object, multiplyTransformMatrices(to, objectTransform));
+          object.setCoords();
+        });
+      },
+
+      /**
+       * Use the matrix diff to keep clip path in place after resizing instance by applying the inverted diff to it
+       * @private
+       */
+      _applyMatrixDiffToClipPath: function () {
+        var clipPath = this.clipPath;
+        if (clipPath && !clipPath.absolutePositioned
+          && this.prevMatrixCache && this.ownMatrixCache.key !== this.prevMatrixCache.key) {
+          var from = this.prevMatrixCache.cache, to = this.calcOwnMatrix();
+          var transformDiff = multiplyTransformMatrices(invertTransform(to), from);
+          applyTransformToObject(clipPath, multiplyTransformMatrices(transformDiff, clipPath.calcTransformMatrix()));
+        }
+      },
+
+      /**
+       * Compares changes made to the transform matrix and applies them to instance's objects.
+       * In other words, call this method to make the current transform the starting point of a transform diff for objects.
+       * @param {boolean} [disablePropagation] disable propagation of current transform diff to objects, preventing the existing transform diff from being applied to them unnecessarily.
+       */
+      _applyMatrixDiff: function (disablePropagation) {
+        var key = this.ownMatrixCache && this.ownMatrixCache.key;
+        if ((!this.prevMatrixCache || this.prevMatrixCache.key !== key) && this.subTargetCheck) {
+          var transform = this.calcOwnMatrix();
+          if (this.prevMatrixCache && !disablePropagation) {
+            this._applyMatrixDiffToObjects(this.prevMatrixCache.cache, transform);
+          }
+          this.prevMatrixCache = {
+            key: this.ownMatrixCache.key,
+            cache: transform
+          };
+        }
+      },
+
+      /**
+       * @private
+       */
+      _onBeforeObjectsChange: function () {
+        this._applyMatrixDiff();
+      },
+
+      add: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.add.apply(this, arguments);
+        this._onAfterObjectsChange('added', arguments);
+        return this;
+      },
+
+      /**
+       * backward compatibility
+       * @deprecated 
+       */
+      addWithUpdate: function () {
+        this.add.apply(this, arguments);
+      },
+
+      insertAt: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.insertAt.apply(this, arguments);
+        this._onAfterObjectsChange('added', arguments);
+        return this;
+      },
+
+      remove: function () {
+        this._onBeforeObjectsChange();
+        fabric.Collection.remove.apply(this, arguments);
+        this._onAfterObjectsChange('removed', arguments);
+        return this;
+      },
+
+      removeAll: function () {
+        this._activeObjects = [];
+        return this.remove.apply(this, this._objects);
+      },
+
+      /**
+       * backward compatibility
+       * @deprecated
+       */
+      removeWithUpdate: function () {
+        this.remove.apply(this, arguments);
+      },
+
+      /**
+       * @private
+       * @param {'added'|'removed'} type
+       */
+      _onAfterObjectsChange: function (type) {
+        this._applyLayoutStrategy({
+          type: type,
+          targets: arguments
+        });
+        this._set('dirty', true);
+      },
+
+      /**
+       * invalidates layout on object modified
+       * @private
+       */
+      __objectMonitor: function (opt) {
+        this._applyLayoutStrategy(extend(clone(opt), {
+          type: 'object_modified'
+        }));
+        this._set('dirty', true);
+      },
+
+      /**
+       * keeps track of the selected objects
+       * @private
+       */
+      __objectSelectionMonitor: function (selected, opt) {
+        var object = opt.target;
+        if (selected) {
+          this._activeObjects.push(object);
+          this._set('dirty', true);
+        }
+        else if (this._activeObjects.length > 0) {
+          var index = this._activeObjects.indexOf(object);
+          if (index > -1) {
+            this._activeObjects.splice(index, 1);
+            this._set('dirty', true);
+          }
+        }
+      },
+
+      /**
+       * @private
+       * @param {boolean} watch
+       * @param {fabric.Object} object
+       */
+      _watchObject: function (watch, object) {
+        var directive = watch ? 'on' : 'off';
+        object[directive]('modified', this.__objectMonitor);
+        object[directive]('selected', this.__objectSelectionTracker);
+        object[directive]('deselected', this.__objectSelectionDisposer);
+      },
+
+      /**
+       * @private
+       * @param {fabric.Object} object
+       */
+      _onObjectAdded: function (object) {
+        object._set('parent', this);
+        object._set('canvas', this.canvas);
+        this._watchObject(true, object);
+        object.fire('added', { target: this });
+        var activeObject = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
+        if (activeObject && (activeObject === object || object.isDescendantOf(activeObject))) {
+          this._activeObjects.push(true);
+        }
+      },
+
+      /**
+       * @private
+       * @param {fabric.Object} object
+       */
+      _onObjectRemoved: function (object) {
+        delete object.canvas;
+        delete object.parent;
+        this._watchObject(false, object);
+        object.fire('removed', { target: this });
+        var index = this._activeObjects.length > 0 ? this._activeObjects.indexOf(object) : -1;
+        if (index > -1) {
+          this._activeObjects.splice(index, 1);
+        }
+      },
+
+      /**
+       *
+       * @param {object} opt
+       * @param {fabric.Object[]} opt.subTargets
+       * @returns true to abort selection, a `subTarget` to select that or false to defer to default behavior and allow selection to take place
+       */
+      onSelect: function (opt) {
+        return this.callSuper('onSelect', opt) || (opt.subTargets && opt.subTargets.length > 0 && opt.subTargets[0]);
+      },
+
+      /**
+       * Check if instance or its parent are caching, recursively up
+       * @return {Boolean}
+       */
+      isOnACache: function () {
+        return this.ownCaching || (!!this.parent && this.parent.isOnACache());
+      },
+
+      /**
+       * hook used to apply matrix diff on objects
+       * @override
+       * @param {boolean} [skipCanvas]
+       * @returns {boolean}
+       */
+      isCacheDirty: function (skipCanvas) {
+        //  apply matrix diff before deciding if cache isn't dirty
+        this._applyMatrixDiff();
+        if (this.callSuper('isCacheDirty', skipCanvas)) {
+          return true;
+        }
+        if (!this.statefullCache) {
+          return false;
+        }
+        return this._objects.some(function (object) {
+          return object.isCacheDirty(true);
+        });
+      },
+
+      /**
+       * hook used to apply matrix diff on objects
+       */
+      setCoords: function () {
+        this._applyMatrixDiff();
+        this.callSuper('setCoords');
+      },
+
+      /**
+       * Renders instance on a given context
+       * @param {CanvasRenderingContext2D} ctx context to render instance on
+       */
+      render: function (ctx) {
+        //  used to inform objects not to double opacity
+        this._transformDone = true;
+        this.callSuper('render', ctx);
+        this._transformDone = false;
+      },
+
+      /**
+       * If `subTargetCheck === true` we transform `ctx` back to canvas plane, objects are up to date with the latest diff
+       * otherwise we transform ctx back to canvas plane by applying the initial matrix, objects relating accordingly
+       *
+       * Performance optimizations:
+       *
+       * **`subTargetCheck === false`**:
+       * In case we don't need instance to be interactive (selectable objects etc.) we don't apply the transform diff to the objects in order to minimize the number of iterations.
+       * We transform the entire ctx with the diff instead.
+       * We store the initial value of the transform matrix to do so, leaving objects as they were when the initial value was stored, rather than updating them continueously.
+       * This means that objects will render correctly on screen, **BUT** that's it. All geometry methods will **NOT WORK**.
+       * This optimization is crucial for an instance that contains a very large amount of objects.
+       * In case you need to select objects toggle `subTargetCheck` accordingly.
+       *
+       * **caching and selection**:
+       * Once an object is selected, instance is rendered without the selected object.
+       * This way instance is cached only once for the entire interaction with the selected object.
+       *
+       * @private
+       * @param {CanvasRenderingContext2D} ctx Context to render on
+       */
+      _render: function (ctx) {
+        ctx.save();
+        var t = this.subTargetCheck ? this.calcTransformMatrix() : this.ownMatrixCache.initialValue;
+        ctx.transform.apply(ctx, invertTransform(t));
+        this._renderObjects(ctx);
+        ctx.restore();
+      },
+
+      /**
+       * **Performance optimization**:
+       * render only non-selected objects,
+       * canvas is in charge of rendering the selected objects
+       * @private
+       * @param {CanvasRenderingContext2D} ctx Context to render on
+       */
+      _renderObjects: function (ctx) {
+        this.forEachObject(function (object) {
+          if (this._activeObjects.length === 0 || this._activeObjects.indexOf(object) === -1) {
+            object.render(ctx);
+          }
+        }, this);
+      },
+
+      /**
+       * @private
+       * @param {object} context see `getLayoutStrategyResult`
+       */
+      _applyLayoutStrategy: function (context) {
+        var result = this.getLayoutStrategyResult(this.layout, this._objects, context);
+        if (!result) {
+          return;
+        }
+        this.set({ width: result.width, height: result.height });
+        this.setPositionByOrigin(new fabric.Point(result.x, result.y), result.originX, result.originY);
+        //  refresh matrix cache
+        this.calcOwnMatrix();
+        //  keep clip path in place
+        this._applyMatrixDiffToClipPath();
+        //  set diff point without changing objects matrices
+        this._applyMatrixDiff(true);
+        //  make sure coords are up to date
+        context.type !== 'initialization' && this.callSuper('setCoords');
+        //  fire layout hook
+        this.onLayout(context, result);
+        //  recursive up
+        if (this.parent && this.parent._applyLayoutStrategy) {
+          //  append the path recursion to context
+          if (!context.path) {
+            context.path = [];
+          }
+          context.path.push(this);
+          //  all parents should invalidate their layout
+          this.parent._applyLayoutStrategy(context);
+        }
+      },
+
+      /**
+       * Override this method to customize layout.
+       * If you need to run logic once layout completes use `onLayout`
+       * @public
+       * @param {string} layoutDirective
+       * @param {fabric.Object[]} objects
+       * @param {object} context object with data regarding what triggered the call
+       * @param {'initializion'|'object_modified'|'added'|'removed'|'layout_change'} context.type
+       * @param {fabric.Object[]} context.path array of objects starting from the object that triggered the call to the current one
+       * @returns {Object} options object
+       */
+      getLayoutStrategyResult: function (layoutDirective, objects, context) {  // eslint-disable-line no-unused-vars
+        if (layoutDirective === 'fit-content') {
+          return this.getObjectsBoundingBox(objects);
+        }
+        else if (layoutDirective === 'fixed' && context.type === 'initializion') {
+          var bbox = this.getObjectsBoundingBox(objects),
+              hasX = typeof context.options.left === 'number',
+              hasY = typeof context.options.top === 'number';
+          return {
+            x: hasX ? this.left : bbox.left,
+            y: hasY ? this.top : bbox.top,
+            width: this.width || bbox.width,
+            height: this.height || bbox.height,
+            originX: hasX ? this.originX : 'center',
+            originY: hasY ? this.originY : 'center'
+          };
+        }
+      },
+
+      /**
+       * Hook that is called once layout has completed.
+       * Provided for layout customization, override if necessary.
+       * Complements `getLayoutStrategyResult`, which is called at the beginning of layout.
+       * @public
+       * @param {*} context layout context
+       * @param {Object} result layout result
+       */
+      onLayout: function () {
+        //  override by subclass
+      },
+
+      /**
+       * @todo support instance rotation
+       * @public
+       * @param {fabric.Object[]} objects
+       * @returns
+       */
+      getObjectsBoundingBox: function (objects) {
+        if (objects.length === 0) {
+          return {};
+        }
+        var coords = [];
+        for (var i = 0, o; i < objects.length; ++i) {
+          o = objects[i];
+          coords.push.apply(coords, o.getCoords(true, true));
+        }
+        var bounds = coords.reduce(function (acc, point) {
+          return {
+            min: {
+              x: Math.min(acc.min.x, point.x),
+              y: Math.min(acc.min.y, point.y)
+            },
+            max: {
+              x: Math.max(acc.max.x, point.x),
+              y: Math.max(acc.max.y, point.y)
+            }
+          };
+        }, { min: coords[0], max: coords[0] });
+        var center = new fabric.Point(bounds.min.x, bounds.min.y).midPointFrom(bounds.max),
+            width = (bounds.max.x - bounds.min.x) / (this.scaleX || 1),
+            height = (bounds.max.y - bounds.min.y) / (this.scaleY || 1),
+            rad = fabric.util.degreesToRadians(this.angle || 0),
+            cos = Math.abs(Math.cos(rad)),
+            sin = Math.abs(Math.sin(rad));
+        return {
+          x: center.x,
+          y: center.y,
+          width: width * cos + height * sin,
+          height: width * sin + height * cos,
+          originX: 'center',
+          originY: 'center'
+        };
+      },
+
+      /**
+       *
+       * @private
+       * @param {'toObject'|'toDatalessObject'} [method]
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @returns {Object[]} serialized objects
+       */
+      __serializeObjects: function (method, propertiesToInclude) {
+        var _includeDefaultValues = this.includeDefaultValues;
+        return this._objects
+          .filter(function (obj) {
+            return !obj.excludeFromExport;
+          })
+          .map(function (obj) {
+            var originalDefaults = obj.includeDefaultValues;
+            obj.includeDefaultValues = _includeDefaultValues;
+            var data = obj[method || 'toObject'](propertiesToInclude);
+            obj.includeDefaultValues = originalDefaults;
+            delete data.version;
+            return data;
+          });
+      },
+
+      /**
+       * Returns object representation of an instance
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @return {Object} object representation of an instance
+       */
+      toObject: function (propertiesToInclude) {
+        var obj = fabric.Object.prototype.toObject.call(this, ['layout'].concat(propertiesToInclude));
+        obj.objects = this.__serializeObjects('toObject', propertiesToInclude);
+        return obj;
+      },
+
+      /**
+       * Returns object representation of an instance, in dataless mode.
+       * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output
+       * @return {Object} object representation of an instance
+       */
+      toDatalessObject: function (propertiesToInclude) {
+        var obj = fabric.Object.prototype.toDatalessObject.call(this, ['layout'].propertiesToInclude);
+        obj.objects = this.sourcePath || this.__serializeObjects('toDatalessObject', propertiesToInclude);
+        return obj;
+      },
+
+      toString: function () {
+        return '#<fabric.ICollection: (' + this.complexity() + ')>';
+      },
+
+      dispose: function () {
+        this._activeObjects = [];
+        this.forEachObject(function (object) {
+          this._watchObject(false, object);
+          object.dispose && object.dispose();
+        }, this);
+      },
+
+      /* _TO_SVG_START_ */
+
+      /**
+       * Returns svg representation of an instance
+       * @param {Function} [reviver] Method for further parsing of svg representation.
+       * @return {String} svg representation of an instance
+       */
+      _toSVG: function (reviver) {
+        var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];
+        //  in case there's an unapplied matrix diff (`subTargetCheck = false`) we need to use `ownMatrixCache.initialValue`
+        var t = invertTransform(this.ownMatrixCache.initialValue || this.calcTransformMatrix());
+        svgString.push('<g ', 'transform="', fabric.util.matrixToSVG(t), '">\n');
+        for (var i = 0, len = this._objects.length; i < len; i++) {
+          svgString.push('\t\t', this._objects[i].toSVG(reviver));
+        }
+        svgString.push('</g>\n', '</g>\n');
+        return svgString;
+      },
+
+      /**
+       * Returns svg clipPath representation of an instance
+       * @param {Function} [reviver] Method for further parsing of svg representation.
+       * @return {String} svg representation of an instance
+       */
+      toClipPathSVG: function (reviver) {
+        var svgString = [];
+        for (var i = 0, len = this._objects.length; i < len; i++) {
+          svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
+        }
+        return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
+      },
+      /* _TO_SVG_END_ */
+    });
+
+  /**
+   * @todo support loading from svg
+   * @private
+   * @static
+   * @memberOf fabric.ICollection
+   * @param {Object} object Object to create an instance from
+   * @param {(objects: fabric.Object[], options?: Object) => any} [callback]
+   */
+  fabric.ICollection._fromObject = function (object, callback) {
+    var objects = object.objects,
+        options = clone(object, true);
+    delete options.objects;
+    if (typeof objects === 'string') {
+      // it has to be a url or something went wrong.
+      fabric.loadSVGFromURL(objects, function (elements) {
+        options = fabric.util.getOptionsFromSVG(elements, object, objects);
+        callback && callback(elements, options);
+      });
+      return;
+    }
+    fabric.util.enlivenObjects(objects, function (enlivenedObjects) {
+      fabric.util.enlivenObjects([object.clipPath], function (enlivedClipPath) {
+        var options = clone(object, true);
+        options.clipPath = enlivedClipPath[0];
+        delete options.objects;
+        callback && callback(enlivenedObjects, options);
+      });
+    });
+  };
+
+  /**
+   * Returns fabric.ICollection instance from an object representation
+   * @static
+   * @memberOf fabric.ICollection
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   */
+  fabric.ICollection.fromObject = function (object, callback) {
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.ICollection(objects, options));
+    });
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
diff --git a/src/shapes/layer.class.js b/src/shapes/layer.class.js
new file mode 100644
index 00000000..b8134fc7
--- /dev/null
+++ b/src/shapes/layer.class.js
@@ -0,0 +1,175 @@
+(function (global) {
+
+  'use strict';
+
+  var fabric = global.fabric || (global.fabric = {});
+
+  if (fabric.Layer) {
+    fabric.warn('fabric.Layer is already defined');
+    return;
+  }
+
+  /**
+   * Layer class
+   * @class fabric.Layer
+   * @extends fabric.Object
+   * @mixes fabric.Collection
+   * @see {@link fabric.Layer#initialize} for constructor definition
+   */
+  fabric.Layer = fabric.util.createClass(fabric.ICollection, /** @lends fabric.ICollection.prototype */ {
+
+    /**
+     * @default
+     * @type string
+     */
+    type: 'layer',
+
+    /**
+     * @override
+     * @default
+     */
+    layout: 'auto',
+
+    /**
+     * @override
+     * @default
+     */
+    objectCaching: false,
+
+    /**
+     * @override
+     * @default
+     */
+    strokeWidth: 0,
+
+    /**
+     * @override
+     * @default
+     */
+    hasControls: false,
+
+    /**
+     * @override
+     * @default
+     */
+    hasBorders: false,
+
+    /**
+     * @override
+     * @default
+     */
+    lockMovementX: true,
+
+    /**
+     * @override
+     * @default
+     */
+    lockMovementY: true,
+
+    /**
+     * Constructor
+     *
+     * @param {fabric.Object[]} [objects] instance objects
+     * @param {Object} [options] Options object
+     * @return {fabric.ICollection} thisArg
+     */
+    initialize: function (objects, options) {
+      this.callSuper('initialize', objects, options);
+      this.__canvasMonitor = this.__canvasMonitor.bind(this);
+    },
+
+    /**
+     * 
+     * @param {string} key 
+     * @param {*} value 
+     */
+    _set: function (key, value) {
+      var settingCanvas = key === 'canvas';
+      if (settingCanvas) {
+        if (!value && this.canvas) {
+          //  detach canvas resize handler
+          this.canvas.off('resize', this.__canvasMonitor);
+        }
+        else if (value && (!this.canvas || this.canvas !== value)) {
+          //  attach canvas resize handler, make sure we listen to the resize event only once
+          this.canvas && this.canvas.off('resize', this.__canvasMonitor);
+          value.off('resize', this.__canvasMonitor);
+          value.on('resize', this.__canvasMonitor);
+        }
+      }
+      this.callSuper('_set', key, value);
+      //  apply layout after canvas is set
+      if (settingCanvas) {
+        this._applyLayoutStrategy({ type: 'canvas' });
+      }
+    },
+
+    /**
+     * used by canvas' active object logic to determine `subTargets`
+     * @private
+     * @memberOf fabric.Object.prototype
+     * @returns {boolean}
+     */
+    isSelectable: function () {
+      return false;
+    },
+
+    /**
+     * we do not need to invalidate layout because layer fills the entire canvas
+     * @override
+     * @private
+     */
+    __objectMonitor: function () {
+      //  noop
+    },
+
+    /**
+     * @private
+     */
+    __canvasMonitor: function () {
+      this._applyLayoutStrategy({ type: 'canvas_resize' });
+    },
+
+    /**
+     * Override this method to customize layout
+     * @public
+     * @param {string} layoutDirective
+     * @param {fabric.Object[]} objects
+     * @param {object} context object with data regarding what triggered the call
+     * @param {'initializion'|'canvas'|'canvas_resize'|'layout_change'} context.type
+     * @param {fabric.Object[]} context.path array of objects starting from the object that triggered the call to the current one
+     * @returns {Object} options object
+     */
+    getLayoutStrategyResult: function (layoutDirective, objects, context) {  // eslint-disable-line no-unused-vars
+      if ((context.type === 'canvas' || context.type === 'canvas_resize') && this.canvas) {
+        return {
+          x: 0,
+          y: 0,
+          originX: 'left',
+          originY: 'top',
+          width: this.canvas.width,
+          height: this.canvas.height
+        };
+      }
+    },
+
+    toString: function () {
+      return '#<fabric.Layer: (' + this.complexity() + ')>';
+    },
+
+  });
+
+  /**
+   * Returns fabric.Layer instance from an object representation
+   * @static
+   * @memberOf fabric.Layer
+   * @param {Object} object Object to create an instance from
+   * @param {function} [callback] invoked with new instance as first argument
+   */
+  fabric.Layer.fromObject = function (object, callback) {
+    callback && fabric.ICollection._fromObject(object, function (objects, options) {
+      callback(new fabric.Layer(objects, options));
+    });
+  };
+
+})(typeof exports !== 'undefined' ? exports : this);
diff --git a/src/shapes/object.class.js b/src/shapes/object.class.js
index 7db7c565..617fee2f 100644
--- a/src/shapes/object.class.js
+++ b/src/shapes/object.class.js
@@ -972,9 +972,9 @@
      * @return {Number}
      */
     getObjectOpacity: function() {
-      var opacity = this.opacity;
-      if (this.group) {
-        opacity *= this.group.getObjectOpacity();
+      var opacity = this.opacity, parent = this.group || this.parent;
+      if (parent) {
+        opacity *= parent.getObjectOpacity();
       }
       return opacity;
     },
@@ -987,7 +987,7 @@
      */
     _set: function(key, value) {
       var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
-          isChanged = this[key] !== value, groupNeedsUpdate = false;
+          isChanged = this[key] !== value;
 
       if (shouldConstrainValue) {
         value = this._constrainScale(value);
@@ -1003,20 +1003,20 @@
       else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
         value = new fabric.Shadow(value);
       }
-      else if (key === 'dirty' && this.group) {
-        this.group.set('dirty', value);
+      else if (key === 'dirty') {
+        this.group && this.group.set('dirty', value);
+        this.parent && this.parent.set('dirty', value);
       }
 
       this[key] = value;
 
       if (isChanged) {
-        groupNeedsUpdate = this.group && this.group.isOnACache();
+        var parent = this.group || this.parent;
         if (this.cacheProperties.indexOf(key) > -1) {
           this.dirty = true;
-          groupNeedsUpdate && this.group.set('dirty', true);
         }
-        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
-          this.group.set('dirty', true);
+        if (parent && parent.isOnACache() && (this.dirty || this.stateProperties.indexOf(key) > -1)) {
+          parent.set('dirty', true);
         }
       }
       return this;
@@ -1045,7 +1045,7 @@
       return fabric.iMatrix.concat();
     },
 
-    /*
+    /**
      * @private
      * return if the object would be visible in rendering
      * @memberOf fabric.Object.prototype
@@ -1057,6 +1057,16 @@
         !this.visible;
     },
 
+    /**
+     * used by canvas' active object logic to determine `subTargets`
+     * @private
+     * @memberOf fabric.Object.prototype
+     * @returns {boolean}
+     */
+    isSelectable: function() {
+      return this.selectable && this.evented && !this.isNotVisible() && this.isOnScreen();
+    },
+
     /**
      * Renders an object on a specified context
      * @param {CanvasRenderingContext2D} ctx Context to render on
@@ -1167,11 +1177,9 @@
      * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
      * @return {Boolean}
      */
-    shouldCache: function() {
-      this.ownCaching = this.needsItsOwnCache() || (
-        this.objectCaching &&
-        (!this.group || !this.group.isOnACache())
-      );
+    shouldCache: function () {
+      var parent = this.group || this.parent;
+      this.ownCaching = this.needsItsOwnCache() || (this.objectCaching && (!parent || !parent.isOnACache()));
       return this.ownCaching;
     },
 
@@ -1308,8 +1316,9 @@
      * @private
      * @param {CanvasRenderingContext2D} ctx Context to render on
      */
-    _setOpacity: function(ctx) {
-      if (this.group && !this.group._transformDone) {
+    _setOpacity: function (ctx) {
+      var parent = this.group || this.parent;
+      if (parent && !parent._transformDone) {
         ctx.globalAlpha = this.getObjectOpacity();
       }
       else {
@@ -1932,6 +1941,27 @@
       };
     },
 
+    /**
+     * Checks if object is decendant of target
+     * Should be used instead of @link {fabric.Collection.contains} for performance reasons
+     * @param {fabric.Object|fabric.StaticCanvas} target 
+     * @returns {boolean}
+     */
+    isDescendantOf: function (target) {
+      var parent = this.group || this.parent || this.canvas;
+      while (parent) {
+        if (target === parent) {
+          return true;
+        }
+        else if (parent instanceof fabric.StaticCanvas) {
+          //  happens after all parents were traversed through without a match
+          return false;
+        }
+        parent = parent.group || parent.parent || parent.canvas;
+      }
+      return false;
+    },
+
     /**
      * Sets canvas globalCompositeOperation for specific object
      * custom composition operation for the particular object can be specified using globalCompositeOperation property
diff --git a/src/shapes/polygon.class.js b/src/shapes/polygon.class.js
index f5159b48..9c205f67 100644
--- a/src/shapes/polygon.class.js
+++ b/src/shapes/polygon.class.js
@@ -2,8 +2,7 @@
 
   'use strict';
 
-  var fabric = global.fabric || (global.fabric = {}),
-      projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;
+  var fabric = global.fabric || (global.fabric = { });
 
   if (fabric.Polygon) {
     fabric.warn('fabric.Polygon is already defined');
@@ -25,13 +24,6 @@
      */
     type: 'polygon',
 
-    /**
-     * @private
-     */
-    _projectStrokeOnPoints: function () {
-      return projectStrokeOnPoints(this.points, this);
-    },
-
     /**
      * @private
      * @param {CanvasRenderingContext2D} ctx Context to render on
diff --git a/src/shapes/polyline.class.js b/src/shapes/polyline.class.js
index fb676459..2575a9ca 100644
--- a/src/shapes/polyline.class.js
+++ b/src/shapes/polyline.class.js
@@ -6,8 +6,7 @@
       extend = fabric.util.object.extend,
       min = fabric.util.array.min,
       max = fabric.util.array.max,
-      toFixed = fabric.util.toFixed,
-      projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;
+      toFixed = fabric.util.toFixed;
 
   if (fabric.Polyline) {
     fabric.warn('fabric.Polyline is already defined');
@@ -36,17 +35,6 @@
      */
     points: null,
 
-    /**
-     * WARNING: Feature in progress
-     * Calculate the exact bounding box taking in account strokeWidth on acute angles
-     * this will be turned to true by default on fabric 5.0
-     * maybe will be left in as an optimization since calculations may be slow
-     * @deprecated
-     * @type Boolean
-     * @default false
-     */
-    exactBoundingBox: false,
-
     cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),
 
     /**
@@ -75,25 +63,13 @@
       this._setPositionDimensions(options);
     },
 
-    /**
-     * @private
-     */
-    _projectStrokeOnPoints: function () {
-      return projectStrokeOnPoints(this.points, this, true);
-    },
-
     _setPositionDimensions: function(options) {
-      var calcDim = this._calcDimensions(options), correctLeftTop,
-          correctSize = this.exactBoundingBox ? this.strokeWidth : 0;
-      this.width = calcDim.width - correctSize;
-      this.height = calcDim.height - correctSize;
+      var calcDim = this._calcDimensions(options), correctLeftTop;
+      this.width = calcDim.width;
+      this.height = calcDim.height;
       if (!options.fromSVG) {
         correctLeftTop = this.translateToGivenOrigin(
-          {
-            // this looks bad, but is one way to keep it optional for now.
-            x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,
-            y: calcDim.top - this.strokeWidth / 2 + correctSize / 2
-          },
+          { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
           'left',
           'top',
           this.originX,
@@ -107,8 +83,8 @@
         this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
       }
       this.pathOffset = {
-        x: calcDim.left + this.width / 2 + correctSize / 2,
-        y: calcDim.top + this.height / 2 + correctSize / 2
+        x: calcDim.left + this.width / 2,
+        y: calcDim.top + this.height / 2
       };
     },
 
@@ -124,7 +100,7 @@
      */
     _calcDimensions: function() {
 
-      var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points,
+      var points = this.points,
           minX = min(points, 'x') || 0,
           minY = min(points, 'y') || 0,
           maxX = max(points, 'x') || 0,
@@ -136,7 +112,7 @@
         left: minX,
         top: minY,
         width: width,
-        height: height,
+        height: height
       };
     },
 
diff --git a/src/shapes/text.class.js b/src/shapes/text.class.js
index e767bbab..04078cf2 100644
--- a/src/shapes/text.class.js
+++ b/src/shapes/text.class.js
@@ -1343,12 +1343,19 @@
      * @return {Number} Line width
      */
     getLineWidth: function(lineIndex) {
-      if (this.__lineWidths[lineIndex] !== undefined) {
+      if (this.__lineWidths[lineIndex]) {
         return this.__lineWidths[lineIndex];
       }
 
-      var lineInfo = this.measureLine(lineIndex);
-      var width = lineInfo.width;
+      var width, line = this._textLines[lineIndex], lineInfo;
+
+      if (line === '') {
+        width = 0;
+      }
+      else {
+        lineInfo = this.measureLine(lineIndex);
+        width = lineInfo.width;
+      }
       this.__lineWidths[lineIndex] = width;
       return width;
     },
diff --git a/src/static_canvas.class.js b/src/static_canvas.class.js
index e1cab9da..b63ad41f 100644
--- a/src/static_canvas.class.js
+++ b/src/static_canvas.class.js
@@ -232,7 +232,7 @@
      * @private
      */
     _isRetinaScaling: function() {
-      return (fabric.devicePixelRatio > 1 && this.enableRetinaScaling);
+      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
     },
 
     /**
@@ -240,7 +240,7 @@
      * @return {Number} retinaScaling if applied, otherwise 1;
      */
     getRetinaScaling: function() {
-      return Math.max(1, fabric.devicePixelRatio);
+      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
     },
 
     /**
diff --git a/src/util/misc.js b/src/util/misc.js
index 24dc83cc..04b0f227 100644
--- a/src/util/misc.js
+++ b/src/util/misc.js
@@ -139,135 +139,6 @@
       };
     },
 
-    /**
-     * Creates a vetor from points represented as a point
-     * @static
-     * @memberOf fabric.util
-     *
-     * @typedef {Object} Point
-     * @property {number} x
-     * @property {number} y
-     *
-     * @param {Point} from
-     * @param {Point} to
-     * @returns {Point} vector
-     */
-    createVector: function (from, to) {
-      return new fabric.Point(to.x - from.x, to.y - from.y);
-    },
-
-    /**
-     * Calculates angle between 2 vectors using dot product
-     * @static
-     * @memberOf fabric.util
-     * @param {Point} a
-     * @param {Point} b
-     * @returns the angle in radian between the vectors
-     */
-    calcAngleBetweenVectors: function (a, b) {
-      return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));
-    },
-
-    /**
-     * @static
-     * @memberOf fabric.util
-     * @param {Point} v
-     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`
-     */
-    getHatVector: function (v) {
-      return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));
-    },
-
-    /**
-     * @static
-     * @memberOf fabric.util
-     * @param {Point} A
-     * @param {Point} B
-     * @param {Point} C
-     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle
-     */
-    getBisector: function (A, B, C) {
-      var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);
-      var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);
-      //  check if alpha is relative to AB->BC
-      var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);
-      var phi = alpha * (ro === 0 ? 1 : -1) / 2;
-      return {
-        vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),
-        angle: alpha
-      };
-    },
-
-    /**
-     * Project stroke width on points returning 2 projections for each point as follows:
-     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.
-     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.
-     * - `round`: same as `bevel`
-     * Used to calculate object's bounding box
-     * @static
-     * @memberOf fabric.util
-     * @param {Point[]} points
-     * @param {Object} options
-     * @param {number} options.strokeWidth
-     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin
-     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit
-     * @param {boolean} options.strokeUniform
-     * @param {number} options.scaleX
-     * @param {number} options.scaleY
-     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points
-     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points
-     */
-    projectStrokeOnPoints: function (points, options, openPath) {
-      var coords = [], s = options.strokeWidth / 2,
-          strokeUniformScalar = options.strokeUniform ?
-            new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1),
-          getStrokeHatVector = function (v) {
-            var scalar = s / (Math.hypot(v.x, v.y));
-            return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);
-          };
-      if (points.length <= 1) {return coords;}
-      points.forEach(function (p, index) {
-        var A = new fabric.Point(p.x, p.y), B, C;
-        if (index === 0) {
-          C = points[index + 1];
-          B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];
-        }
-        else if (index === points.length - 1) {
-          B = points[index - 1];
-          C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];
-        }
-        else {
-          B = points[index - 1];
-          C = points[index + 1];
-        }
-        var bisector = fabric.util.getBisector(A, B, C),
-            bisectorVector = bisector.vector,
-            alpha = bisector.angle,
-            scalar,
-            miterVector;
-        if (options.strokeLineJoin === 'miter') {
-          scalar = -s / Math.sin(alpha / 2);
-          miterVector = new fabric.Point(
-            bisectorVector.x * scalar * strokeUniformScalar.x,
-            bisectorVector.y * scalar * strokeUniformScalar.y
-          );
-          if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {
-            coords.push(A.add(miterVector));
-            coords.push(A.subtract(miterVector));
-            return;
-          }
-        }
-        scalar = -s * Math.SQRT2;
-        miterVector = new fabric.Point(
-          bisectorVector.x * scalar * strokeUniformScalar.x,
-          bisectorVector.y * scalar * strokeUniformScalar.y
-        );
-        coords.push(A.add(miterVector));
-        coords.push(A.subtract(miterVector));
-      });
-      return coords;
-    },
-
     /**
      * Apply transform t to point p
      * @static
@@ -621,18 +492,17 @@
     },
 
     /**
-     * Groups SVG elements (usually those retrieved from SVG document)
+     * prepares options object from svg
      * @static
      * @memberOf fabric.util
      * @param {Array} elements SVG elements to group
      * @param {Object} [options] Options object
      * @param {String} path Value to set sourcePath to
-     * @return {fabric.Object|fabric.Group}
+     * @return {Object|undefined} options
      */
-    groupSVGElements: function(elements, options, path) {
-      var object;
+    getOptionsFromSVG: function (elements, options, path) {
       if (elements && elements.length === 1) {
-        return elements[0];
+        return;
       }
       if (options) {
         if (options.width && options.height) {
@@ -646,10 +516,27 @@
           delete options.height;
         }
       }
-      object = new fabric.Group(elements, options);
       if (typeof path !== 'undefined') {
-        object.sourcePath = path;
+        options.sourcePath = path;
+      }
+      return options;
+    },
+
+    /**
+     * Groups SVG elements (usually those retrieved from SVG document)
+     * @static
+     * @memberOf fabric.util
+     * @param {Array} elements SVG elements to group
+     * @param {Object} [options] Options object
+     * @param {String} path Value to set sourcePath to
+     * @return {fabric.Object|fabric.Group}
+     */
+    groupSVGElements: function(elements, options, path) {
+      var object;
+      if (elements && elements.length === 1) {
+        return elements[0];
       }
+      object = new fabric.Group(elements, fabric.util.getOptionsFromSVG(elements, options, path));
       return object;
     },
 
diff --git a/src/util/path.js b/src/util/path.js
index 705e732f..a187ea65 100644
--- a/src/util/path.js
+++ b/src/util/path.js
@@ -507,15 +507,15 @@
         p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
     // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
     // the path
-    while (tmpLen < distance && nextStep > 0.0001) {
+    while (tmpLen < distance && perc <= 1 && nextStep > 0.0001) {
       p = iterator(perc);
       lastPerc = perc;
       nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
       // compare tmpLen each cycle with distance, decide next perc to test.
       if ((nextLen + tmpLen) > distance) {
         // we discard this step and we make smaller steps.
-        perc -= nextStep;
         nextStep /= 2;
+        perc -= nextStep;
       }
       else {
         tempP = p;
diff --git a/test/unit/activeselection.js b/test/unit/activeselection.js
index 89b5fc75..8a07f9d4 100644
--- a/test/unit/activeselection.js
+++ b/test/unit/activeselection.js
@@ -45,231 +45,8 @@
     assert.equal(group.toString(), '#<fabric.ActiveSelection: (2)>', 'should return proper representation');
   });
 
-  QUnit.test('toObject', function(assert) {
-    var group = makeAsWith2Objects();
-
-    assert.ok(typeof group.toObject === 'function');
-
-    var clone = group.toObject();
-
-    var expectedObject = {
-      version:                  fabric.version,
-      type:                     'activeSelection',
-      originX:                  'left',
-      originY:                  'top',
-      left:                     50,
-      top:                      100,
-      width:                    80,
-      height:                   60,
-      fill:                     'rgb(0,0,0)',
-      stroke:                   null,
-      strokeWidth:              0,
-      strokeDashArray:          null,
-      strokeLineCap:            'butt',
-      strokeDashOffset:         0,
-      strokeLineJoin:           'miter',
-      strokeMiterLimit:         4,
-      scaleX:                   1,
-      scaleY:                   1,
-      shadow:                   null,
-      visible:                  true,
-      backgroundColor:          '',
-      angle:                    0,
-      flipX:                    false,
-      flipY:                    false,
-      opacity:                  1,
-      fillRule:                 'nonzero',
-      paintFirst:               'fill',
-      globalCompositeOperation: 'source-over',
-      skewX:                    0,
-      skewY:                    0,
-      strokeUniform:            false,
-      objects:                  clone.objects
-    };
-
-    assert.deepEqual(clone, expectedObject);
-
-    assert.ok(group !== clone, 'should produce different object');
-    assert.ok(group.getObjects() !== clone.objects, 'should produce different object array');
-    assert.ok(group.getObjects()[0] !== clone.objects[0], 'should produce different objects in array');
-  });
-
-  QUnit.test('toObject without default values', function(assert) {
-    var group = makeAsWith2Objects();
-    group.includeDefaultValues = false;
-    var clone = group.toObject();
-    var objects = [{
-      version:                  fabric.version,
-      type: 'rect',
-      left: 10,
-      top: -30,
-      width: 30,
-      height: 10,
-      strokeWidth: 0
-    }, {
-      version:                  fabric.version,
-      type: 'rect',
-      left: -40,
-      top: -10,
-      width: 10,
-      height: 40,
-      strokeWidth: 0
-    }];
-    var expectedObject = {
-      version:            fabric.version,
-      type:               'activeSelection',
-      left:               50,
-      top:                100,
-      width:              80,
-      height:             60,
-      objects:            objects
-    };
-    assert.deepEqual(clone, expectedObject);
-  });
-
   QUnit.test('_renderControls', function(assert) {
     assert.ok(typeof fabric.ActiveSelection.prototype._renderControls === 'function');
   });
 
-  QUnit.test('fromObject', function(assert) {
-    var done = assert.async();
-    var group = makeAsWith2ObjectsWithOpacity();
-
-    assert.ok(typeof fabric.ActiveSelection.fromObject === 'function');
-    var groupObject = group.toObject();
-
-    fabric.ActiveSelection.fromObject(groupObject, function(newGroupFromObject) {
-
-      var objectFromOldGroup = group.toObject();
-      var objectFromNewGroup = newGroupFromObject.toObject();
-
-      assert.ok(newGroupFromObject instanceof fabric.ActiveSelection);
-
-      assert.deepEqual(objectFromOldGroup.objects[0], objectFromNewGroup.objects[0]);
-      assert.deepEqual(objectFromOldGroup.objects[1], objectFromNewGroup.objects[1]);
-
-      // delete `objects` arrays, since `assertHashEqual` fails to compare them for equality
-      delete objectFromOldGroup.objects;
-      delete objectFromNewGroup.objects;
-
-      assert.deepEqual(objectFromOldGroup, objectFromNewGroup);
-
-      done();
-    });
-  });
-
-  QUnit.test('get with locked objects', function(assert) {
-    var group = makeAsWith2Objects();
-
-    assert.equal(group.get('lockMovementX'), false);
-
-    // TODO activeGroup
-    // group.getObjects()[0].lockMovementX = true;
-    // assert.equal(group.get('lockMovementX'), true);
-    //
-    // group.getObjects()[0].lockMovementX = false;
-    // assert.equal(group.get('lockMovementX'), false);
-
-    group.set('lockMovementX', true);
-    assert.equal(group.get('lockMovementX'), true);
-
-    // group.set('lockMovementX', false);
-    // group.getObjects()[0].lockMovementY = true;
-    // group.getObjects()[1].lockRotation = true;
-    //
-    // assert.equal(group.get('lockMovementY'), true);
-    // assert.equal(group.get('lockRotation'), true);
-  });
-
-  QUnit.test('insertAt', function(assert) {
-    var rect1 = new fabric.Rect(),
-        rect2 = new fabric.Rect(),
-        group = new fabric.Group();
-
-    group.add(rect1, rect2);
-
-    assert.ok(typeof group.insertAt === 'function', 'should respond to `insertAt` method');
-
-    group.insertAt(rect1, 1);
-    assert.equal(group.item(1), rect1);
-    group.insertAt(rect2, 2);
-    assert.equal(group.item(2), rect2);
-    assert.equal(group.insertAt(rect1, 2), group, 'should be chainable');
-  });
-
-  QUnit.test('group addWithUpdate', function(assert) {
-    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
-        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
-        group = new fabric.Group([rect1]);
-
-    var coords = group.oCoords;
-    group.addWithUpdate(rect2);
-    var newCoords = group.oCoords;
-    assert.notEqual(coords, newCoords, 'object coords have been recalculated - add');
-  });
-
-  QUnit.test('group removeWithUpdate', function(assert) {
-    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
-        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
-        group = new fabric.Group([rect1, rect2]);
-
-    var coords = group.oCoords;
-    group.removeWithUpdate(rect2);
-    var newCoords = group.oCoords;
-    assert.notEqual(coords, newCoords, 'object coords have been recalculated - remove');
-  });
-
-  QUnit.test('ActiveSelection shouldCache', function(assert) {
-    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
-        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
-        group = new fabric.ActiveSelection([rect1, rect2], { objectCaching: true});
-
-    assert.equal(group.shouldCache(), false, 'Active selection do not cache');
-  });
-
-  QUnit.test('canvas property propagation', function(assert) {
-    var g2 = makeAsWith4Objects();
-
-    canvas.add(g2);
-    assert.equal(g2.canvas, canvas);
-    assert.equal(g2._objects[3].canvas, canvas);
-  });
-
-  QUnit.test('moveTo on activeSelection', function(assert) {
-    var group = makeAsWith4Objects({ canvas: canvas }),
-        groupEl1 = group.getObjects()[0],
-        groupEl2 = group.getObjects()[1],
-        groupEl3 = group.getObjects()[2],
-        groupEl4 = group.getObjects()[3];
-    canvas.add(groupEl1, groupEl2, groupEl3, groupEl4);
-    canvas.setActiveObject(group);
-    assert.ok(typeof group.item(0).moveTo === 'function');
-
-    // [ 1, 2, 3, 4 ]
-    assert.equal(group.item(0), groupEl1, 'actual group position 1');
-    assert.equal(group.item(1), groupEl2, 'actual group position 2');
-    assert.equal(group.item(2), groupEl3, 'actual group position 3');
-    assert.equal(group.item(3), groupEl4, 'actual group position 4');
-    assert.equal(group.item(9999), undefined);
-    assert.equal(canvas.item(0), groupEl1, 'actual canvas position 1');
-    assert.equal(canvas.item(1), groupEl2, 'actual canvas position 2');
-    assert.equal(canvas.item(2), groupEl3, 'actual canvas position 3');
-    assert.equal(canvas.item(3), groupEl4, 'actual canvas position 4');
-    assert.equal(canvas.item(9999), undefined);
-
-    group.item(0).moveTo(3);
-
-    assert.equal(group.item(0), groupEl1, 'did not change group position 1');
-    assert.equal(group.item(1), groupEl2, 'did not change group position 2');
-    assert.equal(group.item(2), groupEl3, 'did not change group position 3');
-    assert.equal(group.item(3), groupEl4, 'did not change group position 4');
-    assert.equal(group.item(9999), undefined);
-    // moved 1 to level 3 — [2, 3, 4, 1]
-    assert.equal(canvas.item(3), groupEl1, 'item 1 is not at last');
-    assert.equal(canvas.item(0), groupEl2, 'item 2 shifted down to 1');
-    assert.equal(canvas.item(1), groupEl3, 'item 3 shifted down to 2');
-    assert.equal(canvas.item(2), groupEl4, 'item 4 shifted down to 3');
-    assert.equal(canvas.item(9999), undefined);
-  });
-
 })();
diff --git a/test/unit/canvas.js b/test/unit/canvas.js
index 1594d29e..30012272 100644
--- a/test/unit/canvas.js
+++ b/test/unit/canvas.js
@@ -717,8 +717,8 @@
       rect3Selected = true;
     });
     var currentObjects = canvas.getActiveObjects();
-    activeSelection.removeWithUpdate(rect1);
-    activeSelection.addWithUpdate(rect3);
+    activeSelection.remove(rect1);
+    activeSelection.add(rect3);
     canvas._fireSelectionEvents(currentObjects, {});
     assert.ok(rect3Selected, 'rect 3 selected');
     assert.ok(rect1Deselected, 'rect 1 deselected');
diff --git a/test/unit/icollection.js b/test/unit/icollection.js
new file mode 100644
index 00000000..2618d101
--- /dev/null
+++ b/test/unit/icollection.js
@@ -0,0 +1,832 @@
+(function() {
+  var canvas = this.canvas = new fabric.StaticCanvas(null, { enableRetinaScaling: false, width: 600, height: 600 });
+  
+  /**
+   * 
+   * @returns {[fabric.Rect, fabric.Rect]}
+   */
+  function get2Objects() {
+    return [
+      new fabric.Rect({ top: 100, left: 100, width: 30, height: 10, strokeWidth: 0 }),
+      new fabric.Rect({ top: 120, left: 50, width: 10, height: 40, strokeWidth: 0 })
+    ];
+  }
+
+  function get2ObjectsWithOpacity() {
+    return [
+      new fabric.Rect({ top: 100, left: 100, width: 30, height: 10, strokeWidth: 0, opacity: 0.5 }),
+      new fabric.Rect({ top: 120, left: 50, width: 10, height: 40, strokeWidth: 0, opacity: 0.8 })
+    ];
+  }
+
+  function get4Objects() {
+    return [
+      new fabric.Rect({ top: 100, left: 100, width: 30, height: 10 }),
+      new fabric.Rect({ top: 120, left: 50, width: 10, height: 40 }),
+      new fabric.Rect({ top: 40, left: 0, width: 20, height: 40 }),
+      new fabric.Rect({ top: 75, left: 75, width: 40, height: 40 })
+    ];
+  }
+
+  function makeCollectionWith2Objects() {
+    return new fabric.ICollection(get2Objects(), {strokeWidth: 0});
+  }
+
+  function makeCollectionWith2ObjectsWithOpacity() {
+    return new fabric.ICollection(get2ObjectsWithOpacity(), {strokeWidth: 0,opacity:0.7});
+  }
+
+  function makeCollectionWith2ObjectsAndNoExport() {
+    var objects = get2Objects();
+    objects[1].excludeFromExport = true;
+    return new fabric.ICollection(objects, { strokeWidth: 0 });
+  }
+
+  function makeCollectionWith4Objects() {
+    return new fabric.ICollection(get4Objects());
+  }
+
+  function serializeObjects(arg, includeDefaultValues = false) {
+    if (arg._objects) {
+      var defaults = arg.includeDefaultValues;
+      arg.includeDefaultValues = includeDefaultValues;
+      var data = arg.toObject().objects;
+      arg.includeDefaultValues = defaults;
+      return data;
+    }
+    else if (Array.isArray(arg)) {
+      return arg.map(o => {
+        var defaults = o.includeDefaultValues;
+        o.includeDefaultValues = includeDefaultValues;
+        var data = o.toObject();
+        o.includeDefaultValues = defaults;
+        delete data.version;
+        return data;
+      });
+    }
+    throw new Error('bad input, can\'t serialize');
+  }
+
+  QUnit.module('fabric.ICollection', {
+    afterEach: function() {
+      fabric.Object.__uid = 0;
+      canvas.clear();
+      canvas.backgroundColor = fabric.Canvas.prototype.backgroundColor;
+      canvas.calcOffset();
+    }
+  });
+
+  QUnit.test('constructor', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(collection);
+    assert.ok(collection instanceof fabric.ICollection, 'should be instance of fabric.ICollection');
+  });
+
+  QUnit.test('toString', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    assert.equal(collection.toString(), '#<fabric.ICollection: (2)>', 'should return proper representation');
+  });
+
+  QUnit.test('getObjects', function(assert) {
+    var rect1 = new fabric.Rect(),
+        rect2 = new fabric.Rect();
+
+    var collection = new fabric.ICollection([rect1, rect2]);
+
+    assert.ok(typeof collection.getObjects === 'function');
+    assert.ok(Object.prototype.toString.call(collection.getObjects()) == '[object Array]', 'should be an array');
+    assert.equal(collection.getObjects().length, 2, 'should have 2 items');
+    assert.deepEqual(collection.getObjects(), [rect1, rect2], 'should return deepEqual objects as those passed to constructor');
+  });
+
+  QUnit.test('getObjects with type', function(assert) {
+    var rect = new fabric.Rect({ width: 10, height: 20 }),
+        circle = new fabric.Circle({ radius: 30 });
+
+    var collection = new fabric.ICollection([rect, circle]);
+
+    assert.equal(collection.size(), 2, 'should have length=2 initially');
+
+    assert.deepEqual(collection.getObjects('rect'), [rect], 'should return rect only');
+    assert.deepEqual(collection.getObjects('circle'), [circle], 'should return circle only');
+  });
+
+  QUnit.test('add', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    var fired = [];
+    var rect1 = new fabric.Rect(),
+        rect2 = new fabric.Rect(),
+        rect3 = new fabric.Rect();
+    
+    collection.getObjects()
+      .concat(rect1, rect2, rect3).forEach(rect => rect.on('added', ({ target }) => {
+        assert.equal(target, collection);
+        fired.push(rect);
+      }));
+
+    assert.ok(typeof collection.add === 'function');
+    assert.equal(collection.add(rect1), collection, 'should be chainable');
+    assert.strictEqual(collection.item(collection.size() - 1), rect1, 'last object should be newly added one');
+    assert.equal(collection.getObjects().length, 3, 'there should be 3 objects');
+    assert.deepEqual(fired, [rect1]);
+
+    collection.add(rect2, rect3);
+    assert.strictEqual(collection.item(collection.size() - 1), rect3, 'last object should be last added one');
+    assert.equal(collection.size(), 5, 'there should be 5 objects');
+    assert.deepEqual(fired, [rect1, rect2, rect3]);
+  });
+
+  QUnit.test('insertAt', function (assert) {
+    var rect1 = new fabric.Rect(),
+      rect2 = new fabric.Rect(),
+      collection = new fabric.ICollection();
+
+    collection.add(rect1, rect2);
+
+    assert.ok(typeof collection.insertAt === 'function', 'should respond to `insertAt` method');
+
+    collection.insertAt(rect1, 1);
+    assert.equal(collection.item(1), rect1);
+    collection.insertAt(rect2, 2);
+    assert.equal(collection.item(2), rect2);
+    assert.equal(collection.insertAt(rect1, 2), collection, 'should be chainable');
+  });
+
+  QUnit.test('remove', function(assert) {
+    var rect1 = new fabric.Rect(),
+      rect2 = new fabric.Rect(),
+      rect3 = new fabric.Rect(),
+      rect4 = new fabric.Rect(),
+      collection = new fabric.ICollection([rect1, rect2, rect3, rect4]),
+      fired = [];
+
+    collection.getObjects()
+      .forEach(rect => rect.on('removed', ({ target }) => {
+        assert.equal(target, collection);
+        fired.push(rect);
+      }));
+    
+    assert.ok(typeof collection.remove === 'function');
+    assert.equal(collection.remove(rect2), collection, 'should be chainable');
+    assert.deepEqual(collection.getObjects(), [rect1, rect3, rect4], 'should remove object properly');
+    assert.deepEqual(fired, [rect2]);
+
+    collection.remove(rect1, rect3);
+    assert.deepEqual(collection.getObjects(), [rect4], 'should remove object properly');
+    assert.deepEqual(fired, [rect2, rect1, rect3]);
+
+    collection.remove(rect4);
+    assert.equal(collection.isEmpty(), true, 'collection should be empty');
+  });
+
+  QUnit.test('removeAll', function (assert) {
+    var rect1 = new fabric.Rect(),
+      rect2 = new fabric.Rect(),
+      rect3 = new fabric.Rect(),
+      rect4 = new fabric.Rect(),
+      collection = new fabric.ICollection([rect1, rect2, rect3, rect4]),
+      fired = [];
+
+    collection.getObjects()
+      .forEach(rect => rect.on('removed', ({ target }) => {
+        assert.equal(target, collection);
+        fired.push(rect);
+      }));
+
+    assert.ok(typeof collection.removeAll === 'function');
+    collection.removeAll();
+    assert.deepEqual(fired, [rect1, rect2, rect3, rect4]);
+    assert.equal(collection.isEmpty(), true, 'collection should be empty');
+  });
+
+  QUnit.test('size', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(typeof collection.size === 'function');
+    assert.equal(collection.size(), 2);
+    collection.add(new fabric.Rect());
+    assert.equal(collection.size(), 3);
+    collection.remove(collection.getObjects()[0]);
+    collection.remove(collection.getObjects()[0]);
+    assert.equal(collection.size(), 1);
+  });
+
+  QUnit.test('set', function(assert) {
+    var collection = makeCollectionWith2Objects(),
+        firstObject = collection.getObjects()[0];
+
+    assert.ok(typeof collection.set === 'function');
+
+    assert.equal(collection.set('opacity', 0.12345), collection, 'should be chainable');
+    assert.equal(collection.get('opacity'), 0.12345, 'collection\'s "own" property should be set properly');
+    assert.equal(firstObject.get('opacity'), 1, 'objects\' value of non delegated property should stay same');
+
+    collection.set('left', 1234);
+    assert.equal(collection.get('left'), 1234, 'collection\'s own "left" property should be set properly');
+    assert.ok(firstObject.get('left') !== 1234, 'objects\' value should not be affected');
+
+    collection.set({ left: 888, top: 999 });
+    assert.equal(collection.get('left'), 888, 'collection\'s own "left" property should be set properly via object');
+    assert.equal(collection.get('top'), 999, 'collection\'s own "top" property should be set properly via object');
+  });
+
+  QUnit.test('contains', function(assert) {
+    var rect1 = new fabric.Rect(),
+      rect2 = new fabric.Rect(),
+      deepRect = new fabric.Rect(),
+      notIncludedRect = new fabric.Rect(),
+      subCollection = new fabric.ICollection([deepRect]),
+      collection = new fabric.ICollection([rect1, rect2, subCollection]);
+
+    assert.ok(typeof collection.contains === 'function');
+
+    assert.ok(collection.contains(rect1), 'should contain first object');
+    assert.ok(collection.contains(rect2), 'should contain second object');
+    assert.ok(collection.contains(subCollection), 'should contain second object');
+    assert.ok(collection.contains(deepRect) === false, 'should not pass shallow contains');
+    assert.ok(collection.contains(deepRect, true), 'should deep contain object');
+    assert.ok(!collection.contains(notIncludedRect), 'should report not-included one properly');
+  });
+
+  QUnit.test('toObject', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(typeof collection.toObject === 'function');
+
+    var clone = collection.toObject();
+
+    var expectedObject = {
+      version:                  fabric.version,
+      type:                     'iCollection',
+      layout:                   'fit-content',
+      originX:                  'left',
+      originY:                  'top',
+      left:                     50,
+      top:                      100,
+      width:                    80,
+      height:                   60,
+      fill:                     '',
+      stroke:                   null,
+      strokeWidth:              0,
+      strokeDashArray:          null,
+      strokeLineCap:            'butt',
+      strokeDashOffset:         0,
+      strokeLineJoin:           'miter',
+      strokeMiterLimit:         4,
+      scaleX:                   1,
+      scaleY:                   1,
+      shadow:                   null,
+      visible:                  true,
+      backgroundColor:          '',
+      angle:                    0,
+      flipX:                    false,
+      flipY:                    false,
+      opacity:                  1,
+      fillRule:                 'nonzero',
+      paintFirst:               'fill',
+      globalCompositeOperation: 'source-over',
+      skewX:                    0,
+      skewY:                    0,
+      objects:                  serializeObjects(collection, true),
+      strokeUniform:            false
+    };
+
+    assert.deepEqual(clone, expectedObject);
+
+    assert.ok(collection !== clone, 'should produce different object');
+    assert.ok(collection.getObjects() !== clone.objects, 'should produce different object array');
+    assert.ok(collection.getObjects()[0] !== clone.objects[0], 'should produce different objects in array');
+  });
+
+  QUnit.test('toObject without default values', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    collection.includeDefaultValues = false;
+    var clone = collection.toObject();
+    var expectedObject = {
+      version: fabric.version,
+      type: 'iCollection',
+      left: 50,
+      top: 100,
+      width: 80,
+      height: 60,
+      objects: serializeObjects(get2Objects())
+    };
+    assert.deepEqual(clone, expectedObject);
+  });
+
+  QUnit.test('toObject with excludeFromExport set on an object', function (assert) {
+    var c1 = makeCollectionWith2Objects();
+    var c2 = makeCollectionWith2ObjectsAndNoExport();
+    assert.deepEqual(serializeObjects(c2), serializeObjects(c2._objects.filter(obj => !obj.excludeFromExport)));
+    var clone = c1.toObject();
+    var clone2 = c2.toObject();
+    delete clone.objects;
+    delete clone2.objects;
+    assert.deepEqual(clone, clone2);
+  });
+
+  QUnit.test('Collection does not mutate objects', function (assert) {
+    assert.deepEqual(serializeObjects(makeCollectionWith2Objects()), serializeObjects(get2Objects()), 'should return deepEqual objects as those passed to constructor');
+    assert.deepEqual(serializeObjects(makeCollectionWith2ObjectsWithOpacity()), serializeObjects(get2ObjectsWithOpacity()), 'should return deepEqual objects as those passed to constructor');
+    assert.deepEqual(serializeObjects(makeCollectionWith4Objects()), serializeObjects(get4Objects()), 'should return deepEqual objects as those passed to constructor');
+  });
+
+  QUnit.test('render', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    assert.ok(typeof collection.render === 'function');
+  });
+
+  QUnit.test('item', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(typeof collection.item === 'function');
+    assert.equal(collection.item(0), collection.getObjects()[0]);
+    assert.equal(collection.item(1), collection.getObjects()[1]);
+    assert.equal(collection.item(9999), undefined);
+  });
+
+  QUnit.test('moveTo', function(assert) {
+    var collection = makeCollectionWith4Objects(),
+        groupEl1 = collection.getObjects()[0],
+        groupEl2 = collection.getObjects()[1],
+        groupEl3 = collection.getObjects()[2],
+        groupEl4 = collection.getObjects()[3];
+
+    assert.ok(typeof collection.item(0).moveTo === 'function');
+
+    // [ 1, 2, 3, 4 ]
+    assert.equal(collection.item(0), groupEl1);
+    assert.equal(collection.item(1), groupEl2);
+    assert.equal(collection.item(2), groupEl3);
+    assert.equal(collection.item(3), groupEl4);
+    assert.equal(collection.item(9999), undefined);
+
+    collection.item(0).moveTo(3);
+
+    // moved 1 to level 3 — [2, 3, 4, 1]
+    assert.equal(collection.item(3), groupEl1);
+    assert.equal(collection.item(0), groupEl2);
+    assert.equal(collection.item(1), groupEl3);
+    assert.equal(collection.item(2), groupEl4);
+    assert.equal(collection.item(9999), undefined);
+
+    collection.item(0).moveTo(2);
+
+    // moved 2 to level 2 — [3, 4, 2, 1]
+    assert.equal(collection.item(3), groupEl1);
+    assert.equal(collection.item(2), groupEl2);
+    assert.equal(collection.item(0), groupEl3);
+    assert.equal(collection.item(1), groupEl4);
+    assert.equal(collection.item(9999), undefined);
+  });
+
+  QUnit.test('complexity', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(typeof collection.complexity === 'function');
+    assert.equal(collection.complexity(), 2);
+  });
+
+  QUnit.test('containsPoint', function(assert) {
+
+    var collection = makeCollectionWith2Objects();
+    collection.set({ originX: 'center', originY: 'center' }).setCoords();
+
+    //  Rect #1     top: 100, left: 100, width: 30, height: 10
+    //  Rect #2     top: 120, left: 50, width: 10, height: 40
+
+    assert.ok(typeof collection.containsPoint === 'function');
+
+    assert.ok(!collection.containsPoint({ x: 0, y: 0 }));
+
+    collection.scale(2);
+    assert.ok(collection.containsPoint({ x: 50, y: 120 }));
+    assert.ok(collection.containsPoint({ x: 100, y: 160 }));
+    assert.ok(!collection.containsPoint({ x: 0, y: 0 }));
+
+    collection.scale(1);
+    collection.padding = 30;
+    collection.setCoords();
+    assert.ok(collection.containsPoint({ x: 50, y: 120 }));
+    assert.ok(!collection.containsPoint({ x: 100, y: 170 }));
+    assert.ok(!collection.containsPoint({ x: 0, y: 0 }));
+  });
+
+  QUnit.test('forEachObject', function(assert) {
+    var collection = makeCollectionWith2Objects();
+
+    assert.ok(typeof collection.forEachObject === 'function');
+    assert.equal(collection.forEachObject(function(){}), collection, 'should be chainable');
+
+    var iteratedObjects = [];
+    collection.forEachObject(function(groupObject) {
+      iteratedObjects.push(groupObject);
+    });
+
+    assert.equal(iteratedObjects[0], collection.getObjects()[0], 'iteration give back objects in same order');
+    assert.equal(iteratedObjects[1], collection.getObjects()[1], 'iteration give back objects in same order');
+  });
+
+  QUnit.test('fromObject', function(assert) {
+    var done = assert.async();
+    var collection = makeCollectionWith2ObjectsWithOpacity();
+
+    assert.ok(typeof fabric.ICollection.fromObject === 'function');
+    var groupObject = collection.toObject();
+
+    fabric.ICollection.fromObject(groupObject, function(newGroupFromObject) {
+
+      var objectFromOldGroup = collection.toObject();
+      var objectFromNewGroup = newGroupFromObject.toObject();
+
+      assert.ok(newGroupFromObject instanceof fabric.ICollection);
+
+      assert.deepEqual(objectFromOldGroup.objects[0], objectFromNewGroup.objects[0]);
+      assert.deepEqual(objectFromOldGroup.objects[1], objectFromNewGroup.objects[1]);
+
+      // delete `objects` arrays, since `assertHashEqual` fails to compare them for equality
+      delete objectFromOldGroup.objects;
+      delete objectFromNewGroup.objects;
+
+      assert.deepEqual(objectFromOldGroup, objectFromNewGroup);
+
+      done();
+    });
+  });
+
+  QUnit.test('fromObject with clipPath', function(assert) {
+    var done = assert.async();
+    var clipPath = new fabric.Rect({
+      width: 500,
+      height: 250,
+      top: 0,
+      left: 0,
+      absolutePositioned: true
+    });
+
+    var groupObject = new fabric.ICollection([
+      new fabric.Rect({ width: 100, height: 100, fill: 'red' }),
+      new fabric.Rect({ width: 100, height: 100, fill: 'yellow', left: 100 }),
+      new fabric.Rect({ width: 100, height: 100, fill: 'blue', top: 100 }),
+      new fabric.Rect({ width: 100, height: 100, fill: 'green', left: 100, top: 100 })
+    ]);
+    groupObject.clipPath = clipPath;
+
+    var groupToObject = groupObject.toObject();
+
+    fabric.ICollection.fromObject(groupToObject, function(newGroupFromObject) {
+
+      var objectFromNewGroup = newGroupFromObject.toObject();
+
+      assert.ok(newGroupFromObject instanceof fabric.ICollection);
+      assert.ok(newGroupFromObject.clipPath instanceof fabric.Rect, 'clipPath has been restored');
+      assert.deepEqual(objectFromNewGroup, groupToObject, 'double serialization gives same results');
+
+      done();
+    });
+  });
+
+  QUnit.test('fromObject does not delete objects from source', function(assert) {
+    var done = assert.async();
+    var collection = makeCollectionWith2ObjectsWithOpacity();
+    var groupObject = collection.toObject();
+
+    fabric.ICollection.fromObject(groupObject, function(newGroupFromObject) {
+      assert.equal(newGroupFromObject.objects, undefined, 'the objects array has not been pulled in');
+      assert.notEqual(groupObject.objects, undefined, 'the objects array has not been deleted from object source');
+      done();
+    });
+  });
+
+  QUnit.test('fromObject with svg url', function(assert) {
+    var done = assert.async();
+    var url = 'data:image/svg+xml,%3csvg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="612px" height="502.174px" viewBox="0 65.326 612 502.174" enable-background="new 0 65.326 612 502.174" xml:space="preserve"%3e %3cellipse fill="%23C6C6C6" cx="283.5" cy="487.5" rx="259" ry="80"/%3e %3cpath id="bird" d="M210.333%2c65.331C104.367%2c66.105-12.349%2c150.637%2c1.056%2c276.449c4.303%2c40.393%2c18.533%2c63.704%2c52.171%2c79.03 c36.307%2c16.544%2c57.022%2c54.556%2c50.406%2c112.954c-9.935%2c4.88-17.405%2c11.031-19.132%2c20.015c7.531-0.17%2c14.943-0.312%2c22.59%2c4.341 c20.333%2c12.375%2c31.296%2c27.363%2c42.979%2c51.72c1.714%2c3.572%2c8.192%2c2.849%2c8.312-3.078c0.17-8.467-1.856-17.454-5.226-26.933 c-2.955-8.313%2c3.059-7.985%2c6.917-6.106c6.399%2c3.115%2c16.334%2c9.43%2c30.39%2c13.098c5.392%2c1.407%2c5.995-3.877%2c5.224-6.991 c-1.864-7.522-11.009-10.862-24.519-19.229c-4.82-2.984-0.927-9.736%2c5.168-8.351l20.234%2c2.415c3.359%2c0.763%2c4.555-6.114%2c0.882-7.875 c-14.198-6.804-28.897-10.098-53.864-7.799c-11.617-29.265-29.811-61.617-15.674-81.681c12.639-17.938%2c31.216-20.74%2c39.147%2c43.489 c-5.002%2c3.107-11.215%2c5.031-11.332%2c13.024c7.201-2.845%2c11.207-1.399%2c14.791%2c0c17.912%2c6.998%2c35.462%2c21.826%2c52.982%2c37.309 c3.739%2c3.303%2c8.413-1.718%2c6.991-6.034c-2.138-6.494-8.053-10.659-14.791-20.016c-3.239-4.495%2c5.03-7.045%2c10.886-6.876 c13.849%2c0.396%2c22.886%2c8.268%2c35.177%2c11.218c4.483%2c1.076%2c9.741-1.964%2c6.917-6.917c-3.472-6.085-13.015-9.124-19.18-13.413 c-4.357-3.029-3.025-7.132%2c2.697-6.602c3.905%2c0.361%2c8.478%2c2.271%2c13.908%2c1.767c9.946-0.925%2c7.717-7.169-0.883-9.566 c-19.036-5.304-39.891-6.311-61.665-5.225c-43.837-8.358-31.554-84.887%2c0-90.363c29.571-5.132%2c62.966-13.339%2c99.928-32.156 c32.668-5.429%2c64.835-12.446%2c92.939-33.85c48.106-14.469%2c111.903%2c16.113%2c204.241%2c149.695c3.926%2c5.681%2c15.819%2c9.94%2c9.524-6.351 c-15.893-41.125-68.176-93.328-92.13-132.085c-24.581-39.774-14.34-61.243-39.957-91.247 c-21.326-24.978-47.502-25.803-77.339-17.365c-23.461%2c6.634-39.234-7.117-52.98-31.273C318.42%2c87.525%2c265.838%2c64.927%2c210.333%2c65.331 z M445.731%2c203.01c6.12%2c0%2c11.112%2c4.919%2c11.112%2c11.038c0%2c6.119-4.994%2c11.111-11.112%2c11.111s-11.038-4.994-11.038-11.111 C434.693%2c207.929%2c439.613%2c203.01%2c445.731%2c203.01z"/%3e %3c/svg%3e';
+    var groupObject = {
+      left: 10,
+      top: 10,
+      objects: url
+    };
+    fabric.ICollection.fromObject(groupObject, function(newGroupFromObject) {
+      assert.equal(newGroupFromObject.sourcePath, url, 'the url is copied in sourcePath');
+      assert.equal(newGroupFromObject._objects.length, 2, '2 objects are created');
+      done();
+    });
+  });
+
+  QUnit.test('toSVG', function (assert) {
+    var collection = makeCollectionWith2Objects();
+    assert.ok(typeof collection.toSVG === 'function');
+    var expectedSVG = '<g transform=\"matrix(1 0 0 1 90 130)\"  >\n<g style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: none; fill-rule: nonzero; opacity: 1;\"   >\n<g transform=\"matrix(1 0 0 1 -90 -130)\">\n\t\t<g transform=\"matrix(1 0 0 1 115 105)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n</g>\n\t\t<g transform=\"matrix(1 0 0 1 55 140)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</g>\n</g>\n</g>\n</g>\n';
+    assert.equal(collection.toSVG(), expectedSVG);
+  });
+
+  QUnit.test('toSVG with unapplied matrix diff', function (assert) {
+    var collection = makeCollectionWith2Objects();
+    collection.subTargetCheck = false;
+    collection.set({ scaleX: 2 });
+    collection.calcOwnMatrix();
+    collection._applyMatrixDiff();
+    var expectedSVG = '<g transform=\"matrix(2 0 0 1 130 130)\"  >\n<g style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: none; fill-rule: nonzero; opacity: 1;\"   >\n<g transform=\"matrix(0.5 0 0 1 -65 -130)\">\n\t\t<g transform=\"matrix(1 0 0 1 115 105)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n</g>\n\t\t<g transform=\"matrix(1 0 0 1 55 140)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</g>\n</g>\n</g>\n</g>\n';
+    assert.equal(collection.toSVG(), expectedSVG);
+  });
+
+  QUnit.test('toSVG with a clipPath', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    collection.clipPath = new fabric.Rect({ width: 100, height: 100 });
+    var expectedSVG = '<g transform=\"matrix(1 0 0 1 90 130)\" clip-path=\"url(#CLIPPATH_0)\"  >\n<clipPath id=\"CLIPPATH_0\" >\n\t<rect transform=\"matrix(1 0 0 1 50.5 50.5)\" x=\"-50\" y=\"-50\" rx=\"0\" ry=\"0\" width=\"100\" height=\"100\" />\n</clipPath>\n<g style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: none; fill-rule: nonzero; opacity: 1;\"   >\n<g transform=\"matrix(1 0 0 1 -90 -130)\">\n\t\t<g transform=\"matrix(1 0 0 1 115 105)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n</g>\n\t\t<g transform=\"matrix(1 0 0 1 55 140)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</g>\n</g>\n</g>\n</g>\n';
+    assert.equal(collection.toSVG(), expectedSVG);
+  });
+
+  QUnit.test('toSVG with a clipPath absolutePositioned', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    collection.clipPath = new fabric.Rect({ width: 100, height: 100 });
+    collection.clipPath.absolutePositioned = true;
+    var expectedSVG = '<g clip-path=\"url(#CLIPPATH_0)\"  >\n<g transform=\"matrix(1 0 0 1 90 130)\"  >\n<clipPath id=\"CLIPPATH_0\" >\n\t<rect transform=\"matrix(1 0 0 1 50.5 50.5)\" x=\"-50\" y=\"-50\" rx=\"0\" ry=\"0\" width=\"100\" height=\"100\" />\n</clipPath>\n<g style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: none; fill-rule: nonzero; opacity: 1;\"   >\n<g transform=\"matrix(1 0 0 1 -90 -130)\">\n\t\t<g transform=\"matrix(1 0 0 1 115 105)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n</g>\n\t\t<g transform=\"matrix(1 0 0 1 55 140)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</g>\n</g>\n</g>\n</g>\n</g>\n';
+    assert.equal(collection.toSVG(), expectedSVG);
+  });
+
+  QUnit.test('toSVG with a collection as a clipPath', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    collection.clipPath = makeCollectionWith2Objects();
+    var expectedSVG = '<g transform=\"matrix(1 0 0 1 90 130)\" clip-path=\"url(#CLIPPATH_0)\"  >\n<clipPath id=\"CLIPPATH_0\" >\n\t\t<rect transform=\"matrix(1 0 0 1 115 105)\" x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n\t\t<rect transform=\"matrix(1 0 0 1 55 140)\" x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</clipPath>\n<g style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: none; fill-rule: nonzero; opacity: 1;\"   >\n<g transform=\"matrix(1 0 0 1 -90 -130)\">\n\t\t<g transform=\"matrix(1 0 0 1 115 105)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-15\" y=\"-5\" rx=\"0\" ry=\"0\" width=\"30\" height=\"10\" />\n</g>\n\t\t<g transform=\"matrix(1 0 0 1 55 140)\"  >\n<rect style=\"stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;\"  x=\"-5\" y=\"-20\" rx=\"0\" ry=\"0\" width=\"10\" height=\"40\" />\n</g>\n</g>\n</g>\n</g>\n';
+    assert.equal(collection.toSVG(), expectedSVG);
+  });
+
+  QUnit.test('cloning collection with 2 objects', function(assert) {
+    var done = assert.async();
+    var collection = makeCollectionWith2Objects();
+    collection.clone(function(clone) {
+
+      assert.ok(clone !== collection);
+      assert.deepEqual(clone.toObject(), collection.toObject());
+
+      done();
+    });
+  });
+
+  QUnit.test('z-index methods with collection objects', function(assert) {
+
+    var textBg = new fabric.Rect({
+      fill: '#abc',
+      width: 100,
+      height: 100
+    });
+
+    var text = new fabric.Text('text');
+    var collection = new fabric.ICollection([textBg, text]);
+
+    canvas.add(collection);
+
+    assert.ok(collection.getObjects()[0] === textBg);
+    assert.ok(collection.getObjects()[1] === text);
+
+    textBg.bringToFront();
+
+    assert.ok(collection.getObjects()[0] === text);
+    assert.ok(collection.getObjects()[1] === textBg);
+
+    textBg.sendToBack();
+
+    assert.ok(collection.getObjects()[0] === textBg);
+    assert.ok(collection.getObjects()[1] === text);
+  });
+
+  QUnit.test('reference on an object', function(assert) {
+    var collection = makeCollectionWith2Objects();
+    var firstObjInGroup = collection.getObjects()[0];
+    var secondObjInGroup = collection.getObjects()[1];
+
+    assert.equal(firstObjInGroup.parent, collection);
+    assert.equal(secondObjInGroup.parent, collection);
+
+    collection.remove(firstObjInGroup);
+    assert.ok(typeof firstObjInGroup.collection === 'undefined');
+  });
+
+  QUnit.test('dirty flag propagation from children up', function(assert) {
+    var g1 = makeCollectionWith4Objects();
+    var obj = g1.item(0);
+    g1.dirty = false;
+    obj.dirty = false;
+    g1.ownCaching = true;
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+    obj.set('fill', 'red');
+    assert.equal(obj.dirty, true, 'Obj has dirty flag set');
+    assert.equal(g1.dirty, true, 'ICollection has dirty flag set');
+  });
+
+  QUnit.test('dirty flag propagation from children up is stopped if collection is not caching', function(assert) {
+    var g1 = makeCollectionWith4Objects();
+    var obj = g1.item(0);
+    g1.dirty = false;
+    obj.dirty = false;
+    g1.ownCaching = false;
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+    obj.set('fill', 'red');
+    assert.equal(obj.dirty, true, 'Obj has dirty flag set');
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+  });
+
+  QUnit.test('dirty flag propagation from children up does not happen if value does not change really', function(assert) {
+    var g1 = makeCollectionWith4Objects();
+    var obj = g1.item(0);
+    obj.fill = 'red';
+    g1.dirty = false;
+    obj.dirty = false;
+    g1.ownCaching = true;
+    assert.equal(obj.dirty, false, 'Obj has no dirty flag set');
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+    obj.set('fill', 'red');
+    assert.equal(obj.dirty, false, 'Obj has no dirty flag set');
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+  });
+
+  QUnit.test('dirty flag propagation from children up with', function(assert) {
+    var g1 = makeCollectionWith4Objects();
+    var obj = g1.item(0);
+    g1.dirty = false;
+    obj.dirty = false;
+    // specify that the collection is caching or the test will fail under node since the
+    // object caching is disabled by default
+    g1.ownCaching = true;
+    assert.equal(g1.dirty, false, 'ICollection has no dirty flag set');
+    obj.set('angle', 5);
+    assert.equal(obj.dirty, false, 'Obj has dirty flag still false');
+    assert.equal(g1.dirty, true, 'ICollection has dirty flag set');
+  });
+
+  QUnit.test('_getCacheCanvasDimensions returns dimensions and zoom for cache canvas are influenced by collection', function(assert) {
+    var g1 = makeCollectionWith4Objects();
+    var obj = g1.item(0);
+    var dims = obj._getCacheCanvasDimensions();
+    g1.scaleX = 2;
+    var dims2 = obj._getCacheCanvasDimensions();
+    g1._applyMatrixDiff();
+    assert.deepEqual(dims, dims2, 'width of cache has increased with collection scale');
+  });
+
+  QUnit.test('test collection - pixels.', function(assert) {
+    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
+        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
+        collection = new fabric.ICollection([rect1, rect2], {opacity: 1, fill: 'blue', strokeWidth: 0, objectCaching: false}),
+        isTransparent = fabric.util.isTransparent,
+        ctx = canvas.contextContainer;
+    canvas.add(collection);
+    canvas.renderAll();
+    assert.equal(canvas.enableRetinaScaling, false, 'enable retina scaling is off');
+    assert.equal(isTransparent(ctx, 0, 0, 0), true, '0,0 is transparent');
+    assert.equal(isTransparent(ctx, 1, 1, 0), false, '1,1 is opaque');
+    assert.equal(isTransparent(ctx, 2, 2, 0), false, '2,2 is opaque');
+    assert.equal(isTransparent(ctx, 3, 3, 0), true, '3,3 is transparent');
+    assert.equal(isTransparent(ctx, 4, 4, 0), true, '4,4 is transparent');
+    assert.equal(isTransparent(ctx, 5, 5, 0), false, '5,5 is opaque');
+    assert.equal(isTransparent(ctx, 6, 6, 0), false, '6,6 is opaque');
+    assert.equal(isTransparent(ctx, 7, 7, 0), true, '7,7 is transparent');
+  });
+
+  QUnit.test('collection toDatalessObject', function(assert) {
+    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
+        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: false}),
+        pathGroup = new fabric.ICollection([rect1, rect2], { sourcePath: 'sourcePath'}),
+        collection = new fabric.ICollection([pathGroup]),
+        dataless = collection.toDatalessObject();
+
+    assert.equal(dataless.objects[0].objects, 'sourcePath', 'the paths have been changed with the sourcePath');
+  });
+
+  QUnit.test('canvas prop propagation with set', function(assert) {
+    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        collection = new fabric.ICollection([rect1, rect2]);
+
+    collection.set('canvas', 'a-canvas');
+    assert.equal(collection.canvas, 'a-canvas', 'canvas has been set');
+    assert.equal(collection._objects[0].canvas, 'a-canvas', 'canvas has been set on object 0');
+    assert.equal(collection._objects[1].canvas, 'a-canvas', 'canvas has been set on object 1');
+  });
+
+  QUnit.test('canvas prop propagation with add', function(assert) {
+    var rect1 = new fabric.Rect({ top: 1, left: 1, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        rect2 = new fabric.Rect({ top: 5, left: 5, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        rect3 = new fabric.Rect({ top: 9, left: 9, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        rect4 = new fabric.Rect({ top: 13, left: 13, width: 2, height: 2, strokeWidth: 0, fill: 'red', opacity: 1, objectCaching: true}),
+        collection = new fabric.ICollection([rect1, rect2]);
+
+    canvas.add(collection);
+    collection.add(rect3);
+    collection.insertAt(rect4, 0);
+    assert.equal(collection.canvas, canvas, 'canvas has been set');
+    collection.forEachObject(obj => assert.equal(obj.canvas, canvas, 'canvas has been set on object'));
+  });
+
+  QUnit.test('apply matrix diff', function (assert) {
+    var rect = new fabric.Rect({ width: 10, height: 10 });
+    var rStart = rect.calcTransformMatrix();
+    var collection = new fabric.ICollection([rect]);
+    var cStart = collection.calcOwnMatrix();
+    var transform = { scaleX: 2 };
+    collection.set(transform);
+    assert.deepEqual(rect.calcTransformMatrix(), rStart, 'object should not be transformed by diff');
+    collection.calcOwnMatrix()
+    collection._applyMatrixDiff();
+    var expected = fabric.util.multiplyTransformMatrices(fabric.util.composeMatrix(transform), rStart);
+    assert.deepEqual(rect.calcTransformMatrix(), expected, 'object should be transformed by diff');
+    transform = { scaleX: 1, left: 50 };
+    expected = fabric.util.multiplyTransformMatrices(fabric.util.composeMatrix(transform), expected);
+    assert.deepEqual(rect.calcTransformMatrix(), expected, 'object should be transformed by diff');
+    collection.set(transform);
+    collection.calcOwnMatrix()
+    collection._applyMatrixDiff();
+    expected = rStart.concat();
+    expected[4] += 50;
+    assert.deepEqual(rect.calcTransformMatrix(), expected, 'object should be transformed by diff');
+    transform = { scaleY: 0.5 };
+    collection.subTargetCheck = false;
+    collection.set(transform);
+    assert.notDeepEqual(collection.calcOwnMatrix(), cStart, 'matrix should be different');
+    collection._applyMatrixDiff();
+    assert.deepEqual(rect.calcTransformMatrix(), expected, 'object should not be transformed by diff when `subTargetCheck = false`');
+  });
+
+  QUnit.test('object monitors', function (assert) {
+    var collection = makeCollectionWith4Objects();
+    var fired = false;
+    collection.__objectMonitor = () => {
+      fired = true;
+    }
+    collection.forEachObject(object => {
+      assert.deepEqual(Object.keys(object.__eventListeners), ['modified', 'selected', 'deselected']);
+    });
+    var item = collection.item(0);
+    collection.remove(item);
+    item.fire('modified');
+    assert.equal(fired, false, 'removed object should not trigger monitor');
+    collection.add(item);
+    item.fire('modified');
+    assert.equal(fired, true, 'added object should trigger monitor');
+  });
+
+  QUnit.test('selection monitor', function (assert) {
+    var collection = makeCollectionWith4Objects();
+    var fireSelectionEvent = (type, target) => {
+      target.fire(type, { target });
+    }
+    assert.deepEqual(collection._activeObjects, [], 'initial state');
+    fireSelectionEvent('selected', collection.item(0));
+    assert.equal(collection._activeObjects.length, 1, 'item(0) should be selected');
+    assert.deepEqual(collection._activeObjects, [collection.item(0)], 'item(0) should be selected');
+    fireSelectionEvent('deselected', collection.item(0));
+    assert.deepEqual(collection._activeObjects, [], 'initial state');
+    fireSelectionEvent('selected', collection.item(3));
+    assert.deepEqual(collection._activeObjects, [collection.item(3)], 'item(3) should be selected');
+    var removed = collection.item(3);
+    collection.remove(removed);
+    assert.deepEqual(collection._activeObjects, [], 'item(3) should not be selected');
+    fireSelectionEvent('selected', removed);
+    assert.deepEqual(collection._activeObjects, [], 'item(3) should not be selected');
+    fireSelectionEvent('selected', collection.item(1));
+    fireSelectionEvent('selected', collection.item(2));
+    assert.equal(collection._activeObjects.length, collection._objects.slice(1).length, 'item(1) item(2) should be selected');
+    assert.deepEqual(collection._activeObjects, collection._objects.slice(1), 'item(1) item(2) should be selected');
+  });
+
+  QUnit.test('render objects without selected objects', function (assert) {
+    var collection = makeCollectionWith4Objects();
+    var rendered = [],
+      ctx = {
+        transform() { },
+        save() { },
+        restore() { },
+      };
+    var fireSelectionEvent = (type, target) => {
+      target.fire(type, { target });
+    }
+    collection.forEachObject(object => {
+      object.render = () => rendered.push(object);
+    });
+    var render = () => {
+      rendered = [];
+      collection.render(ctx);
+    }
+    assert.deepEqual(rendered, [], 'initial state');
+    render();
+    assert.deepEqual(rendered, collection._objects, 'should render all objects');
+    fireSelectionEvent('selected', collection.item(0));
+    render();
+    assert.deepEqual(rendered, collection._objects.slice(1), 'should render all objects except item(0)');
+    fireSelectionEvent('deselected', collection.item(0));
+    render();
+    assert.deepEqual(rendered, collection._objects, 'should render all objects');
+    fireSelectionEvent('selected', collection.item(1));
+    render();
+    var objects = collection._objects.slice();
+    objects.splice(1, 1);
+    assert.deepEqual(rendered, objects, 'should render all objects except item(1)');
+    fireSelectionEvent('selected', collection.item(2));
+    objects.splice(1, 1);
+    render();
+    assert.deepEqual(rendered, objects, 'should render all objects except item(1) & item(2)');
+  });
+
+})();
diff --git a/test/unit/object.js b/test/unit/object.js
index 0c8c9329..fb5cdb43 100644
--- a/test/unit/object.js
+++ b/test/unit/object.js
@@ -428,11 +428,11 @@
     activeSel.toCanvasElement();
 
     assert.equal(cObj.canvas, canvas, 'canvas is the main one step 2');
-
-    activeSel.destroy();
+    
+    activeSel.removeAll();
 
     assert.equal(cObj.canvas, canvas, 'canvas is the main one step 3');
-
+    
   });
 
   QUnit.test('toCanvasElement does not modify oCoords on zoomed canvas', function(assert) {
@@ -1205,4 +1205,27 @@
     object.fill = 'transparent';
     assert.equal(object.hasFill(), false, 'with a color that is transparent, hasFill is true');
   });
+
+  QUnit.test('isDescendantOf', function (assert) {
+    var object = new fabric.Object();
+    var parent = new fabric.Object();
+    var canvas = new fabric.Object();
+    parent.canvas = canvas;
+    object.parent = parent;
+    assert.ok(object.isDescendantOf(parent));
+    object.parent = {
+      parent
+    }
+    assert.ok(object.isDescendantOf(parent));
+    object.parent = {
+      group: parent
+    }
+    assert.ok(object.isDescendantOf(parent));
+    assert.ok(object.isDescendantOf(canvas));
+    object.parent = undefined;
+    assert.ok(object.isDescendantOf(parent) === false);
+    assert.ok(object.isDescendantOf(canvas) === false);
+    object.canvas = canvas;
+    assert.ok(object.isDescendantOf(canvas));
+  });
 })();
diff --git a/test/unit/polygon.js b/test/unit/polygon.js
index e1510f46..0aaa3dca 100644
--- a/test/unit/polygon.js
+++ b/test/unit/polygon.js
@@ -64,27 +64,6 @@
     assert.deepEqual(polygon.get('points'), [{ x: 10, y: 12 }, { x: 20, y: 22 }]);
   });
 
-  QUnit.test('polygon with exactBoundingBox false', function(assert) {
-    var polygon = new fabric.Polygon([{ x: 10, y: 10 }, { x: 20, y: 10 }, { x: 20, y: 100 }], {
-      exactBoundingBox: false,
-      strokeWidth: 60,
-    });
-    var dimensions = polygon._getNonTransformedDimensions();
-    assert.equal(dimensions.x, 70);
-    assert.equal(dimensions.y, 150);
-  });
-
-  QUnit.test('polygon with exactBoundingBox true', function(assert) {
-    var polygon = new fabric.Polygon([{ x: 10, y: 10 }, { x: 20, y: 10 }, { x: 20, y: 100 }], {
-      exactBoundingBox: true,
-      strokeWidth: 60,
-    });
-
-    var dimensions = polygon._getNonTransformedDimensions();
-    assert.equal(Math.round(dimensions.x), 74);
-    assert.equal(Math.round(dimensions.y), 162);
-  });
-
   QUnit.test('complexity', function(assert) {
     var polygon = new fabric.Polygon(getPoints());
     assert.ok(typeof polygon.complexity === 'function');
diff --git a/test/visual/assets/svg-missing-images.svg b/test/visual/assets/svg-missing-images.svg
index 68726dfe..734d7ba3 100644
--- a/test/visual/assets/svg-missing-images.svg
+++ b/test/visual/assets/svg-missing-images.svg
@@ -55,6 +55,8 @@
 		<g>
 			<g>
 
+					<image style="overflow:visible;opacity:0.75;enable-background:new    ;" width="150" height="150" xlink:href="956ACC63.png"  transform="matrix(3.530182e-02 0 0 3.530182e-02 76.0177 50.5407)">
+				</image>
 				<g>
 					<path class="st2" d="M79.7,54.7h-2.8c-0.2,0-0.4-0.2-0.4-0.4v-2.8c0-0.2,0.2-0.4,0.4-0.4h2.8c0.2,0,0.4,0.2,0.4,0.4v2.8
 						C80.2,54.5,80,54.7,79.7,54.7z"/>
@@ -64,6 +66,8 @@
 			</g>
 			<g>
 
+					<image style="overflow:visible;opacity:0.75;enable-background:new    ;" width="125" height="125" xlink:href="956ACC61.png"  transform="matrix(3.492018e-02 0 0 3.492018e-02 76.4828 51.0059)">
+				</image>
 				<g>
 					<polygon class="st4" points="79.4,54 79.2,54.2 77.3,54.2 77.1,54 76.9,53.8 76.9,51.9 77.1,51.6 77.3,51.4 79.3,51.4
 						79.5,51.6 79.7,51.9 79.7,53.8 					"/>
@@ -95,6 +99,8 @@
 		<g>
 			<g>
 
+					<image style="overflow:visible;opacity:0.75;enable-background:new    ;" width="254" height="350" xlink:href="956ACC67.png"  transform="matrix(3.503740e-02 0 0 3.503740e-02 110.8333 48.5576)">
+				</image>
 				<g>
 					<path class="st2" d="M117,58.6h-4.9c-0.2,0-0.4-0.2-0.4-0.4v-8.4c0-0.2,0.2-0.4,0.4-0.4h4.9c0.2,0,0.4,0.2,0.4,0.4v8.4
 						C117.5,58.5,117.3,58.6,117,58.6z"/>
@@ -104,6 +110,8 @@
 			</g>
 			<g>
 
+					<image style="overflow:visible;opacity:0.75;enable-background:new    ;" width="213" height="283" xlink:href="956ACC60.png"  transform="matrix(3.533624e-02 0 0 3.533624e-02 111.5197 49.689)">
+				</image>
 				<g>
 					<polygon class="st4" points="116.4,57 116,57.5 113.1,57.5 112.8,56.9 112.4,56.3 112.4,51.6 112.8,51 113.1,50.5 116.1,50.5
 						116.4,51 116.8,51.7 116.8,56.4 					"/>
@@ -335,6 +343,8 @@
 		<rect x="32.2" y="46.4" class="st19" width="17.5" height="20"/>
 		<g>
 
+				<image style="overflow:visible;opacity:0.75;enable-background:new    ;" width="404" height="521" xlink:href="956ACC6E.png"  transform="matrix(3.539820e-02 0 0 3.539820e-02 90.1152 47.1288)">
+			</image>
 			<g>
 				<rect x="91.8" y="48.8" class="st4" width="7.9" height="12.1"/>
 				<rect x="91.8" y="48.8" class="st6" width="7.9" height="12.1"/>
